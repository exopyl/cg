/workspaces/cg/src/cgimg/color.cpp:
    1|       |#include "color.h"
    2|       |
    3|       |Color::Color ()
    4|      0|{
    5|      0|	SetRGBA (255, 255, 255, 255);
    6|      0|}
    7|       |
    8|       |Color::Color (unsigned char r, unsigned char g, unsigned char b)
    9|      0|{
   10|      0|	SetRGBA (r, g, b, 255);
   11|      0|}
   12|       |
   13|       |Color::~Color ()
   14|      0|{
   15|      0|}
   16|       |
   17|       |void Color::SetRGB (unsigned char r, unsigned char g, unsigned char b)
   18|      0|{
   19|      0|	SetRGBA (r, g, b, 255);
   20|      0|}
   21|       |
   22|       |void Color::SetRGBA (unsigned char r, unsigned char g, unsigned char b, unsigned char a)
   23|      0|{
   24|      0|	c[0] = r;
   25|      0|	c[1] = g;
   26|      0|	c[2] = b;
   27|      0|	c[3] = a;
   28|      0|}
   29|       |
   30|       |
   31|       |//
   32|       |// Conversions
   33|       |//
   34|       |void Color::Int2RGBf (int c, RGBf &rgb)
   35|      0|{
   36|      0|	rgb.r = ((c >> 16) & 255) / 255;
   37|      0|	rgb.g = ((c >> 8) & 255) / 255;
   38|      0|	rgb.b = (c & 255) / 255;
   39|      0|}
   40|       |
   41|       |void Color::Int2RGBc (int c, RGBc &rgb)
   42|      0|{
   43|      0|	rgb.r = ((c >> 16) & 255);
   44|      0|	rgb.g = ((c >> 8) & 255);
   45|      0|	rgb.b = (c & 255);
   46|      0|}
   47|       |
   48|       |int Color::RGBc2Int (unsigned char r, unsigned char g, unsigned char b)
   49|      0|{
   50|      0|	return ((int)(r) << 16) | ((int)(g) << 8) | (int)(b);
   51|      0|}
   52|       |
   53|       |int Color::RGBf2Int (float r, float g, float b)
   54|      0|{
   55|      0|	return ((int)(r * 255) << 16) | ((int)(g * 255) << 8) | (int)(b * 255);
   56|      0|}
   57|       |
   58|       |int Color::RGBc2Int (RGBc rgb)
   59|      0|{
   60|      0|	return RGBc2Int(rgb.r, rgb.g, rgb.b);
   61|      0|}
   62|       |
   63|       |int Color::RGBAc2Int (RGBAc rgba)
   64|      0|{
   65|      0|	return RGBc2Int(rgba.r, rgba.g, rgba.b);
   66|      0|}
   67|       |
   68|       |// r,g,b values are from 0 to 1
   69|       |// h = [0,360], s = [0,1], v = [0,1]
   70|       |//		if s == 0, then h = -1 (undefined)
   71|       |void Color::RGBftoHSV (RGBf rgb, HSVf hsv)
   72|      0|{
   73|      0|	float r = rgb.r;
   74|      0|	float g = rgb.g;
   75|      0|	float b = rgb.b;
   76|      0|	float h, s, v;
   77|       |
   78|      0|	float min, max, delta;
   79|      0|	min = MIN3( r, g, b );
   80|      0|	max = MAX3( r, g, b );
   81|      0|	v = max;				// v
   82|      0|	delta = max - min;
   83|      0|	if( max != 0 )
   84|      0|		s = delta / max;		// s
   85|      0|	else {
   86|       |		// r = g = b = 0		// s = 0, v is undefined
   87|      0|		s = 0;
   88|      0|		h = -1;
   89|      0|		return;
   90|      0|	}
   91|      0|	if( r == max )
   92|      0|		h = ( g - b ) / delta;		// between yellow & magenta
   93|      0|	else if( g == max )
   94|      0|		h = 2 + ( b - r ) / delta;	// between cyan & yellow
   95|      0|	else
   96|      0|		h = 4 + ( r - g ) / delta;	// between magenta & cyan
   97|      0|	h *= 60;				// degrees
   98|      0|	if( h < 0 )
   99|      0|		h += 360;
  100|       |
  101|      0|	hsv.h = h;
  102|      0|	hsv.s = s;
  103|      0|	hsv.v = v;
  104|      0|}
  105|       |
  106|       |void Color::HSVtoRGBf (HSVf hsv, RGBf rgb)
  107|      0|{
  108|      0|	float h = hsv.h;
  109|      0|	float s = hsv.s;
  110|      0|	float v = hsv.v;
  111|      0|	float r, g, b;
  112|       |
  113|      0|	int i;
  114|      0|	float f, p, q, t;
  115|      0|	if( s == 0 ) {
  116|       |		// achromatic (grey)
  117|      0|		r = g = b = v;
  118|      0|		return;
  119|      0|	}
  120|      0|	h /= 60;			// sector 0 to 5
  121|      0|	i = floor( h );
  122|      0|	f = h - i;			// factorial part of h
  123|      0|	p = v * ( 1 - s );
  124|      0|	q = v * ( 1 - s * f );
  125|      0|	t = v * ( 1 - s * ( 1 - f ) );
  126|      0|	switch( i ) {
  127|      0|		case 0: r = v; g = t; b = p; break;
  128|      0|		case 1: r = q; g = v; b = p; break;
  129|      0|		case 2: r = p; g = v; b = t; break;
  130|      0|		case 3: r = p; g = q; b = v; break;
  131|      0|		case 4: r = t; g = p; b = v; break;
  132|      0|		case 5: r = v; g = p; b = q; break;
  133|      0|	}
  134|      0|	rgb.r = r;
  135|      0|	rgb.g = g;
  136|      0|	rgb.b = b;
  137|      0|}
  138|       |
  139|       |//
  140|       |void Color::RGBftoHSL (RGBf rgb, HSLf hsl)
  141|      0|{
  142|      0|        float max = MAX3( rgb.r, rgb.g, rgb.b );
  143|      0|        float min = MIN3( rgb.r, rgb.g, rgb.b );
  144|      0|        float add = max + min;
  145|      0|        float sub = max - min;
  146|       |        
  147|      0|        float h;
  148|      0|	if (max == min) {
  149|      0|		h = 0;
  150|      0|        } else if (max == rgb.r) {
  151|      0|		h = (int)(60 * (rgb.g - rgb.b) / sub + 360) % 360;
  152|      0|        } else if (max == rgb.g) {
  153|      0|		h = 60 * (rgb.b - rgb.r) / sub + 120;
  154|      0|        } else if (max == rgb.b) {
  155|      0|            h = 60 * (rgb.r - rgb.g) / sub + 240;
  156|      0|        }
  157|       |        
  158|      0|        float l = add / 2.;
  159|       |        
  160|      0|	float s;
  161|      0|        if (max == min) {
  162|      0|		s = 0;
  163|      0|        } else if (l <= .5) {
  164|      0|		s = sub / add;
  165|      0|        } else {
  166|      0|		s = sub / (2 - add);
  167|      0|        }
  168|       |
  169|      0|	hsl.h = h;
  170|      0|	hsl.s = s;
  171|      0|	hsl.l = l;
  172|      0|}
  173|       |
  174|       |//
  175|       |void Color::HSLtoRGBf (HSLf hsl, RGBf rgb)
  176|      0|{
  177|      0|	float q;
  178|      0|	if (hsl.l < 1 / 2) {
  179|      0|		q = hsl.l * (1 + hsl.s);
  180|      0|        } else {
  181|      0|		q = hsl.l + hsl.s - (hsl.l * hsl.s);
  182|      0|        }
  183|       |        
  184|      0|        float p = 2 * hsl.l - q;
  185|      0|	float hk = ((int)hsl.h % 360) / 360;
  186|      0|	float tr = hk + 1 / 3;
  187|      0|        float tg = hk;
  188|      0|        float tb = hk - 1 / 3;
  189|       |        
  190|      0|        float tc[3] = {tr,tg,tb};
  191|      0|	for (int n=0; n<3; n++)
  192|      0|        {
  193|      0|            float t = tc[n];
  194|      0|            if (t < 0) t += 1;
  195|      0|            if (t > 1) t -= 1;
  196|      0|	    if (t < 1 / 6) {
  197|      0|                tc[n] = p + ((q - p) * 6 * t);
  198|      0|            } else if (t < 1 / 2) {
  199|      0|                tc[n] = q;
  200|      0|            } else if (t < 2 / 3) {
  201|      0|                tc[n] = p + ((q - p) * 6 * (2 / 3 - t));
  202|      0|            } else {
  203|      0|                tc[n] = p;
  204|      0|            }
  205|      0|        }
  206|       |        
  207|      0|	rgb.r = tc[0];
  208|      0|	rgb.g = tc[1];
  209|      0|	rgb.b = tc[2];
  210|      0|}
  211|       |
  212|       |void Color::HSLf2HSVf(HSLf hsl, HSVf hsv)
  213|      0|{
  214|      0|	RGBf rgb = {0, 0, 0};
  215|      0|	HSLtoRGBf (hsl, rgb);
  216|      0|	RGBftoHSV (rgb, hsv);
  217|      0|}
  218|       |    
  219|       |void Color::HSVf2HSLf(HSVf hsv, HSLf hsl)
  220|      0|{
  221|      0|	RGBf rgb = {0, 0, 0};
  222|      0|	HSVtoRGBf (hsv, rgb);
  223|      0|	RGBftoHSL (rgb, hsl);
  224|      0|}
  225|       |
  226|       |
  227|       |
  228|       |
  229|       |
  230|       |void color_jet(float index, float *_r, float *_g, float *_b)
  231|      0|{
  232|      0|	const float ri[5] = {0.f, 0.35f, 0.66f, 0.89f, 1.f};
  233|      0|	const float rv[5] = {0.f, 0.f, 1.f, 1.f, 0.5f};
  234|      0|	const float gi[6] = {0.f, 0.125f, 0.375f, 0.64f, 0.91f, 1.f};
  235|      0|	const float gv[6] = {0.f, 0.f, 1.f, 1.f, 0.f, 0.f};
  236|      0|	const float bi[5] = {0.f, 0.11f, 0.34f, 0.65f, 1.f};
  237|      0|	const float bv[5] = {0.5f, 1.f, 1.f, 0.f, 0.f};
  238|       |
  239|      0|	float r, g, b;
  240|      0|	int j;
  241|       |	
  242|       |	// red
  243|      0|	for (j=1; j<5; j++) if (ri[j] > index) break;
  244|      0|	r = ((rv[j]-rv[j-1])*index+rv[j-1]*ri[j]-rv[j]*ri[j-1])/(ri[j]-ri[j-1]);
  245|       |	
  246|       |	// green
  247|      0|	for (j=1; j<5; j++) if (gi[j] > index) break;
  248|      0|	g = ((gv[j]-gv[j-1])*index+gv[j-1]*gi[j]-gv[j]*gi[j-1])/(gi[j]-gi[j-1]);
  249|       |	
  250|       |	// blue
  251|      0|	for (j=1; j<5; j++) if (bi[j] > index) break;
  252|      0|	b = ((bv[j]-bv[j-1])*index+bv[j-1]*bi[j]-bv[j]*bi[j-1])/(bi[j]-bi[j-1]);
  253|       |
  254|      0|	*_r = r;
  255|      0|	*_g = g;
  256|      0|	*_b = b;
  257|      0|}
  258|       |
  259|       |void color_jet_int (float index, int *_r, int *_g, int *_b)
  260|      0|{
  261|      0|	float fr, fg, fb;
  262|      0|	color_jet (index, &fr, &fg, &fb);
  263|       |
  264|      0|	*_r = (int)(255.*fr);
  265|      0|	*_g = (int)(255.*fg);
  266|      0|	*_b = (int)(255.*fb);
  267|      0|}

/workspaces/cg/src/cgimg/color.h:
    1|       |#pragma once
    2|       |
    3|       |#include "../cgmath/common.h"
    4|       |
    5|       |typedef struct RGBc  { unsigned char r, g, b; }    RGBc;
    6|       |typedef struct RGBf  { float r, g, b; }            RGBf;
    7|       |typedef struct RGBAc { unsigned char r, g, b, a; } RGBAc;
    8|       |typedef struct RGBAf { float r, g, b, a; }         RGBAf;
    9|       |typedef struct HSVf  { float h, s, v; }            HSVf;
   10|       |typedef struct HSLf  { float h, s, l; }            HSLf;
   11|       |// h = [0,360], s = [0,1], v = [0,1]
   12|       |//		if s == 0, then h = -1 (undefined)
   13|       |
   14|       |class Color
   15|       |{
   16|       |public:
   17|       |	Color ();
   18|       |	Color (unsigned char r, unsigned char g, unsigned char b);
   19|      0|	Color(const Color& color) { *this = color; };
   20|       |	~Color ();
   21|       |
   22|       |	void SetRGB (unsigned char r, unsigned char g, unsigned char b);
   23|       |	void SetRGBA (unsigned char r, unsigned char g, unsigned char b, unsigned char a);
   24|       |
   25|      0|	inline unsigned char operator[](unsigned int i) { return (i<4)? c[i]:0; };
   26|      0|	inline unsigned char r() { return c[0]; };
   27|      0|	inline unsigned char g() { return c[1]; };
   28|      0|	inline unsigned char b() { return c[2]; };
   29|      0|	inline unsigned char a() { return c[3]; };
   30|       |
   31|       |	//
   32|       |	// Conversions as services
   33|       |	// References : http://www.cs.rit.edu/~ncs/color/t_convert.html
   34|       |	//
   35|       |	static void Int2RGBf  (int c, RGBf &rgb);
   36|       |	static void Int2RGBc  (int c, RGBc &rgb);
   37|       |	static int  RGBc2Int  (unsigned char r, unsigned char g, unsigned char b);
   38|       |	static int  RGBf2Int  (float r, float g, float b);
   39|       |	static int  RGBf2Int  (RGBf rgb);
   40|       |	static int  RGBc2Int  (RGBc rgb);
   41|       |	static int  RGBAc2Int (RGBAc rgba);
   42|       |	static void RGBftoHSV (RGBf rgb, HSVf hsv);
   43|       |	static void HSVtoRGBf (HSVf hsv, RGBf rgb);
   44|       |	static void RGBftoHSL (RGBf rgb, HSLf hsl);
   45|       |	static void HSLtoRGBf (HSLf hsl, RGBf rgb);
   46|       |	static void HSLf2HSVf (HSLf hsl, HSVf hsv);
   47|       |	static void HSVf2HSLf (HSVf hsv, HSLf hsl);
   48|       |
   49|       |private:
   50|       |	unsigned char c[4];
   51|       |};
   52|       |
   53|       |
   54|       |// http://stackoverflow.com/questions/7706339/grayscale-to-red-green-blue-matlab-jet-color-scale
   55|       |extern void color_jet(float index, float *_r, float *_g, float *_b);
   56|       |extern void color_jet_int (float index, int *_r, int *_g, int *_b);

/workspaces/cg/src/cgimg/image.cpp:
    1|       |#include <stdlib.h>
    2|       |#include <stdio.h>
    3|       |#include <string.h>
    4|       |
    5|       |#include "image.h"
    6|       |#include "color.h"
    7|       |#include "../cgmath/TVector2.h"
    8|       |
    9|       |#include <list>
   10|       |using namespace std;
   11|       |
   12|       |int Img::AreIdentical (Img *pImg1, Img *pImg2)
   13|      0|{
   14|      0|	if (pImg1->m_iWidth != pImg2->m_iWidth && pImg1->m_iHeight != pImg2->m_iHeight)
   15|      0|		return -1;
   16|       |
   17|      0|	int nDifferentPixels = 0;
   18|      0|	for (unsigned int j=0; j<pImg1->m_iHeight; j++)
   19|      0|		for (unsigned int i=0; i<pImg1->m_iWidth; i++)
   20|      0|		{
   21|      0|			if (pImg1->get_pixel_int(i,j) != pImg2->get_pixel_int(i,j))
   22|      0|				nDifferentPixels++;
   23|      0|		}
   24|       |
   25|      0|	return nDifferentPixels;
   26|      0|}
   27|       |
   28|       |
   29|       |int Img::resize_memory (unsigned int width, unsigned int height, bool use_palette)
   30|     11|{
   31|     11|	if (width == m_iWidth && height == m_iHeight)
   32|      3|		return 0;
   33|       |	
   34|      8|	if (m_pPixels)
   35|      0|		free (m_pPixels);
   36|       |
   37|      8|	m_iWidth = width;
   38|      8|	m_iHeight = height;
   39|       |
   40|      8|	if (use_palette)
   41|      0|	{
   42|      0|		m_pPixels = (unsigned char*)malloc(m_iWidth*m_iHeight*sizeof(unsigned char));
   43|      0|		bUsePalette = true;
   44|      0|		m_pPalette = new Palette ();
   45|      0|	}
   46|      8|	else
   47|      8|	{
   48|      8|		m_pPixels = (unsigned char*)malloc(4*m_iWidth*m_iHeight*sizeof(unsigned char));
   49|      8|		bUsePalette = false;
   50|      8|		m_pPalette = NULL;
   51|      8|	}
   52|       |	
   53|      8|	return (m_pPixels)? 0 : -1;
   54|     11|}
   55|       |
   56|       |Img::Img (unsigned int w, unsigned int h, bool use_palette)
   57|      8|{
   58|      8|	m_iWidth = 0;
   59|      8|	m_iHeight = 0;
   60|      8|	m_pPixels = NULL;
   61|      8|	bUsePalette = use_palette;
   62|      8|	m_pPalette = NULL;
   63|      8|	resize_memory (w,h, use_palette);
   64|      8|}
   65|       |
   66|       |Img::Img (const Img &img)
   67|      0|{
   68|      0|	m_iWidth = 0;
   69|      0|	m_iHeight = 0;
   70|      0|	m_pPixels = NULL;
   71|      0|	resize_memory (img.m_iWidth, img.m_iHeight, false);
   72|      0|	if (!img.bUsePalette)
   73|      0|		memcpy (m_pPixels, img.m_pPixels, 4*m_iWidth*m_iHeight*sizeof(unsigned char));
   74|      0|	else
   75|      0|	{
   76|      0|		for(unsigned int y=0;y<m_iHeight;y++)
   77|      0|			for(unsigned int x=0;x<m_iWidth;x++)
   78|      0|			{
   79|      0|				unsigned char r, g, b, a;
   80|      0|				img.get_pixel(x,y, &r, &g, &b, &a);
   81|      0|				set_pixel(x,y, r, g, b, a);
   82|      0|			}
   83|      0|	}
   84|       |
   85|      0|	bUsePalette = 0;
   86|      0|	m_pPalette = NULL;
   87|      0|}
   88|       |
   89|       |Img::~Img ()
   90|      7|{
   91|      7|	if (m_pPixels)
   92|      7|		free (m_pPixels);
   93|       |
   94|      7|	if (m_pPalette)
   95|      0|		delete m_pPalette;
   96|      7|}
   97|       |
   98|       |int Img::init_color (unsigned char r, unsigned char g, unsigned char b, unsigned char a)
   99|      0|{
  100|      0|	for (unsigned int j=0; j<m_iHeight; j++)
  101|      0|		for (unsigned int i=0; i<m_iWidth; i++)
  102|      0|			set_pixel (i, j, r, g, b, a);
  103|       |
  104|      0|	return 0;
  105|      0|}
  106|       |
  107|       |void Img::set_pixel (unsigned int i, unsigned int j,
  108|       |		     unsigned char r, unsigned char g, unsigned char b, unsigned char a)
  109|   442k|{
  110|   442k|	if (i>=m_iWidth || j>=m_iHeight)
  111|  6.46k|	{
  112|  6.46k|		printf ("!!! [Img::set_pixel] %d %d in %d %d\n", i, j, m_iWidth, m_iHeight);
  113|  6.46k|		return;
  114|  6.46k|	}
  115|   435k|	unsigned int index = j*m_iWidth+i;
  116|   435k|	if (bUsePalette)
  117|      0|	{
  118|      0|		m_pPixels[index] = m_pPalette->AddColor (r, g, b, a);
  119|      0|	}
  120|   435k|	else
  121|   435k|	{
  122|   435k|		index *= 4;
  123|   435k|		m_pPixels[index]   = r;
  124|   435k|		m_pPixels[index+1] = g;
  125|   435k|		m_pPixels[index+2] = b;
  126|   435k|		m_pPixels[index+3] = a;
  127|   435k|	}
  128|   435k|}
  129|       |
  130|       |void Img::set_pixel_int (unsigned int i, unsigned int j, int c)
  131|      0|{
  132|      0|	RGBc rgb;
  133|      0|	Color::Int2RGBc (c, rgb);
  134|      0|	printf ("##%d => %d %d %d\n", c, rgb.r, rgb.g, rgb.b);
  135|      0|	set_pixel (i, j, rgb.r, rgb.g, rgb.b, 255);
  136|      0|}
  137|       |
  138|       |void Img::set_pixel_index (unsigned int i, unsigned int j, unsigned int index)
  139|      0|{
  140|      0|	if (i>=m_iWidth || j>=m_iHeight)
  141|      0|	{
  142|      0|		printf ("!!! [Img::set_pixel_index] %d %d in %d %d\n", i, j, m_iWidth, m_iHeight);
  143|      0|		return;
  144|      0|	}
  145|      0|	if (!bUsePalette)
  146|      0|	{
  147|      0|		printf ("!!! [Img::set_pixel_index] bUsePalette = %d\n", bUsePalette);
  148|      0|		return;
  149|      0|	}
  150|      0|	m_pPixels[j*m_iWidth+i] = index;
  151|      0|}
  152|       |
  153|       |void Img::get_pixel (unsigned int i, unsigned int j,
  154|       |		     unsigned char *r, unsigned char *g, unsigned char *b, unsigned char *a) const
  155|      0|{
  156|      0|	if (i>=m_iWidth || j>= m_iHeight)
  157|      0|	{
  158|      0|		printf ("!!! [Img::get_pixel] %d %d in %d %d\n", i, j, m_iWidth, m_iHeight);
  159|      0|		*r = 0; *g = 0; *b = 0; *a = 0;
  160|      0|		return;
  161|      0|	}
  162|      0|	unsigned int index = j*m_iWidth+i;
  163|      0|	if (!bUsePalette)
  164|      0|	{
  165|      0|		*r = m_pPixels[4*index];
  166|      0|		*g = m_pPixels[4*index+1];
  167|      0|		*b = m_pPixels[4*index+2];
  168|      0|		*a = m_pPixels[4*index+3];
  169|      0|	}
  170|      0|	else
  171|      0|	{
  172|      0|		unsigned int icolor = m_pPixels[index];
  173|      0|		*r = m_pPalette->m_pColors[icolor].r();
  174|      0|		*g = m_pPalette->m_pColors[icolor].g();
  175|      0|		*b = m_pPalette->m_pColors[icolor].b();
  176|      0|		*a = m_pPalette->m_pColors[icolor].a();
  177|      0|	}
  178|      0|}
  179|       |
  180|       |int Img::get_pixel_int (unsigned int i, unsigned int j)
  181|      0|{
  182|      0|	RGBAc rgba;
  183|       |	//unsigned char r, g, b, a;
  184|       |	//get_pixel (i, j, &r, &g, &b, &a);
  185|       |	//printf ("%d x %d => %d %d %d %d\n", i, j, r, g, b, a);
  186|      0|	get_pixel (i, j, &rgba.r, &rgba.g, &rgba.b, &rgba.a);
  187|       |	//printf ("%d %d %d %d => %d\n", rgba.r, rgba.g, rgba.b, rgba.a, RGBAc2Int (rgba));
  188|      0|	return Color::RGBAc2Int (rgba);
  189|      0|}
  190|       |
  191|       |int Img::get_pixel_index (unsigned int i, unsigned int j)
  192|      0|{
  193|      0|	if (!bUsePalette)
  194|      0|		return -1;
  195|      0|	return m_pPixels[m_iWidth*j+i];
  196|      0|}
  197|       |
  198|       |unsigned char Img::get_r (unsigned int i, unsigned int j)
  199|      0|{
  200|      0|	if (i>=m_iWidth || j>= m_iHeight)
  201|      0|	{
  202|      0|		printf ("!!! [Img::get_pixel] %d %d in %d %d\n", i, j, m_iWidth, m_iHeight);
  203|      0|		return 0;
  204|      0|	}
  205|      0|	return m_pPixels[4*(j*m_iWidth+i)];
  206|      0|}
  207|       |
  208|       |unsigned char Img::get_g (unsigned int i, unsigned int j)
  209|      0|{
  210|      0|	if (i>=m_iWidth || j>= m_iHeight)
  211|      0|	{
  212|      0|		printf ("!!! [Img::get_pixel] %d %d in %d %d\n", i, j, m_iWidth, m_iHeight);
  213|      0|		return 0;
  214|      0|	}
  215|      0|	return m_pPixels[4*(j*m_iWidth+i)+1];
  216|      0|}
  217|       |
  218|       |unsigned char Img::get_b (unsigned int i, unsigned int j)
  219|      0|{
  220|      0|	if (i>=m_iWidth || j>= m_iHeight)
  221|      0|	{
  222|      0|		printf ("!!! [Img::get_pixel] %d %d in %d %d\n", i, j, m_iWidth, m_iHeight);
  223|      0|		return 0;
  224|      0|	}
  225|      0|	return m_pPixels[4*(j*m_iWidth+i)+2];
  226|      0|}
  227|       |
  228|       |unsigned char Img::get_a (unsigned int i, unsigned int j)
  229|      0|{
  230|      0|	if (i>=m_iWidth || j>= m_iHeight)
  231|      0|	{
  232|      0|		printf ("!!! [Img::get_pixel] %d %d in %d %d\n", i, j, m_iWidth, m_iHeight);
  233|      0|		return 0;
  234|      0|	}
  235|      0|	return m_pPixels[4*(j*m_iWidth+i)+3];
  236|      0|}
  237|       |
  238|       |void Img::get_nearest_pixel (float u, float v,
  239|       |			     unsigned char *r, unsigned char *g, unsigned char *b, unsigned char *a)
  240|      0|{
  241|      0|	unsigned int i = (unsigned int)(u*m_iWidth);
  242|      0|	unsigned int j = (unsigned int)(v*m_iHeight);
  243|      0|	get_pixel (i, j, r, g, b, a);
  244|      0|}
  245|       |
  246|       |// test images
  247|       |void Img::init_test_grayscale1 (unsigned int h)
  248|      0|{
  249|      0|	resize_memory (255, h);
  250|      0|	for (unsigned int j=0; j<m_iHeight; j++)
  251|      0|		for (unsigned int i=0; i<m_iWidth; i++)
  252|      0|			set_pixel (i, j, i, i, i, 255);
  253|      0|}
  254|       |
  255|       |void Img::init_test_grayscale2 (unsigned int size)
  256|      0|{
  257|      0|	resize_memory (8*size, 8*size);
  258|      0|	for (unsigned int j=0; j<8; j++)
  259|      0|		for (unsigned int i=0; i<8; i++)
  260|      0|		{
  261|      0|			unsigned char level = 4 * (8*j+i);
  262|      0|			for (unsigned int kj=0; kj<size; kj++)
  263|      0|				for (unsigned int ki=0; ki<size; ki++)
  264|      0|					set_pixel (i*size+ki, j*size+kj, level, level, level, 255);
  265|      0|		}
  266|      0|}
  267|       |
  268|       |void Img::init_test_color_jet (unsigned int w, unsigned int h)
  269|      0|{
  270|      0|	resize_memory (w, h);
  271|      0|	for (unsigned int i=0; i<m_iWidth; i++)
  272|      0|	{
  273|      0|		int r, g, b;
  274|      0|		color_jet_int ((float)i/m_iWidth, &r, &g, &b);
  275|      0|		for (unsigned int j=0; j<m_iHeight; j++)
  276|      0|			set_pixel (i, j, (unsigned char)r, (unsigned char)g, (unsigned char)b, 255);
  277|      0|	}
  278|      0|}
  279|       |
  280|       |// http://docs.gimp.org/2.6/en/gimp-tool-desaturate.html
  281|       |void Img::convert_to_grayscale (grayscale_method_type grayscale_method_id, unsigned char nlevels)
  282|      0|{
  283|      0|	int n = m_iWidth * m_iHeight;
  284|       |
  285|      0|	switch (grayscale_method_id)
  286|      0|	{
  287|      0|	case GRAYSCALE_LUMINOSITY:
  288|      0|	{
  289|      0|		float kr = 0.21;
  290|      0|		float kg = 0.71;
  291|      0|		float kb = 0.07;
  292|       |		/*
  293|       |		  float kr = 0.3;
  294|       |		  float kg = 0.59;
  295|       |		  float kb = 0.11;
  296|       |		*/
  297|      0|		for (int i=0; i<n; i++)
  298|      0|		{
  299|      0|			unsigned char gray = (unsigned char)(kr * m_pPixels[4*i] + kg * m_pPixels[4*i+1] + kb * m_pPixels[4*i+2]);
  300|      0|			m_pPixels[4*i]   = gray;
  301|      0|			m_pPixels[4*i+1] = gray;
  302|      0|			m_pPixels[4*i+2] = gray;
  303|      0|		}
  304|      0|	}
  305|      0|	break;
  306|      0|	case GRAYSCALE_LIGHTNESS:
  307|      0|		for (int i=0; i<n; i++)
  308|      0|		{
  309|      0|			unsigned char r = m_pPixels[4*i];
  310|      0|			unsigned char g = m_pPixels[4*i+1];
  311|      0|			unsigned char b = m_pPixels[4*i+2];
  312|      0|			unsigned char gray = (MIN(MIN(r,g), b) + MAX(MAX(r,g),b))/2.;
  313|      0|			m_pPixels[4*i]   = gray;
  314|      0|			m_pPixels[4*i+1] = gray;
  315|      0|			m_pPixels[4*i+2] = gray;
  316|      0|		}
  317|      0|		break;
  318|      0|	case GRAYSCALE_AVERAGE:
  319|      0|		for (int i=0; i<n; i++)
  320|      0|		{
  321|      0|			unsigned char gray = (unsigned char)((m_pPixels[4*i] + m_pPixels[4*i+1] + m_pPixels[4*i+2])/3.);
  322|      0|			m_pPixels[4*i]   = gray;
  323|      0|			m_pPixels[4*i+1] = gray;
  324|      0|			m_pPixels[4*i+2] = gray;
  325|      0|		}
  326|      0|		break;
  327|      0|	default:
  328|      0|		break;
  329|      0|	}
  330|       |
  331|      0|     if (nlevels < 2)
  332|      0|	  nlevels = 2;
  333|      0|     if (nlevels != 255)
  334|      0|     {
  335|      0|	  for (int i=0; i<n; i++)
  336|      0|	  {
  337|      0|	       unsigned char gray = m_pPixels[4*i];
  338|      0|	       unsigned char interval = (int)(nlevels * gray / 256.);
  339|      0|	       gray = (unsigned char)(255.*interval/(nlevels-1));
  340|      0|	       m_pPixels[4*i]   = gray;
  341|      0|	       m_pPixels[4*i+1] = gray;
  342|      0|	       m_pPixels[4*i+2] = gray;
  343|      0|	  }
  344|      0|     }
  345|      0|}
  346|       |
  347|       |void Img::get_histogram (float histogram[256], int normalized)
  348|      0|{
  349|      0|     memset (histogram, 0, 256*sizeof(float));
  350|       |     
  351|      0|     for (unsigned int j=0; j<m_iHeight; j++)
  352|      0|     {
  353|      0|	  for (unsigned int i=0; i<m_iWidth; i++)
  354|      0|	  {
  355|      0|	       unsigned int index = j * m_iWidth + i;
  356|      0|	       unsigned char red = m_pPixels[4*index];
  357|      0|	       histogram[red] += 1.;
  358|      0|	  }
  359|      0|     }
  360|       |
  361|       |     // normalize the histogram (sum = 1)
  362|      0|     if (normalized)
  363|      0|     {
  364|      0|	     float s = 1./(m_iWidth * m_iHeight);
  365|      0|	     for (int j=0; j<256; j++)
  366|      0|		     histogram[j] *= s;
  367|      0|     }
  368|      0|}
  369|       |
  370|       |Img* Img::get_histogram_img (unsigned int height)
  371|      0|{
  372|      0|	float histogram[256];
  373|      0|	get_histogram (histogram, 1);
  374|       |
  375|      0|	Img *histo = new Img (256, height);
  376|      0|	for (unsigned int j=0; j<histo->m_iHeight; j++)
  377|      0|		for (unsigned int i=0; i<histo->m_iWidth; i++)
  378|      0|		{
  379|      0|			if (histogram[i] > (float)j*0.01/histo->m_iHeight)
  380|      0|				histo->set_pixel (i, histo->m_iHeight-1-j, 255, 255, 255, 255);
  381|      0|			else
  382|      0|				histo->set_pixel (i, histo->m_iHeight-1-j, 0, 0, 0, 255);
  383|      0|		}
  384|       |
  385|      0|	return histo;
  386|      0|}
  387|       |
  388|       |void Img::histogram_equalization (void)
  389|      0|{
  390|       |     // eval the histogram
  391|      0|     float histogram[256];
  392|      0|     get_histogram (histogram);
  393|       |
  394|       |     // eval the cumulative distribution function
  395|      0|     float cdf[256];
  396|      0|     float sum = 0.;
  397|      0|     for (int i=0; i<256; i++)
  398|      0|     {
  399|      0|	  sum += histogram[i];
  400|      0|	  cdf[i] = sum;
  401|      0|    }
  402|       |
  403|       |     // image mapping
  404|      0|    for (unsigned int j=0; j<m_iHeight; j++)
  405|      0|     {
  406|      0|	  for (unsigned int i=0; i<m_iWidth; i++)
  407|      0|	  {
  408|      0|	       unsigned int index = j * m_iWidth + i;
  409|      0|	       unsigned char red = m_pPixels[4*index];
  410|      0|	       float grey = cdf[red];
  411|      0|	       m_pPixels[4*index]   = (unsigned char)(grey*255.0);
  412|      0|	       m_pPixels[4*index+1] = (unsigned char)(grey*255.0);
  413|      0|	       m_pPixels[4*index+2] = (unsigned char)(grey*255.0);
  414|      0|	  }
  415|      0|     }
  416|      0|}
  417|       |
  418|       |void Img::histogram_equalization_bezier (CurveBezier *bezier)
  419|      0|{
  420|      0|	if (bezier == NULL)
  421|      0|		bezier = new CurveBezier();
  422|      0|	vec3 v0, v1, v2, v3;
  423|      0|	vec3_init (v0, 0., 255., 0.);
  424|      0|	vec3_init (v1, 10., 0., 0.);
  425|      0|	vec3_init (v2, 245., 0., 0.);
  426|      0|	vec3_init (v3, 255., 255., 0.);
  427|      0|	bezier->addControlPoint (v0);
  428|      0|	bezier->addControlPoint (v1);
  429|      0|	bezier->addControlPoint (v2);
  430|      0|	bezier->addControlPoint (v3);
  431|       |
  432|       |     // eval the histogram
  433|      0|     float histogram[256];
  434|      0|     get_histogram (histogram);
  435|       |
  436|       |     // eval the cumulative distribution function
  437|      0|     float cdf[256];
  438|      0|     float sum = 0.;
  439|      0|     for (int i=0; i<256; i++)
  440|      0|     {
  441|      0|	  sum += histogram[i];
  442|      0|	  cdf[i] = sum;
  443|      0|     }
  444|       |     
  445|      0|     float *bezier_interpolated = (float*)malloc(256*sizeof(float));
  446|      0|     for (int i=0; i<256; i++)
  447|      0|     {
  448|      0|	     vec3 pt;
  449|      0|	     bezier->eval_on_x (i, pt);
  450|      0|	     bezier_interpolated[i] = pt[1];
  451|      0|     }
  452|      0|     output_1array (bezier_interpolated, 256, (char*)"output.dat");
  453|      0|     bezier->export_interpolated ((char*)"bezier.dat", 256);
  454|       |
  455|       |     // image mapping
  456|      0|     for (unsigned int j=0; j<m_iHeight; j++)
  457|      0|     {
  458|      0|	  for (unsigned int i=0; i<m_iWidth; i++)
  459|      0|	  {
  460|      0|	       unsigned int index = j * m_iWidth + i;
  461|      0|	       unsigned char red = m_pPixels[4*index];
  462|      0|	       red = (unsigned char)bezier_interpolated[red];
  463|      0|	       float grey = cdf[red];
  464|      0|	       m_pPixels[4*index]   = (unsigned char)(grey*255.0);
  465|      0|	       m_pPixels[4*index+1] = (unsigned char)(grey*255.0);
  466|      0|	       m_pPixels[4*index+2] = (unsigned char)(grey*255.0);
  467|      0|	  }
  468|      0|     }
  469|      0|}
  470|       |
  471|       |void Img::invert (void)
  472|      0|{
  473|      0|	int n = m_iWidth*m_iHeight;
  474|      0|	for (int index=0; index<n; index++)
  475|      0|	{
  476|      0|		m_pPixels[4*index]   = 255-m_pPixels[4*index];
  477|      0|		m_pPixels[4*index+1] = 255-m_pPixels[4*index+1];
  478|      0|		m_pPixels[4*index+2] = 255-m_pPixels[4*index+2];
  479|      0|	}
  480|      0|}
  481|       |
  482|       |void Img::contrast (float k)
  483|      0|{
  484|      0|	unsigned char min = 255;
  485|      0|	unsigned char max = 0;
  486|       |
  487|      0|	int n = m_iWidth*m_iHeight;
  488|      0|	for (int i=0; i<n; i++)
  489|      0|	{
  490|      0|		if (min > m_pPixels[4*i])
  491|      0|			min = m_pPixels[4*i];
  492|      0|		if (max < m_pPixels[4*i])
  493|      0|			max = m_pPixels[4*i];
  494|      0|	}
  495|       |
  496|      0|	unsigned char r, g, b, a;
  497|      0|	float T = 1.;
  498|      0|	float alpha = k;
  499|      0|	for (unsigned int j=0; j<m_iHeight; j++)
  500|      0|		for (unsigned int i=0; i<m_iWidth; i++)
  501|      0|		{
  502|      0|			get_pixel (i, j, &r, &g, &b, &a);
  503|       |
  504|      0|			float rtmp = (float) (r-min) / (max-min);
  505|      0|			rtmp = filter_raised_cosine_filter (T, alpha, 1.-rtmp);
  506|      0|			r = (unsigned char)(255.*rtmp);
  507|       |
  508|      0|			set_pixel (i, j, r, r, r, a);
  509|      0|		}
  510|      0|}
  511|       |
  512|       |int Img::get_mean_value (void)
  513|      0|{
  514|      0|	int sum = 0;
  515|      0|	for (unsigned int j=0; j<m_iHeight; j++)
  516|      0|		for (unsigned int i=0; i<m_iWidth; i++)
  517|      0|			sum += m_pPixels[4*(j+m_iWidth+i)];
  518|       |
  519|      0|	return (int)(sum/(m_iWidth*m_iHeight));
  520|      0|}
  521|       |
  522|       |int Img::get_median_value (void)
  523|      0|{
  524|      0|	float histogram[256];
  525|      0|	get_histogram (histogram, 0);
  526|       |
  527|      0|	int i = 0, n = 0;
  528|      0|	int n2 = m_iWidth * m_iHeight /2.;
  529|      0|	int median = 0;
  530|      0|	while (n < n2)
  531|      0|		n += histogram[i++];
  532|       |
  533|      0|	return i;
  534|      0|}
  535|       |
  536|       |int Img::crop (Img *pImg, int x, int y, unsigned int width, unsigned int height)
  537|      0|{
  538|      0|	if (x+width > pImg->m_iWidth || y+height > pImg->m_iHeight)
  539|      0|		return -1;
  540|       |	
  541|      0|	m_iWidth = 0;
  542|      0|	m_iHeight = 0;
  543|      0|	resize_memory (width, height);
  544|       |	
  545|      0|	unsigned char r, g, b, a;
  546|      0|	for (unsigned int j=0; j<height; j++)
  547|      0|		for (unsigned int i=0; i<width; i++)
  548|      0|		{
  549|      0|			unsigned int ii = x+i;
  550|      0|			unsigned int jj = y+j;
  551|      0|			if (ii > pImg->m_iWidth-1)
  552|      0|				ii = 2 * pImg->m_iWidth - 1 - ii;
  553|      0|			if (jj > pImg->m_iHeight-1)
  554|      0|				jj = 2 * pImg->m_iHeight - 1 - jj;
  555|      0|			pImg->get_pixel (ii, jj, &r, &g, &b, &a);
  556|      0|			this->set_pixel (i, j, r, g, b, a);
  557|      0|		}
  558|       |	
  559|      0|	m_iWidth = width;
  560|      0|	m_iHeight = height;
  561|       |	
  562|      0|	return 0;
  563|      0|}
  564|       |
  565|       |int Img::resize (unsigned int width, unsigned int height, int mode)
  566|      0|{
  567|      0|	if (width == m_iWidth && height == m_iHeight)
  568|      0|		return 0;
  569|       |	
  570|      0|	unsigned char *pPixels = (unsigned char*)malloc(4*width*height*sizeof(unsigned char));
  571|      0|	if (pPixels == NULL)
  572|      0|		return -1;
  573|      0|	unsigned char r, g, b, a;
  574|      0|	unsigned int index;
  575|      0|	if (mode == 0) // nearest neighbour
  576|      0|	{
  577|      0|		for (unsigned int j=0; j<height; j++)
  578|      0|			for (unsigned int i=0; i<width; i++)
  579|      0|			{
  580|      0|				int x0 = i*(m_iWidth-1)/(width-1);
  581|      0|				int y0 = j*(m_iHeight-1)/(height-1);
  582|       |				
  583|      0|				this->get_pixel (x0, y0, &r, &g, &b, &a);
  584|      0|				index = j*width + i;
  585|      0|				pPixels[4*index]   = r;
  586|      0|				pPixels[4*index+1] = g;
  587|      0|				pPixels[4*index+2] = b;
  588|      0|				pPixels[4*index+3] = a;
  589|      0|			}
  590|      0|	}
  591|      0|	else if (mode == 1) // bilinear sampling
  592|      0|	{
  593|      0|		for (unsigned int j=0; j<height; j++)
  594|      0|			for (unsigned int i=0; i<width; i++)
  595|      0|			{
  596|      0|				float x = i*(m_iWidth-1)/(width-1);
  597|      0|				float y = j*(m_iHeight-1)/(height-1);
  598|      0|				int x0 = (int)x;
  599|      0|				int y0 = (int)y;
  600|      0|				int x1 = x0 + 1;
  601|      0|				int y1 = y0 + 1;
  602|      0|				x = x - x0;
  603|      0|				y = y - y0;
  604|       |				//
  605|      0|				int i00 = 4 * (y0 * m_iWidth + x0);
  606|      0|				int i01 = 4 * (y0 * m_iWidth + x1);
  607|      0|				int i10 = 4 * (y1 * m_iWidth + x0);
  608|      0|				int i11 = 4 * (y1 * m_iWidth + x1);
  609|      0|				int c00r = m_pPixels[i00];
  610|      0|				int c00g = m_pPixels[i00+1];
  611|      0|				int c00b = m_pPixels[i00+2];
  612|      0|				int c00a = m_pPixels[i00+3];
  613|      0|				int c01r = m_pPixels[i01];
  614|      0|				int c01g = m_pPixels[i01+1];
  615|      0|				int c01b = m_pPixels[i01+2];
  616|      0|				int c01a = m_pPixels[i01+3];
  617|      0|				int c10r = m_pPixels[i10];
  618|      0|				int c10g = m_pPixels[i10+1];
  619|      0|				int c10b = m_pPixels[i10+2];
  620|      0|				int c10a = m_pPixels[i10+3];
  621|      0|				int c11r = m_pPixels[i11];
  622|      0|				int c11g = m_pPixels[i11+1];
  623|      0|				int c11b = m_pPixels[i11+2];
  624|      0|				int c11a = m_pPixels[i11+3];
  625|       |				
  626|      0|				int r, g, b, a;
  627|      0|				r = 	(((int) c00r) * (1.f-x)*(1.f-y) +
  628|      0|					 ((int) c01r) * x      *(1.f-y) +
  629|      0|					 ((int) c10r) * (1.f-x)*      y  +
  630|      0|					 ((int) c11r) * x      *      y) + .5f;
  631|      0|				g = 	(((int) c00g) * (1.f-x)*(1.f-y) +
  632|      0|					 ((int) c01g) * x      *(1.f-y) +
  633|      0|					 ((int) c10g) * (1.f-x)*      y  +
  634|      0|					 ((int) c11g) * x      *      y) + .5f;
  635|      0|				b = 	(((int) c00b) * (1.f-x)*(1.f-y) +
  636|      0|					 ((int) c01b) * x      *(1.f-y) +
  637|      0|					 ((int) c10b) * (1.f-x)*      y  +
  638|      0|					 ((int) c11b) * x      *      y) + .5f;
  639|      0|				a = 	(((int) c00a) * (1.f-x)*(1.f-y) +
  640|      0|					 ((int) c01a) * x      *(1.f-y) +
  641|      0|					 ((int) c10a) * (1.f-x)*      y  +
  642|      0|					 ((int) c11a) * x      *      y) + .5f;
  643|       |				
  644|      0|				unsigned char cr = (unsigned char) ((r > 255) ? 255 : ((r < 0) ? 0 : r));
  645|      0|				unsigned char cg = (unsigned char) ((g > 255) ? 255 : ((g < 0) ? 0 : g));
  646|      0|				unsigned char cb = (unsigned char) ((b > 255) ? 255 : ((b < 0) ? 0 : b));
  647|      0|				unsigned char ca = (unsigned char) ((a > 255) ? 255 : ((a < 0) ? 0 : a));
  648|       |
  649|      0|				index = j*width + i;
  650|      0|				pPixels[4*index]   = cr;
  651|      0|				pPixels[4*index+1] = cg;
  652|      0|				pPixels[4*index+2] = cb;
  653|      0|				pPixels[4*index+3] = ca;
  654|      0|			}
  655|      0|	}
  656|      0|	else if (mode == 2)
  657|      0|	{
  658|      0|		unsigned int xinterval = m_iWidth / width;
  659|      0|		unsigned int yinterval = m_iHeight / height;
  660|      0|		int *histogram = (int*)malloc(4*xinterval*yinterval*sizeof(int));
  661|      0|		int ncolors = 0;
  662|      0|		for (unsigned int j=0; j<height; j++)
  663|      0|			for (unsigned int i=0; i<width; i++)
  664|      0|			{
  665|      0|				ncolors = 0;
  666|      0|				int xoffset = i * (m_iWidth) / (width);
  667|      0|				int yoffset = j * (m_iHeight) / (height);
  668|      0|				for (unsigned int jj=0; jj<yinterval; jj++)
  669|      0|					for (unsigned int ii=0; ii<xinterval; ii++)
  670|      0|					{
  671|      0|						unsigned char r, g, b, a;
  672|      0|						int x0 = xoffset + ii;
  673|      0|						int y0 = yoffset + jj;
  674|       |						
  675|      0|						this->get_pixel (x0, y0, &r, &g, &b, &a);
  676|      0|						int ci;
  677|      0|						for (ci=0; ci<ncolors; ci++)
  678|      0|						{
  679|      0|							if (r == histogram[4*ci] && g == histogram[4*ci+1] && b == histogram[4*ci+2])
  680|      0|							{
  681|      0|								histogram[4*ci+3]++;
  682|      0|								break;
  683|      0|							}
  684|      0|						}
  685|      0|						if (ci == ncolors)
  686|      0|						{
  687|      0|							histogram[4*ci]   = r;
  688|      0|							histogram[4*ci+1] = g;
  689|      0|							histogram[4*ci+2] = b;
  690|      0|							histogram[4*ci+3] = 0;
  691|      0|							ncolors++;
  692|      0|						}
  693|      0|					}
  694|      0|				int max = 0;
  695|      0|				int cimax = 0;
  696|      0|				for (int ci=0; ci<ncolors; ci++)
  697|      0|				{
  698|      0|					if (histogram[4*ci+3] > max)
  699|      0|					{
  700|      0|						max = histogram[4*ci+3];
  701|      0|						cimax = ci;
  702|      0|					}
  703|      0|				}
  704|      0|				index = j*width + i;
  705|      0|				pPixels[4*index]   = histogram[4*cimax];
  706|      0|				pPixels[4*index+1] = histogram[4*cimax+1];
  707|      0|				pPixels[4*index+2] = histogram[4*cimax+2];
  708|      0|				pPixels[4*index+3] = 255;
  709|      0|			}
  710|      0|	}
  711|       |
  712|      0|	m_iWidth = width;
  713|      0|	m_iHeight = height;
  714|      0|	free (m_pPixels);
  715|      0|	m_pPixels = pPixels;
  716|       |	
  717|      0|	return 0;
  718|      0|}
  719|       |
  720|       |int Img::resize_pixel (unsigned int n)
  721|      0|{
  722|      0|	unsigned char *pPixels = (unsigned char*)malloc(4*n*m_iWidth*n*m_iHeight*sizeof(unsigned char));
  723|      0|	if (pPixels == NULL)
  724|      0|		return -1;
  725|       |
  726|      0|	unsigned int iWidth = m_iWidth * n;
  727|      0|	unsigned int iHeight = m_iHeight * n;
  728|      0|	for (unsigned int j=0; j<m_iHeight; j++)
  729|      0|		for (unsigned int i=0; i<m_iWidth; i++)
  730|      0|			for (unsigned int k=0; k<n; k++)
  731|      0|				for (unsigned int l=0; l<n; l++)
  732|      0|				{
  733|      0|					unsigned int isrc = j*m_iWidth+i;
  734|      0|					unsigned int idst = (n*j+l)*iWidth+n*i+k;
  735|      0|					pPixels[4*idst]   = m_pPixels[4*isrc];
  736|      0|					pPixels[4*idst+1] = m_pPixels[4*isrc+1];
  737|      0|					pPixels[4*idst+2] = m_pPixels[4*isrc+2];
  738|      0|					pPixels[4*idst+3] = m_pPixels[4*isrc+3];
  739|      0|				}
  740|       |
  741|      0|	m_iWidth  = iWidth;
  742|      0|	m_iHeight = iHeight;
  743|      0|	free (m_pPixels);
  744|      0|	m_pPixels = pPixels;
  745|       |	
  746|      0|	return 0;
  747|      0|}
  748|       |
  749|       |int Img::copy (unsigned int x, unsigned int y, Img *pSrc)
  750|      0|{
  751|      0|	if (!pSrc)
  752|      0|		return -1;
  753|       |
  754|      0|	unsigned char r, g, b, a;
  755|      0|	for (unsigned int j=0; j<pSrc->m_iHeight; j++)
  756|      0|		for (unsigned int i=0; i<pSrc->m_iWidth; i++)
  757|      0|		{
  758|      0|			pSrc->get_pixel (i, j, &r, &g, &b, &a);
  759|      0|			set_pixel (x+i, y+j, r, g, b, a);
  760|      0|		}
  761|      0|	return 0;
  762|      0|}
  763|       |
  764|       |int Img::concatenate (Img *pImg)
  765|      0|{
  766|      0|	if (!pImg)
  767|      0|		return -1;
  768|       |
  769|      0|	unsigned int w = m_iWidth;
  770|      0|	resize_canvas (m_iWidth+pImg->m_iWidth, m_iHeight, 8, 255, 255, 255, 255);
  771|      0|	copy (w, 0, pImg);
  772|      0|	return 0;
  773|      0|}
  774|       |
  775|       |// mode : 0 = 90 right, 1 = 90 left, 2 = 180
  776|       |int Img::rotate (int mode)
  777|      0|{
  778|      0|     if (mode == 0) // 90 right
  779|      0|     {
  780|      0|	  unsigned char *pPixels = (unsigned char*)malloc(4*m_iWidth*m_iHeight*sizeof(unsigned char));
  781|      0|	  for (unsigned int j=0; j<m_iHeight; j++)
  782|      0|	       for (unsigned int i=0; i<m_iWidth; i++)
  783|      0|	       {
  784|       |		       // (i,j) go to (m_iHeight-1-j,i)
  785|      0|		       unsigned int isrc = 4*(j * m_iWidth + i);
  786|      0|		       unsigned int idst = 4*(i * m_iHeight + m_iHeight - 1 - j);
  787|      0|		       pPixels[idst]   = m_pPixels[isrc];
  788|      0|		       pPixels[idst+1] = m_pPixels[isrc+1];
  789|      0|		       pPixels[idst+2] = m_pPixels[isrc+2];
  790|      0|		       pPixels[idst+3] = m_pPixels[isrc+3];
  791|      0|	       }
  792|       |
  793|      0|	  unsigned int tmp = m_iWidth;
  794|      0|	  m_iWidth = m_iHeight;
  795|      0|	  m_iHeight = tmp;
  796|      0|	  free (m_pPixels);
  797|      0|	  m_pPixels = pPixels;
  798|      0|     }
  799|      0|     else if (mode == 1) // 90 left
  800|      0|     {
  801|      0|	  unsigned char *pPixels = (unsigned char*)malloc(4*m_iWidth*m_iHeight*sizeof(unsigned char));
  802|      0|	  for (unsigned int j=0; j<m_iHeight; j++)
  803|      0|	       for (unsigned int i=0; i<m_iWidth; i++)
  804|      0|	       {
  805|       |		       // (i,j) go to (j,w-1-i)
  806|      0|		       unsigned int isrc = 4*(j * m_iWidth + i);
  807|      0|		       unsigned int idst = 4*((m_iWidth - 1 - i) * m_iHeight + j);
  808|      0|		       pPixels[idst]   = m_pPixels[isrc];
  809|      0|		       pPixels[idst+1] = m_pPixels[isrc+1];
  810|      0|		       pPixels[idst+2] = m_pPixels[isrc+2];
  811|      0|		       pPixels[idst+3] = m_pPixels[isrc+3];
  812|      0|	       }
  813|       |
  814|      0|	  unsigned int tmp = m_iWidth;
  815|      0|	  m_iWidth = m_iHeight;
  816|      0|	  m_iHeight = tmp;
  817|      0|	  free (m_pPixels);
  818|      0|	  m_pPixels = pPixels;
  819|      0|      }
  820|      0|     else if (mode == 2) // 180
  821|      0|     {
  822|      0|	     unsigned int w = m_iWidth;
  823|      0|	     unsigned int h = m_iHeight;
  824|      0|	     unsigned int h2 = (unsigned int)(ceil((float)m_iHeight/2.));
  825|      0|	     for (unsigned int j=0; j<h2; j++)
  826|      0|		     for (unsigned int i=0; i<w; i++)
  827|      0|		     {
  828|      0|			     unsigned char r = m_pPixels[4*(j * w + i)];
  829|      0|			     unsigned char g = m_pPixels[4*(j * w + i) + 1];
  830|      0|			     unsigned char b = m_pPixels[4*(j * w + i) + 2];
  831|      0|			     unsigned char a = m_pPixels [4*(j * w + i) + 3];
  832|       |
  833|      0|			     m_pPixels[4*(j * w + i)]     = m_pPixels[4*((m_iHeight - 1 - j) * m_iWidth + (m_iWidth - 1 - i))];
  834|      0|			     m_pPixels[4*(j * w + i) + 1] = m_pPixels[4*((m_iHeight - 1 - j) * m_iWidth + (m_iWidth - 1 - i)) + 1];
  835|      0|			     m_pPixels[4*(j * w + i) + 2] = m_pPixels[4*((m_iHeight - 1 - j) * m_iWidth + (m_iWidth - 1 - i)) + 2];
  836|      0|			     m_pPixels[4*(j * w + i) + 3] = m_pPixels[4*((m_iHeight - 1 - j) * m_iWidth + (m_iWidth - 1 - i)) + 3];
  837|       |
  838|      0|			     m_pPixels[4*((m_iHeight - 1 - j) * m_iWidth + (m_iWidth - 1 - i))]	    = r;
  839|      0|			     m_pPixels[4*((m_iHeight - 1 - j) * m_iWidth + (m_iWidth - 1 - i)) + 1] = g;
  840|      0|			     m_pPixels[4*((m_iHeight - 1 - j) * m_iWidth + (m_iWidth - 1 - i)) + 2] = b;
  841|      0|			     m_pPixels[4*((m_iHeight - 1 - j) * m_iWidth + (m_iWidth - 1 - i)) + 3] = a;
  842|      0|		     }
  843|      0|     }
  844|      0|	 return 0;
  845|      0|}
  846|       |
  847|       |// positionning :
  848|       |// 1 2 3
  849|       |// 8 0 4
  850|       |// 7 6 5
  851|       |int Img::resize_canvas (unsigned int width, unsigned int height, int positioning,
  852|       |			unsigned char bg_r, unsigned char bg_g, unsigned char bg_b, unsigned char bg_a)
  853|      0|{
  854|      0|	Img *pClone = new Img (*this);
  855|       |
  856|      0|	unsigned int w1 = m_iWidth;
  857|      0|	unsigned int h1 = m_iHeight;
  858|       |	
  859|      0|	unsigned int w2 = width;
  860|      0|	unsigned int h2 = height;
  861|       |	
  862|       |	// resize the image
  863|      0|	resize_memory (width, height);
  864|       |
  865|       |	// init the background
  866|      0|	init_color (bg_r, bg_g, bg_b, bg_a);
  867|       |
  868|       |	// copy the clone in the new image
  869|      0|	unsigned int i1=0, j1=0, i2=0, j2=0;
  870|      0|	if (positioning == 1)
  871|      0|	{
  872|      0|		i1 = (w2 > w1)? 0 : 0;
  873|      0|		j1 = (h2 > h1)? 0 : (h1-h2);
  874|      0|		i2 = 0;
  875|      0|		j2 = (h2 > h1)? (h2-h1) : 0;
  876|      0|	}
  877|      0|	else if (positioning == 2)
  878|      0|	{
  879|      0|		i1 = (w2 > w1)? 0 : (w1-w2)/2.;
  880|      0|		j1 = (h2 > h1)? 0 : (h1-h2);
  881|      0|		i2 = (w2 > w1)? (w2-w1)/2. : 0;
  882|      0|		j2 = (h2 > h1)? (h2-h1) : 0;
  883|      0|	}
  884|      0|	else if (positioning == 3)
  885|      0|	{
  886|      0|		i1 = (w2 > w1)? 0 : (w1-w2);
  887|      0|		j1 = (h2 > h1)? 0 : (h1-h2);
  888|      0|		i2 = (w2 > w1)? (w2-w1) : 0;
  889|      0|		j2 = (h2 > h1)? (h2-h1) : 0;
  890|      0|	}
  891|      0|	else if (positioning == 4)
  892|      0|	{
  893|      0|		i1 = (w2 > w1)? 0 : (w1-w2);
  894|      0|		j1 = (h2 > h1)? 0 : (h1-h2)/2.;
  895|      0|		i2 = (w2 > w1)? (w2-w1) : 0;
  896|      0|		j2 = (h2 > h1)? (h2-h1)/2. : 0;
  897|      0|	}
  898|      0|	else if (positioning == 5)
  899|      0|	{
  900|      0|		i1 = (w2 > w1)? 0 : (w1-w2);
  901|      0|		j1 = (h2 > h1)? 0 : 0;
  902|      0|		i2 = (w2 > w1)? (w2-w1) : 0;
  903|      0|		j2 = 0;
  904|      0|	}
  905|      0|	else if (positioning == 6)
  906|      0|	{
  907|      0|		i1 = (w2 > w1)? 0 : (w1-w2)/2.;
  908|      0|		j1 = (h2 > h1)? 0 : 0;
  909|      0|		i2 = (w2 > w1)? (w2-w1)/2. : 0;
  910|      0|		j2 = 0;
  911|      0|	}
  912|      0|	else if (positioning == 7)
  913|      0|	{
  914|      0|		i1 = (w2 > w1)? 0 : 0;
  915|      0|		j1 = (h2 > h1)? 0 : 0;
  916|      0|		i2 = 0;
  917|      0|		j2 = 0;
  918|      0|	}
  919|      0|	else if (positioning == 8)
  920|      0|	{
  921|      0|		i1 = (w2 > w1)? 0 : 0;
  922|      0|		j1 = (h2 > h1)? 0 : (h1-h2)/2.;
  923|      0|		i2 = 0;
  924|      0|		j2 = (h2 > h1)? (h2-h1)/2. : 0;
  925|      0|	}
  926|      0|	else //(positioning == 0 and all others choices) // ok
  927|      0|	{
  928|      0|		i1 = (w2 > w1)? 0 : (w1-w2)/2.;
  929|      0|		j1 = (h2 > h1)? 0 : (h1-h2)/2.;
  930|      0|		i2 = (w2 > w1)? (w2-w1)/2. : 0;
  931|      0|		j2 = (h2 > h1)? (h2-h1)/2. : 0;
  932|      0|	}
  933|      0|	unsigned int wcopy = (w2 > w1)? w1 : w2;
  934|      0|	unsigned int hcopy = (h2 > h1)? h1 : h2;
  935|      0|	unsigned char r, g, b, a;
  936|      0|	for (unsigned int j=0; j<hcopy; j++)
  937|      0|		for (unsigned int i=0; i<wcopy; i++)
  938|      0|		{
  939|      0|			pClone->get_pixel (i1+i, j1+j, &r, &g, &b, &a);
  940|      0|			set_pixel (i2+i, j2+j, r, g, b, a);
  941|      0|		}
  942|       |	
  943|      0|	delete pClone;
  944|       |
  945|      0|	return 0;
  946|      0|}
  947|       |
  948|       |int Img::multiply (Img *pImg)
  949|      0|{
  950|      0|	if (!pImg || pImg->m_iWidth != m_iWidth || pImg->m_iHeight != m_iHeight)
  951|      0|		return -1;
  952|       |
  953|      0|	unsigned char r, g, b, a;
  954|      0|	unsigned char r2, g2, b2, a2;
  955|      0|	for (unsigned int j=0; j<m_iHeight; j++)
  956|      0|		for (unsigned int i=0; i<m_iWidth; i++)
  957|      0|		{
  958|      0|			get_pixel (i, j, &r, &g, &b, &a);
  959|      0|			pImg->get_pixel (i, j, &r2, &g2, &b2, &a2);
  960|       |			
  961|      0|			set_pixel (i, j,
  962|      0|				   (unsigned char)(r*r2/255.),
  963|      0|				   (unsigned char)(g*g2/255.),
  964|      0|				   (unsigned char)(b*b2/255.),
  965|      0|				   (unsigned char)(a*a2/255.));
  966|      0|		}
  967|      0|		return 0;
  968|      0|}
  969|       |
  970|       |
  971|       |int Img::palettize (Img *pImg)
  972|      0|{
  973|      0|	if (m_pPixels)
  974|      0|		free (m_pPixels);
  975|      0|	m_iWidth = 0;
  976|      0|	m_iHeight = 0;
  977|      0|	resize_memory (pImg->width(), pImg->height(), true);
  978|       |
  979|      0|	unsigned char r, g, b, a;
  980|      0|	for (unsigned int j=0; j<m_iHeight; j++)
  981|      0|		for (unsigned int i=0; i<m_iWidth; i++)
  982|      0|		{
  983|      0|			pImg->get_pixel (i, j, &r, &g, &b, &a);
  984|      0|			m_pPixels[m_iWidth*j + i] = m_pPalette->AddColor (r, g, b, a);
  985|      0|		}
  986|       |
  987|      0|	return 0;
  988|      0|}
  989|       |
  990|       |Palette* Img::get_palette (void)
  991|      0|{
  992|      0|	Palette *pPalette;
  993|      0|	if (bUsePalette)
  994|      0|		pPalette = m_pPalette;
  995|      0|	else
  996|      0|	{
  997|      0|		pPalette = new Palette ();
  998|      0|		unsigned char r, g, b, a;
  999|      0|		for (unsigned int j=0; j<m_iHeight; j++)
 1000|      0|			for (unsigned int i=0; i<m_iWidth; i++)
 1001|      0|			{
 1002|      0|				get_pixel (i, j, &r, &g, &b, &a);
 1003|      0|				pPalette->AddColor (r, g, b, a);
 1004|      0|			}
 1005|      0|	}
 1006|       |
 1007|      0|	return pPalette;
 1008|      0|}
 1009|       |
 1010|       |int Img::flood_fill (unsigned int x, unsigned int y, unsigned char r, unsigned char g, unsigned char b)
 1011|      0|{
 1012|      0|	if(x >= m_iWidth || y >= m_iHeight)
 1013|      0|		return 1;
 1014|       |
 1015|      0|	RGBc rgb;
 1016|      0|	rgb.r = r;
 1017|      0|	rgb.g = g;
 1018|      0|	rgb.b = b;
 1019|      0|	int cou = Color::RGBc2Int (rgb);
 1020|       |	//printf ("cou %d\n", cou);
 1021|       |	
 1022|      0|	int couToReplace = get_pixel_int (x, y);
 1023|       |	//printf ("couToReplace %d\n", couToReplace);
 1024|       |
 1025|      0|	list<Vector2i> listPointToCheck;
 1026|      0|	listPointToCheck.push_back(Vector2i(x,y));
 1027|      0|	while(!listPointToCheck.empty())
 1028|      0|	{
 1029|      0|		Vector2i back = listPointToCheck.front();
 1030|      0|		x = back[0];
 1031|      0|		y = back[1];
 1032|       |
 1033|      0|		listPointToCheck.pop_front();
 1034|      0|		if(get_pixel_int (x, y) == cou)
 1035|      0|			continue;
 1036|       |
 1037|       |		// search the start
 1038|      0|		int xStart = x;
 1039|      0|		while( (xStart-1) >=0 && get_pixel_int (xStart-1, y) == couToReplace)
 1040|      0|			xStart--;
 1041|       |
 1042|       |		// search the end
 1043|      0|		unsigned int xEnd = x;
 1044|      0|		while( (xEnd+1) < m_iWidth && get_pixel_int (xEnd+1, y) == couToReplace)
 1045|      0|			xEnd++;
 1046|       |
 1047|       |		//
 1048|      0|		for(unsigned int xCurrent=xStart; xCurrent<=xEnd; xCurrent++)
 1049|      0|		{
 1050|      0|			set_pixel (xCurrent, y, r, g, b, 255);
 1051|      0|			if(y>0)
 1052|      0|			{
 1053|      0|				if(get_pixel_int (xCurrent, y-1) == couToReplace)
 1054|      0|					listPointToCheck.push_back(Vector2i(xCurrent,y-1));
 1055|      0|			}
 1056|      0|			if(y<m_iHeight-1)
 1057|      0|			{
 1058|      0|				if(get_pixel_int (xCurrent, y+1) == couToReplace)
 1059|      0|					listPointToCheck.push_back(Vector2i(xCurrent,y+1));
 1060|      0|			}
 1061|      0|		}
 1062|      0|	}
 1063|       |
 1064|      0|	return 0;
 1065|      0|}

/workspaces/cg/src/cgimg/image.h:
    1|       |#pragma once
    2|       |
    3|       |#include <stdio.h>
    4|       |#include "../cgmath/cgmath.h"
    5|       |#include "palette.h"
    6|       |
    7|       |
    8|       |//#define JPEGLIB
    9|       |//#define PNG
   10|       |
   11|       |class Img
   12|       |{
   13|       |public:
   14|       |
   15|       |	static int AreIdentical (Img *pImg1, Img *pImg2);
   16|       |
   17|       |	enum grayscale_method_type
   18|       |	{
   19|       |		GRAYSCALE_LUMINOSITY,
   20|       |		GRAYSCALE_LIGHTNESS,
   21|       |		GRAYSCALE_AVERAGE
   22|       |	};
   23|       |	Img (unsigned int w=0, unsigned int h=0, bool use_palette=false);
   24|       |	Img (const Img &img);
   25|       |	~Img ();
   26|       |
   27|       |	int load (char const *filename, char const *path = NULL);
   28|       |	int save (char const *filename);
   29|       |
   30|       |	// getters / setters
   31|     22|	inline unsigned int width (void) const { return m_iWidth; };
   32|     22|	inline unsigned int height (void) const { return m_iHeight; };
   33|       |	
   34|       |	int init_color (unsigned char r, unsigned char g, unsigned char b, unsigned char a);
   35|       |	void set_pixel (unsigned int i, unsigned int j,
   36|       |			unsigned char r, unsigned char g, unsigned char b, unsigned char a);
   37|       |	void set_pixel_int (unsigned int i, unsigned int j, int c);
   38|       |	void set_pixel_index (unsigned int i, unsigned int j, unsigned int index);
   39|       |	void get_pixel (unsigned int i, unsigned int j,
   40|       |			unsigned char *r, unsigned char *g, unsigned char *b, unsigned char *a) const;
   41|       |	int get_pixel_int (unsigned int i, unsigned int j);
   42|       |	int get_pixel_index (unsigned int i, unsigned int j);
   43|       |	unsigned char get_r (unsigned int i, unsigned int j);
   44|       |	unsigned char get_g (unsigned int i, unsigned int j);
   45|       |	unsigned char get_b (unsigned int i, unsigned int j);
   46|       |	unsigned char get_a (unsigned int i, unsigned int j);
   47|       |	void get_nearest_pixel (float u, float v,
   48|       |				unsigned char *r, unsigned char *g, unsigned char *b, unsigned char *a);
   49|       |	
   50|       |	//
   51|       |	// palette
   52|       |	//
   53|       |	int palettize (Img *pImg);
   54|       |	Palette* get_palette (void);
   55|       |	int flood_fill (unsigned int x, unsigned int y, unsigned char r, unsigned char g, unsigned char b);
   56|       |
   57|       |	void convert_to_grayscale (grayscale_method_type grayscale_method_id = GRAYSCALE_LUMINOSITY, unsigned char nlevels = 255);
   58|       |
   59|       |	// test images
   60|       |	void init_test_grayscale1 (unsigned int h);
   61|       |	void init_test_grayscale2 (unsigned int size);
   62|       |	void init_test_color_jet (unsigned int w, unsigned int h);
   63|       |
   64|       |	//
   65|       |	// histogram
   66|       |	//
   67|       |	void get_histogram (float histogram[256], int normalized = 1);
   68|       |	Img* get_histogram_img (unsigned int height);
   69|       |	void histogram_equalization (void);
   70|       |	void histogram_equalization_bezier (CurveBezier *bezier = NULL);
   71|       |	void invert (void);
   72|       |	void contrast (float k);
   73|       |
   74|       |	// 
   75|       |	int get_mean_value (void);
   76|       |	int get_median_value (void);
   77|       |
   78|       |	int multiply (Img *pImg);
   79|       |
   80|       |	// filters
   81|       |	int filter (mat3 m, float divide = 0., float decay = 0.);
   82|       |	int filter_sobel (void);
   83|       |	int gaussian_blur (void);
   84|       |	int blur (void);
   85|       |	int bilateral_filtering (void);
   86|       |	int saturate (float t);
   87|       |	int brightness (float t);
   88|       |	int gamma (float t);
   89|       |	int sepia (void);
   90|       |
   91|       |	//
   92|       |	// quantization
   93|       |	//
   94|       |	int quant_heckbert (int ncolors);
   95|       |	int quant_wu (int ncolors);
   96|       |	int quant_kmean (float threshold);
   97|       |
   98|       |	//
   99|       |	// binarization
  100|       |	//
  101|       |	int bin_threshold (int threshold);
  102|       |	int bin_random (int methodId);
  103|       |	int bin_floyd_steinberg (void);
  104|       |	int bin_otsu (void);
  105|       |	int bin_dithering (unsigned char *pattern, int psize);
  106|       |	int bin_screening (Img *pPattern);
  107|       |
  108|       |	// geodesic
  109|       |	int geodesic (void);
  110|       |
  111|       |	//
  112|       |	// crop / resample
  113|       |	//
  114|       |	int crop (Img *pImg, int x, int y, unsigned int width, unsigned int height);
  115|       |	int resize (unsigned int width, unsigned int height, int mode=1); // 0 : nearest neighbour / 1 : bilinear / 2 : most current color in superpixel
  116|       |	int resize_pixel (unsigned int n);
  117|       |
  118|       |	int copy (unsigned int x, unsigned int y, Img *pImg);
  119|       |	int concatenate (Img *pImg);
  120|       |
  121|       |	int rotate (int mode);
  122|       |
  123|       |	int resize_canvas (unsigned int width, unsigned int height, int positioning,
  124|       |			   unsigned char bg_r, unsigned char bg_g, unsigned char bg_b, unsigned char bg_a);
  125|       |
  126|       |	//
  127|       |	// drawing functions
  128|       |	//
  129|       |	int draw_horizontal_line (unsigned int y, unsigned int xstart, unsigned int xend,
  130|       |				  unsigned char r, unsigned int g, unsigned char b, unsigned char a);
  131|       |	int draw_line (unsigned int xtart, unsigned int ystart, unsigned int xend, unsigned int yend,
  132|       |		       unsigned char r, unsigned int g, unsigned char b, unsigned char a);
  133|       |	int draw_circle (unsigned int x0, unsigned int y0, unsigned int radius,
  134|       |			 unsigned char r, unsigned int g, unsigned char b, unsigned char a);
  135|       |	int draw_disk (unsigned int x0, unsigned int y0, unsigned int radius,
  136|       |		       unsigned char r, unsigned int g, unsigned char b, unsigned char a);
  137|       |	int draw_ellipse (unsigned int x0, unsigned int y0,
  138|       |			  unsigned int radiusx, unsigned int radiusy,
  139|       |			  unsigned char r, unsigned int g, unsigned char b, unsigned char a);
  140|       |
  141|       |	// smooth the transitions between black and white
  142|       |	int smooth_transition (int l);
  143|       |
  144|       |private:
  145|       |	int resize_memory (unsigned int width, unsigned int height, bool use_palette=false);
  146|       |
  147|       |	int import_bmp (const char *filename);
  148|       |	int export_bmp (const char *filename);
  149|       |	int import_tga (const char *filename);
  150|       |	void compute_colormap (unsigned char **_colormap, unsigned short *_colormap_length);
  151|       |	int export_tga (const char *filename);
  152|       |	int import_pbm (FILE *ptr, unsigned int levels, int binary);
  153|       |	int import_pgm (FILE *ptr, unsigned int levels, int binary);
  154|       |	int import_ppm (FILE *ptr, unsigned int levels, int binary);
  155|       |	int import_pnm (const char *filename);
  156|       |	int export_ppm (const char *filename, int binary);
  157|       |	int export_pnm (const char *filename);
  158|       |#ifdef PNG
  159|       |	int import_png (const char *filename);
  160|       |	int export_png (const char *filename);
  161|       |#endif
  162|       |#ifdef JPEGLIB
  163|       |	int import_jpg (const char *filename);
  164|       |	int export_jpg (const char *filename);
  165|       |#endif
  166|       |
  167|       |public:
  168|       |	unsigned char *m_pPixels;
  169|       |	unsigned int m_iWidth, m_iHeight;
  170|       |
  171|       |	// use a palette
  172|       |	int bUsePalette;
  173|       |	Palette *m_pPalette;
  174|       |};

/workspaces/cg/src/cgimg/image_disparity_birchfield.h:
    1|       |#pragma once
    2|       |
    3|       |#include "image.h"
    4|       |
    5|       |class DisparityBirchfield
    6|       |{
    7|       |public:
    8|       |	DisparityBirchfield();
    9|       |	~DisparityBirchfield();
   10|       |
   11|       |	void SetStereoPair(Img *pLeft, Img *pRight);
   12|       |
   13|       |	void setOcclusionPenalty(int);
   14|       |	int getOcclusionPenalty(void);
   15|       |	void setReward(int);
   16|       |	int getReward(void);
   17|       |
   18|       |
   19|       |	void Process(void);
   20|       |	void PostProcess(void);
   21|       |
   22|       |	Img* GetDisparity (void)
   23|      0|	{
   24|      0|		return m_pDisparity1;
   25|      0|	};
   26|       |
   27|       |private:
   28|       |	Img *m_pImgLeft, *m_pImgRight;
   29|       |	Img *m_pDisparity1, *m_pDiscontinuities1; // Results after matching the scanlines independently
   30|       |	Img *m_pDisparity2, *m_pDiscontinuities2; // Results after postprocessing the first disparity map
   31|       |};

/workspaces/cg/src/cgimg/image_io.cpp:
    1|       |#include <stdio.h>
    2|       |#include <string.h>
    3|       |
    4|       |#include "image.h"
    5|       |
    6|       |int Img::load (char const *filename, char const *path)
    7|      3|{
    8|      3|	m_iWidth = 0;
    9|      3|	m_iHeight = 0;
   10|      3|	m_pPixels = NULL;
   11|       |
   12|      3|	if (!filename)
   13|      0|		return -1;
   14|       |
   15|      3|	char filename_full[4096];
   16|      3|	if (path)
   17|      0|		sprintf (filename_full, "%s/%s", path, filename);
   18|      3|	else
   19|      3|		sprintf (filename_full, "%s", filename);
   20|       |
   21|       |#ifdef PNG
   22|       |	if (strcmp (filename+(strlen(filename)-4), ".png") == 0)
   23|       |	     return import_png (filename_full);
   24|       |#endif
   25|       |#ifdef JPEGLIB
   26|       |	if (strcmp (filename+(strlen(filename)-4), ".jpg") == 0)
   27|       |	     return import_jpg (filename_full);
   28|       |#endif
   29|      3|	if (strcmp (filename+(strlen(filename)-4), ".bmp") == 0)
   30|      0|	     return import_bmp (filename_full);
   31|      3|	if (strcmp (filename+(strlen(filename)-4), ".tga") == 0)
   32|      3|	     return import_tga (filename_full);
   33|      0|	if (strcmp (filename+(strlen(filename)-4), ".pbm") == 0 ||
   34|      0|	    strcmp (filename+(strlen(filename)-4), ".pgm") == 0 ||
   35|      0|	    strcmp (filename+(strlen(filename)-4), ".ppm") == 0	)
   36|      0|	     return import_pnm (filename_full);
   37|       |
   38|      0|	return -1;
   39|      0|}
   40|       |
   41|       |int Img::save (char const *filename)
   42|      5|{
   43|      5|	if (!filename)
   44|      0|		return -1;
   45|       |
   46|       |#ifdef PNG
   47|       |	if (strcmp (filename+(strlen(filename)-4), ".png") == 0)
   48|       |	     return export_png (filename);
   49|       |#endif
   50|       |#ifdef JPEGLIB
   51|       |	if (strcmp (filename+(strlen(filename)-4), ".jpg") == 0)
   52|       |	     return export_jpg (filename);
   53|       |#endif
   54|      5|	if (strcmp (filename+(strlen(filename)-4), ".bmp") == 0)
   55|      5|	     return export_bmp (filename);
   56|      0|	if (strcmp (filename+(strlen(filename)-4), ".tga") == 0)
   57|      0|	     return export_tga (filename);
   58|      0|	if (strcmp (filename+(strlen(filename)-4), ".pbm") == 0 ||
   59|      0|	    strcmp (filename+(strlen(filename)-4), ".pgm") == 0 ||
   60|      0|	    strcmp (filename+(strlen(filename)-4), ".ppm") == 0	)
   61|      0|	     return export_pnm (filename);
   62|       |
   63|      0|	return -1;
   64|      0|}

/workspaces/cg/src/cgimg/image_io_bmp.cpp:
    1|       |#include "image.h"
    2|       |
    3|       |//
    4|       |// References :
    5|       |// http://www.fileformat.info/format/bmp/egff.htm
    6|       |//
    7|       |
    8|       |#ifdef WIN32
    9|       |#define WIN32_LEAN_AND_MEAN 
   10|       |#include <windows.h>
   11|       |
   12|       |/* AUX_RGBImageRec*
   13|       |AUX_RGBImageRec *LoadBMP(char *Filename)
   14|       |{
   15|       |	if (!Filename) return NULL;
   16|       |	FILE *File=fopen(Filename,"r");
   17|       |	if (File)
   18|       |	{
   19|       |		fclose(File);
   20|       |		return auxDIBImageLoad(Filename);
   21|       |	}
   22|       |	return NULL;
   23|       |}
   24|       |*/
   25|       |int Img::import_bmp (const char *filename)
   26|       |{
   27|       |	FILE *filePtr;
   28|       |	BITMAPFILEHEADER bitmapFileHeader;
   29|       |	BITMAPINFOHEADER bitmapInfoHeader;
   30|       |	
   31|       |	filePtr = fopen(filename,"rb");
   32|       |	if (filePtr == NULL)
   33|       |		return -1;
   34|       |
   35|       |	//read the bitmap file header
   36|       |	fread(&bitmapFileHeader, sizeof(BITMAPFILEHEADER), 1, filePtr);
   37|       |	if (bitmapFileHeader.bfType != 0x4D42) //verify that this is a bmp file by check bitmap id
   38|       |	{
   39|       |		fclose(filePtr);
   40|       |		return -1;
   41|       |	}
   42|       |
   43|       |	//read the bitmap info header
   44|       |	fread(&bitmapInfoHeader, sizeof(BITMAPINFOHEADER),1,filePtr);
   45|       |
   46|       |	//move file point to the begining of bitmap data
   47|       |	fseek(filePtr, bitmapFileHeader.bfOffBits, SEEK_SET);
   48|       |	
   49|       |	unsigned int width = bitmapInfoHeader.biWidth;
   50|       |	unsigned int height = bitmapInfoHeader.biHeight;
   51|       |	int bits = bitmapInfoHeader.biBitCount;
   52|       |
   53|       |	switch (bits)
   54|       |	{
   55|       |	case 1: // monochrome
   56|       |		{
   57|       |			resize_memory (width, height, false);
   58|       |			int scanlineWidth = bitmapInfoHeader.biSizeImage/m_iHeight;
   59|       |			unsigned char *bytes=(unsigned char*)malloc(scanlineWidth*sizeof(unsigned char));
   60|       |			for(int y=m_iHeight-1;y>=0;y--)
   61|       |			{
   62|       |				fread(bytes,1,scanlineWidth,filePtr);
   63|       |				int indexByte = 0;
   64|       |				for(unsigned int x=0;x<m_iWidth;x+=8)
   65|       |				{
   66|       |					char byte = bytes[indexByte++];
   67|       |					for(int x2=0;x2<8;++x2)
   68|       |					{
   69|       |						unsigned char level = ((byte>>(7-x2))&1)*255;
   70|       |						set_pixel (x+x2,y,level,level,level,255);
   71|       |					}
   72|       |				}
   73|       |			}
   74|       |			free(bytes);
   75|       |		}
   76|       |		break;
   77|       |	case 24: // RGB
   78|       |		{
   79|       |			resize_memory (width, height, false);
   80|       |			int scanlineWidth = bitmapInfoHeader.biSizeImage/m_iHeight;
   81|       |			unsigned char *bytes=(unsigned char*)malloc(scanlineWidth*sizeof(unsigned char));
   82|       |			for(int y=m_iHeight-1;y>=0;y--)
   83|       |			{
   84|       |				fread(bytes,1,scanlineWidth,filePtr);
   85|       |				for(unsigned int x=0;x<m_iWidth;x++)
   86|       |				{
   87|       |					for(int c=0;c<3;++c)
   88|       |						m_pPixels[4*(y*m_iWidth + x)+2-c] = bytes[3*x+c];
   89|       |					m_pPixels[4*(y*m_iWidth + x)+3] = 255;
   90|       |				}
   91|       |			}
   92|       |			free(bytes);
   93|       |		}
   94|       |		break;
   95|       |	default:
   96|       |		{
   97|       |			fclose (filePtr);
   98|       |			return -1;
   99|       |		}
  100|       |		break;
  101|       |	}
  102|       |
  103|       |	fclose(filePtr);
  104|       |
  105|       |	return 0;
  106|       |}
  107|       |
  108|       |int Img::export_bmp (const char *filename)
  109|       |{
  110|       |	FILE *ptrbuffer = fopen(filename, "wb");
  111|       |	if (!ptrbuffer)
  112|       |		return -1;
  113|       |
  114|       |	BITMAPINFOHEADER bitmapInfoHeader; // bitmap info header
  115|       |	bitmapInfoHeader.biSize = sizeof(BITMAPINFOHEADER);
  116|       |	bitmapInfoHeader.biWidth = m_iWidth;
  117|       |	bitmapInfoHeader.biHeight = m_iHeight;
  118|       |	bitmapInfoHeader.biPlanes = 1;
  119|       |	bitmapInfoHeader.biBitCount = 24;//8;
  120|       |	bitmapInfoHeader.biCompression = BI_RGB;
  121|       |	bitmapInfoHeader.biSizeImage = (((m_iWidth * 3) + 3) & ~3) * m_iHeight; // packed pixel formats
  122|       |	bitmapInfoHeader.biXPelsPerMeter = 0;
  123|       |	bitmapInfoHeader.biYPelsPerMeter = 0;
  124|       |	bitmapInfoHeader.biClrUsed = 0;
  125|       |	bitmapInfoHeader.biClrImportant = 0;
  126|       |   
  127|       |	BITMAPFILEHEADER bitmapFileHeader; // bitmap file header
  128|       |	bitmapFileHeader.bfType = 0x4D42;//''MB''
  129|       |	bitmapFileHeader.bfSize = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + bitmapInfoHeader.biSizeImage;
  130|       |	bitmapFileHeader.bfReserved1 = 0;
  131|       |	bitmapFileHeader.bfReserved2 = 0;
  132|       |	bitmapFileHeader.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER);
  133|       |  
  134|       |	fwrite(&bitmapFileHeader, 1, sizeof(BITMAPFILEHEADER), ptrbuffer); // write the bitmap info header
  135|       |	fwrite(&bitmapInfoHeader, 1, sizeof(BITMAPINFOHEADER), ptrbuffer); // write the image data
  136|       |
  137|       |	int scanlineWidth = bitmapInfoHeader.biSizeImage/m_iHeight;
  138|       |	unsigned char *pData = (unsigned char*)malloc(scanlineWidth);
  139|       |	memset(pData, 0, scanlineWidth);
  140|       |	for (unsigned int j=0; j<m_iHeight; j++)
  141|       |	{
  142|       |		for (unsigned int i=0; i<m_iWidth; i++)
  143|       |		{
  144|       |			// ! the image is a "bottom-up" bitmap with the origin in the lower-left corner
  145|       |			pData[3*i+2] = m_pPixels[4*((m_iHeight-1-j)*m_iWidth+i)];
  146|       |			pData[3*i+1] = m_pPixels[4*((m_iHeight-1-j)*m_iWidth+i)+1];
  147|       |			pData[3*i]   = m_pPixels[4*((m_iHeight-1-j)*m_iWidth+i)+2];
  148|       |		}
  149|       |		fwrite(pData, scanlineWidth, 1, ptrbuffer);
  150|       |	}
  151|       |
  152|       |	free (pData);
  153|       |	fclose(ptrbuffer);
  154|       |
  155|       |	return 0;
  156|       |}
  157|       |
  158|       |#else
  159|       |
  160|       |
  161|       |typedef unsigned char  uchar;
  162|       |
  163|       |typedef unsigned short uint16;
  164|       |typedef signed short   int16;
  165|       |
  166|       |typedef unsigned int   uint32;
  167|       |typedef signed int     int32;
  168|       |
  169|      5|#define BI_RGB       0
  170|       |#define BI_RLE4      1
  171|       |#define BI_RLE8      2
  172|       |#define BI_BITFIELDS 3
  173|       |
  174|       |struct bmp_file_header_s
  175|       |{
  176|       |  uint32 size;
  177|       |  uint32 reserved;
  178|       |  uint32 offsettobits;
  179|       |};
  180|       |
  181|       |struct bmp_bitmap_header_s
  182|       |{
  183|       |  uint32 size;
  184|       |  int32  width;
  185|       |  int32  height;
  186|       |  uint16 planes;
  187|       |  uint16 bpp;
  188|       |  uint32 compression;
  189|       |  uint32 imagesize;
  190|       |  int32  widthppm;
  191|       |  int32  heightppm;
  192|       |  uint32 colorused;
  193|       |  uint32 colorimportant;
  194|       |};
  195|       |
  196|       |int Img::import_bmp (const char *filename)
  197|      0|{
  198|       |	// check size of int
  199|      0|	if(sizeof(int)!=4)
  200|      0|		return -1;
  201|       |		
  202|      0|	FILE* f=fopen(filename, "rb");
  203|      0|	if(!f)
  204|      0|		return -1;
  205|      0|	char header[54];
  206|      0|	fread(header,54,1,f);
  207|       |
  208|       |	// "BM" in header
  209|      0|	if(header[0]!='B' || header[1]!='M') 
  210|      0|	{
  211|      0|		printf ("This file is not a bitmap, specifically it doesn't start 'BM'\n");
  212|      0|		fclose(f);
  213|      0|		return -1;
  214|      0|	}
  215|       |
  216|       |	//it seems gimp sometimes makes its headers small, so we have to do this. hence all the fseeks
  217|      0|	int offset=*(unsigned int*)(header+10);
  218|       |	
  219|      0|	int width=*(int*)(header+18);
  220|      0|	int height=*(int*)(header+22);
  221|       |	//now the bitmap knows how big it is it can allocate its memory
  222|      0|	resize_memory (width, height);
  223|       |
  224|      0|	int bits=int(header[28]);
  225|      0|	printf ("bit : %d\n", bits);
  226|      0|	int x,y,c;
  227|      0|	char cols[256*4]; // color table
  228|      0|	switch(bits)
  229|      0|	{
  230|      0|	case 24:
  231|      0|		fseek(f,offset,SEEK_SET);
  232|       |		//fread(m_pPixels,m_iWidth*m_iHeight*3,1,f);
  233|       |		//for(y=0;y<m_iHeight;++y)
  234|      0|		for(y=m_iHeight-1;y>=0;y--)
  235|      0|			for(x=0;x<m_iWidth;x++)
  236|      0|			{
  237|      0|				char byte;
  238|      0|				for(int c=0;c<3;++c)
  239|      0|				{
  240|      0|					fread(&byte,1,1,f);
  241|      0|					m_pPixels[4*(y*m_iWidth + x)+2-c] = byte;
  242|      0|				}
  243|      0|				m_pPixels[4*(y*m_iWidth + x)+3] = 255;
  244|      0|			}
  245|      0|		break;
  246|       |
  247|      0|	case 8:
  248|       |
  249|       |		/*fread(cols,256*4,1,f);							//read colortable
  250|       |		fseek(f,offset,SEEK_SET);
  251|       |		for(y=0;y<bmp.height;++y)						//(Notice 4bytes/col for some reason)
  252|       |			for(x=0;x<bmp.width;++x)
  253|       |			{
  254|       |				BYTE byte;			
  255|       |				fread(&byte,1,1,f);						//just read byte					
  256|       |				for(int c=0;c<3;++c)
  257|       |					bmp.pixel(x,y,c)=cols[byte*4+2-c];	//and look up in the table
  258|       |			}
  259|       |		*/
  260|       |		//changed by shiben bhattacharjee, IIIT Hyderabad shiben@students.iiit.ac.in
  261|       |		//since i needed 8bit greyscale data for my work
  262|       |
  263|      0|		fseek(f,offset,SEEK_SET);
  264|      0|		printf("Reading a grayscale image...\n");
  265|      0|		fread(m_pPixels, m_iWidth*m_iHeight,1,f);
  266|      0|		break;
  267|       |
  268|      0|	case 4:
  269|       |/*
  270|       |		fread(cols,16*4,1,f);
  271|       |		fseek(f,offset,SEEK_SET);
  272|       |		for(y=0;y<256;++y)
  273|       |			for(x=0;x<256;x+=2)
  274|       |			{
  275|       |				char byte;
  276|       |				fread(&byte,1,1,f);						//as above, but need to exract two
  277|       |				for(c=0;c<3;++c)						//pixels from each byte
  278|       |					bmp.pixel(x,y,c)=cols[byte/16*4+2-c];
  279|       |				for(c=0;c<3;++c)
  280|       |					bmp.pixel(x+1,y,c)=cols[byte%16*4+2-c];
  281|       |			}
  282|       |*/
  283|      0|		break;
  284|       |
  285|      0|	case 1:
  286|      0|		fread(cols,8,1,f);
  287|      0|		fseek(f,offset,SEEK_SET);
  288|      0|		for(y=0;y<m_iHeight;++y)
  289|      0|			for(x=0;x<m_iWidth;x+=8)
  290|      0|			{
  291|      0|				char byte;
  292|      0|				fread(&byte,1,1,f);
  293|       |				//Every byte is eight pixels
  294|       |				//so I'm shifting the byte to the relevant position, then masking out
  295|       |				//all but the lowest bit in order to get the index into the colourtable.
  296|      0|				for(int x2=0;x2<8;++x2)
  297|      0|					for(int c=0;c<3;++c)
  298|      0|						m_pPixels[y*m_iWidth + x+x2 +c] = cols[((byte>>(7-x2))&1)*4+2-c];
  299|       |				//bmp.pixel(x+x2,y,c)=cols[((byte>>(7-x2))&1)*4+2-c];
  300|      0|			}
  301|      0|		break;
  302|       |
  303|      0|	default:
  304|      0|		fclose(f);
  305|      0|		return -1;
  306|      0|	}
  307|       |
  308|      0|	if(ferror(f))
  309|      0|	{
  310|      0|		fclose(f);
  311|      0|		return -1;
  312|      0|	}
  313|       |	
  314|      0|	fclose(f);
  315|       |
  316|      0|	return 0;
  317|      0|}
  318|       |
  319|       |int Img::export_bmp (const char *filename)
  320|      5|{
  321|      5|  FILE *ptr;
  322|      5|  ptr = fopen (filename, "w");
  323|      5|  if (!ptr)
  324|      0|    return -1;
  325|       |
  326|      5|  uchar id[2] = {'B','M'};
  327|      5|  struct bmp_file_header_s fh;
  328|      5|  struct bmp_bitmap_header_s bh;
  329|       |
  330|      5|  fh.size           = sizeof(id) + sizeof(fh) + sizeof(bh) + sizeof(m_pPixels);
  331|      5|  fh.reserved       = 0;
  332|      5|  fh.offsettobits   = sizeof(id) + sizeof(fh) + sizeof(bh);
  333|       |  
  334|      5|  bh.size           = sizeof(bh);
  335|      5|  bh.width          = width();
  336|      5|  bh.height         = height();
  337|      5|  bh.planes         = 1;
  338|      5|  bh.bpp            = 24;
  339|      5|  bh.compression    = BI_RGB;
  340|      5|  bh.imagesize      = 3*width()*height();
  341|      5|  bh.widthppm       = 0;
  342|      5|  bh.heightppm      = 0;
  343|      5|  bh.colorused      = 0;
  344|      5|  bh.colorimportant = 0;
  345|       |  
  346|      5|  fwrite (&id, sizeof(unsigned char), 2, ptr);
  347|      5|  fwrite (&fh, sizeof(fh), 1, ptr);
  348|      5|  fwrite (&bh, sizeof(bh), 1, ptr);
  349|      5|  fwrite (m_pPixels, sizeof(unsigned char), 3*width()*height(), ptr); // todo : dismiss alpha
  350|      5|  fclose (ptr);  
  351|       |
  352|      5|  return 0;
  353|      5|}
  354|       |
  355|       |#endif // WIN32

/workspaces/cg/src/cgimg/image_io_pnm.cpp:
    1|       |#include "image.h"
    2|       |
    3|       |
    4|       |//
    5|       |// pnm
    6|       |//
    7|       |
    8|       |// import pbm
    9|       |int Img::import_pbm (FILE *ptr, unsigned int levels, int binary)
   10|      0|{
   11|      0|	if (binary)
   12|      0|		for (unsigned int j=0; j<m_iHeight; j++)
   13|      0|			for (unsigned int i=0; i<m_iWidth; i+=8)
   14|      0|			{
   15|      0|				char c;
   16|      0|				fread (&c, sizeof(char), 1, ptr);
   17|      0|			        unsigned char mask = 128;
   18|      0|				for (char k=0; k<8; k++)
   19|      0|				{
   20|      0|					if (i+k >= m_iWidth)
   21|      0|						break;
   22|      0|					if ((c&mask)==0)
   23|      0|						set_pixel (i+k,(/*height-1-*/j),
   24|      0|								    255, 255, 255, 255);
   25|      0|					else
   26|      0|						set_pixel (i+k,(/*height-1-*/j),
   27|      0|								    0, 0, 0, 255);
   28|      0|					mask /= 2;
   29|      0|				}
   30|      0|			}
   31|      0|	else
   32|      0|		for (unsigned int j=0; j<m_iHeight; j++)
   33|      0|			for (unsigned int i=0; i<m_iWidth; i++)
   34|      0|			{
   35|      0|				char c;
   36|      0|				fscanf (ptr, "%c", &c);
   37|      0|				if (c == '\n')
   38|      0|					i--;
   39|      0|				else
   40|      0|				{
   41|      0|					if (c=='1')
   42|      0|						set_pixel (i,(/*height-1-*/j),
   43|      0|								    0, 0, 0, 255);
   44|      0|					else
   45|      0|						set_pixel (i,(/*height-1-*/j),
   46|      0|								    255, 255, 255, 255);
   47|      0|				}
   48|      0|			}
   49|       |
   50|      0|	return 0;
   51|      0|}
   52|       |
   53|       |int Img::import_pgm (FILE *ptr, unsigned int levels, int binary)
   54|      0|{
   55|      0|	if (binary)
   56|      0|		for (unsigned int j=0; j<m_iHeight; j++)
   57|      0|			for (unsigned int i=0; i<m_iWidth; i++)
   58|      0|			{
   59|      0|				char c;
   60|      0|				fread (&c, sizeof(char), 1, ptr);
   61|      0|				unsigned char gray = (unsigned char)(255.*(float)c/(float)levels);
   62|      0|				set_pixel (i, /*height-1-*/j,
   63|      0|						    gray, gray, gray, 255);
   64|       |				//float gray = (float)c/(float)levels;
   65|       |				//pixel[width*(height-1-j)+i] = color_float_rgba (gray, gray, gray, 1.);
   66|      0|			}
   67|      0|	else
   68|      0|		for (unsigned int j=0; j<m_iHeight; j++)
   69|      0|			for (unsigned int i=0; i<m_iWidth; i++)
   70|      0|			{
   71|      0|				unsigned int c;
   72|      0|				fscanf (ptr, "%d", &c);
   73|      0|				char gray = 255*(float)c/(float)levels;
   74|      0|				set_pixel (i, /*height-1-*/j, gray, gray, gray, 255);
   75|       |				//float gray = (float)c/(float)levels;
   76|       |				//pixel[width*(height-1-j)+i] = color_float_rgba (gray, gray, gray, 1.);
   77|      0|			}
   78|       |
   79|       |
   80|      0|	return 0;
   81|      0|}
   82|       |
   83|       |int Img::import_ppm (FILE *ptr, unsigned int levels, int binary)
   84|      0|{
   85|      0|	if (binary)
   86|      0|	{
   87|      0|		for (unsigned int j=0; j<m_iHeight; j++)
   88|      0|			for (unsigned int i=0; i<m_iWidth; i++)
   89|      0|			{
   90|      0|				char c[3];
   91|      0|				fread (c, sizeof(char), 3, ptr);
   92|      0|				float r = (float)c[0]/(float)levels;
   93|      0|				float g = (float)c[1]/(float)levels;
   94|      0|				float b = (float)c[2]/(float)levels;
   95|      0|				set_pixel (i, /*height-1-*/j, 255*r, 255*g, 255*b, 255);
   96|      0|			}
   97|      0|	}
   98|      0|	else
   99|      0|	{
  100|      0|		for (unsigned int j=0; j<m_iHeight; j++)
  101|      0|			for (unsigned int i=0; i<m_iWidth; i++)
  102|      0|			{
  103|      0|				unsigned int c[3];
  104|      0|				fscanf (ptr, "%d %d %d", &c[0], &c[1], &c[2]);
  105|      0|				float r = (float)c[0]/(float)levels;
  106|      0|				float g = (float)c[1]/(float)levels;
  107|      0|				float b = (float)c[2]/(float)levels;
  108|      0|				set_pixel (i, /*height-1-*/j, 255*r, 255*g, 255*b, 255);
  109|      0|			}
  110|      0|	}
  111|       |
  112|      0|	return 0;
  113|      0|}
  114|       |
  115|       |int Img::import_pnm (const char *filename)
  116|      0|{
  117|      0|	FILE *ptr = fopen (filename, "r");
  118|      0|	if (ptr == NULL)
  119|      0|		return -1;
  120|       |	
  121|      0|	char header[2];
  122|      0|	fscanf (ptr, "%c%c", &header[0], &header[1]);
  123|      0|	if (header[0] != 'P')
  124|      0|	{
  125|      0|		fclose (ptr);
  126|      0|		return -1;
  127|      0|	}
  128|       |
  129|      0|	char buffer[256];
  130|      0|	unsigned int width, height, levels;
  131|      0|	do {
  132|      0|		fgets (buffer, 256, ptr);
  133|      0|	} while (buffer[0] == '#' || buffer[0] == '\n');
  134|      0|	sscanf (buffer, "%d %d\n", &width, &height);
  135|      0|	fscanf (ptr, "%d\n", &levels);
  136|       |	
  137|      0|	if (resize_memory (width, height) == -1)
  138|      0|		return -1;
  139|       |	
  140|      0|	switch (header[1])
  141|      0|	{
  142|      0|	case '1':
  143|      0|		import_pbm (ptr, levels, 0); 
  144|      0|		break;
  145|      0|	case '4':
  146|      0|		import_pbm (ptr, levels, 1); 
  147|      0|		break;
  148|      0|	case '2':
  149|      0|		import_pgm (ptr, levels, 0); 
  150|      0|		break;
  151|      0|	case '5':
  152|      0|		import_pgm (ptr, levels, 1); 
  153|      0|		break;
  154|      0|	case '3':
  155|      0|		import_ppm (ptr,levels,  0); 
  156|      0|		break;
  157|      0|	case '6':
  158|      0|		import_ppm (ptr, levels, 1); 
  159|      0|		break;
  160|      0|	default:
  161|      0|		break;
  162|      0|	}
  163|       |
  164|      0|	fclose (ptr);
  165|       |
  166|      0|	return 0;
  167|      0|}
  168|       |
  169|       |//
  170|       |//
  171|       |//
  172|       |
  173|       |int Img::export_ppm (const char *filename, int binary)
  174|      0|{
  175|      0|	unsigned int w = m_iWidth;
  176|      0|	unsigned int h = m_iHeight;
  177|       |
  178|      0|	unsigned char c[4];
  179|      0|	if (binary)
  180|      0|	{
  181|      0|		FILE *ptr = fopen (filename, "w+b");
  182|      0|		if (ptr == NULL)
  183|      0|			return -1;
  184|       |		
  185|      0|		fprintf (ptr, "P6\n%d %d\n%d\n", w, h, 255);
  186|      0|		for (unsigned int j=0; j<h; j++)
  187|      0|			for (unsigned int i=0; i<w; i++)
  188|      0|			{
  189|      0|				get_pixel (i, j, &c[0], &c[1], &c[2], &c[3]);
  190|      0|				fwrite (c, sizeof(char), 3, ptr);
  191|      0|			}
  192|       |
  193|      0|		fclose (ptr);
  194|      0|	}
  195|      0|	else
  196|      0|	{
  197|      0|		FILE *ptr = fopen (filename, "w");
  198|      0|		if (ptr == NULL)
  199|      0|			return -1;
  200|       |		
  201|      0|		fprintf (ptr, "P3\n%d %d\n%d\n", w, h, 255);
  202|      0|		for (unsigned int j=0; j<h; j++)
  203|      0|			for (unsigned int i=0; i<w; i++)
  204|      0|			{
  205|      0|				get_pixel (i, j, &c[0], &c[1], &c[2], &c[3]);
  206|      0|				fprintf (ptr, "%d %d %d\n", c[0], c[1], c[2]);
  207|      0|			}
  208|      0|		fclose (ptr);
  209|      0|	}
  210|       |
  211|      0|	return 0;
  212|      0|}
  213|       |
  214|       |int Img::export_pnm (const char *filename)
  215|      0|{
  216|      0|	return export_ppm (filename, 0);
  217|      0|}

/workspaces/cg/src/cgimg/image_io_tga.cpp:
    1|       |#include "image.h"
    2|       |
    3|       |/*
    4|       |int Img::import_tga (const char *filename)
    5|       |{
    6|       |	FILE *file;
    7|       |	file = fopen(filename, "rb");
    8|       |	if (!file)
    9|       |		return -1;
   10|       |	
   11|       |	bool rle = false;
   12|       |	bool truecolor = false;
   13|       |	unsigned int CurrentPixel = 0;
   14|       |	unsigned char ch_buf1, ch_buf2;
   15|       |	unsigned char buf1[1000];
   16|       |	
   17|       |	unsigned char IDLength;
   18|       |	unsigned char IDColorMapType;
   19|       |	unsigned char IDImageType;
   20|       |	
   21|       |	fread (&IDLength, sizeof(unsigned char), 1, file);
   22|       |	fread (&IDColorMapType, sizeof(unsigned char), 1, file);
   23|       |	//ReadData(file, (char*)&IDLength, 1);
   24|       |	//ReadData(file, (char*)&IDColorMapType, 1);
   25|       |	
   26|       |	if (IDColorMapType == 1)
   27|       |	{
   28|       |		fclose (file);
   29|       |		return -1;
   30|       |	}
   31|       |	
   32|       |	fread (&IDImageType, sizeof(unsigned char), 1, file);
   33|       |	//ReadData(file, (char*)&IDImageType, 1); 
   34|       |	
   35|       |	int type = 255; // O -> grayscale / 1 -> truecolor rgb / 2 -> truecolor rgba
   36|       |	switch (IDImageType)
   37|       |	{
   38|       |	case 2: // truecolor
   39|       |		type = 1;
   40|       |		break;
   41|       |	case 3: // greyscale
   42|       |		type = 0;
   43|       |		break;
   44|       |	case 10: // truecolor rle
   45|       |		rle = true;
   46|       |		type = 1;
   47|       |		break;
   48|       |	case 11: // grayscale rle
   49|       |		rle = true;
   50|       |		type = 0;
   51|       |		break;
   52|       |	default:
   53|       |		return false;
   54|       |	}
   55|       |
   56|       |	fseek (file, 5, SEEK_CUR);
   57|       |	//file.seekg(5, std::ios::cur);
   58|       |
   59|       |	fseek (file, 4, SEEK_CUR);
   60|       |	//file.seekg(4, std::ios::cur);
   61|       |	fread (&m_iWidth, sizeof(unsigned int), 1, file);
   62|       |	fread (&m_iHeight, sizeof(unsigned int), 1, file);
   63|       |	//ReadData(file, (char*)&m_width, 2);
   64|       |	//ReadData(file, (char*)&m_height, 2);
   65|       |
   66|       |	unsigned char pixelDepth;
   67|       |	fread (&pixelDepth, sizeof(unsigned char), 1, file);
   68|       |	//ReadData(file, (char*)&m_pixelDepth, 1);
   69|       |
   70|       |	if (! ((pixelDepth == 8) || (pixelDepth ==  24) ||
   71|       |	       (pixelDepth == 16) || (pixelDepth == 32)))
   72|       |		return -1;
   73|       |	
   74|       |	fread (&ch_buf1, sizeof(unsigned char), 1, file);
   75|       |	//ReadData(file, (char*)&ch_buf1, 1); 
   76|       |    
   77|       |	ch_buf2 = 15; //00001111;
   78|       |
   79|       |	// the depth of the alpha bitplane
   80|       |	unsigned int alphaDepth;
   81|       |	alphaDepth = ch_buf1 & ch_buf2;
   82|       |
   83|       |	if (! ((alphaDepth == 0) || (alphaDepth == 8)))
   84|       |		return -1;
   85|       |
   86|       |	if (type == 1) // truecolor
   87|       |	{
   88|       |		type = 1;
   89|       |		if (pixelDepth == 32)
   90|       |			type = 2;
   91|       |	}
   92|       |
   93|       |	if (type == 255)
   94|       |		return -1;
   95|       |
   96|       |	fseek (file, IDLength, SEEK_CUR);
   97|       |	//file.seekg(IDLength, std::ios::cur);
   98|       |
   99|       |	resize_memory (m_iWidth, m_iHeight);
  100|       |	//m_pixels = (byte*) malloc(m_width*m_height*(m_pixelDepth/8));
  101|       |
  102|       |	if (!rle)
  103|       |	{
  104|       |		fread (&m_pPixels, sizeof(unsigned char), m_iWidth*m_iHeight*(pixelDepth/8), file);
  105|       |		//ReadData(file, (char*)m_pixels, m_width*m_height*(m_pixelDepth/8));
  106|       |	}
  107|       |	else
  108|       |	{
  109|       |		while (CurrentPixel < m_iWidth*m_iHeight -1)
  110|       |		{
  111|       |			fread (&ch_buf1, sizeof(unsigned char), 1, file);
  112|       |			//ReadData(file, (char*)&ch_buf1, 1);
  113|       |			if ((ch_buf1 & 128) == 128) // this is an rle packet
  114|       |			{
  115|       |				ch_buf2 = (unsigned char)((ch_buf1 & 127) + 1); // how many pixels are encoded using this packet
  116|       |				fread (&buf1, sizeof(unsigned char), pixelDepth/8, file);
  117|       |				//ReadData(file, (char*)buf1, m_pixelDepth/8);
  118|       |				for (unsigned int i=CurrentPixel; i<CurrentPixel+ch_buf2; i++)
  119|       |					for (unsigned int j=0; j<pixelDepth/8; j++)
  120|       |						m_pPixels[i*pixelDepth/8+j] = buf1[j];
  121|       |				CurrentPixel += ch_buf2;
  122|       |			}
  123|       |			else // this is a raw packet
  124|       |			{
  125|       |				ch_buf2 = (unsigned char)((ch_buf1 & 127) + 1);
  126|       |				fread (&buf1, sizeof(unsigned char), pixelDepth/8*ch_buf2, file);
  127|       |				//ReadData(file, (char*)buf1, m_pixelDepth/8*ch_buf2);
  128|       |				for (unsigned int i=CurrentPixel; i<CurrentPixel+ch_buf2; i++)
  129|       |					for (unsigned int j=0; j<pixelDepth/8; j++)
  130|       |						m_pPixels[i*pixelDepth/8+j] =  buf1[(i-CurrentPixel)*pixelDepth/8+j];
  131|       |				CurrentPixel += ch_buf2;
  132|       |			}
  133|       |		}
  134|       |	}
  135|       |
  136|       |	// swap BGR(A) to RGB(A)
  137|       |	unsigned char temp;
  138|       |	if ((type == 1) || (type == 2))
  139|       |		if ((pixelDepth == 24) || (pixelDepth == 32))
  140|       |			for (unsigned int i= 0; i<m_iWidth*m_iHeight; i++)
  141|       |			{
  142|       |				temp = m_pPixels[i*pixelDepth/8];
  143|       |				m_pPixels[i*pixelDepth/8] = m_pPixels[i*pixelDepth/8+2];
  144|       |				m_pPixels[i*pixelDepth/8+2] = temp;
  145|       |			}
  146|       |	
  147|       |	return 0;
  148|       |}
  149|       |*/
  150|       |
  151|       |//
  152|       |// References :
  153|       |// http://paulbourke.net/dataformats/tga/
  154|       |//
  155|       |
  156|       |/*
  157|       | * recognized formats :
  158|       | * TGA_TYPE_MAPPED           nope
  159|       | * TGA_TYPE_TRUE_COLOR       24,32 bits ok
  160|       | * TGA_TYPE_GRAY             nope
  161|       | * TGA_TYPE_MAPPED_RLE       nope
  162|       | * TGA_TYPE_TRUE_COLOR_RLE   24,32 bits ok, only image_origin=0,2
  163|       | * TGA_TYPE_GRAY_RLE         nope
  164|       |*/
  165|       |
  166|       |/* The image types */
  167|      3|#define TGA_TYPE_EMPTY            0
  168|      3|#define TGA_TYPE_MAPPED           1
  169|      3|#define TGA_TYPE_TRUE_COLOR       2
  170|      3|#define TGA_TYPE_GRAY             3
  171|      3|#define TGA_TYPE_MAPPED_RLE       9
  172|      3|#define TGA_TYPE_TRUE_COLOR_RLE  10
  173|      3|#define TGA_TYPE_GRAY_RLE        11
  174|       |
  175|       |int Img::import_tga (const char *filename)
  176|      3|{
  177|      3|	FILE *ptr;
  178|      3|	unsigned int w, h;
  179|      3|	unsigned int i,j;
  180|      3|	unsigned char *color_map;
  181|       |
  182|      3|	if ((ptr = fopen (filename, "rb")) == NULL)
  183|      0|	{
  184|      0|		printf ("unable to open %s\n", filename);
  185|      0|		return -1;
  186|      0|	}
  187|       |  
  188|       |	//
  189|      3|	unsigned char id_length;
  190|      3|	unsigned char color_map_type;
  191|      3|	unsigned char image_type;
  192|       |
  193|      3|	fread (&id_length, sizeof(unsigned char), 1, ptr);
  194|      3|	fread (&color_map_type, sizeof(unsigned char), 1, ptr);
  195|      3|	fread (&image_type, sizeof(unsigned char), 1, ptr);
  196|       |
  197|       |	// color map specifications
  198|      3|	unsigned short color_map_origin;
  199|      3|	unsigned short color_map_length;
  200|      3|	unsigned char  color_map_entry_size;
  201|       |
  202|      3|	fread (&color_map_origin, sizeof(unsigned short), 1, ptr);
  203|      3|	fread (&color_map_length, sizeof(unsigned short), 1, ptr);
  204|      3|	fread (&color_map_entry_size, sizeof(unsigned char), 1, ptr);
  205|       |
  206|       |	// image specification
  207|      3|	unsigned short x_origin;
  208|      3|	unsigned short y_origin;
  209|      3|	unsigned short width;
  210|      3|	unsigned short height;
  211|      3|	unsigned char  pixel_depth; // 8, 16, 24, 32
  212|      3|	unsigned char  image_descriptor;
  213|      3|	unsigned char  image_origin;
  214|      3|	unsigned char  alpha_channel_bits;
  215|      3|	unsigned char  *id;
  216|       |
  217|      3|	fread (&x_origin, sizeof(unsigned short), 1, ptr);
  218|      3|	fread (&y_origin, sizeof(unsigned short), 1, ptr);
  219|      3|	fread (&width, sizeof(unsigned short), 1, ptr);
  220|      3|	fread (&height, sizeof(unsigned short), 1, ptr);
  221|      3|	fread (&pixel_depth, sizeof(unsigned char), 1, ptr);
  222|      3|	fread (&image_descriptor, sizeof(unsigned char), 1, ptr);
  223|      3|	image_origin = (image_descriptor&0x30)>>4;
  224|      3|	alpha_channel_bits = (image_descriptor&0xf);
  225|       |
  226|       |	// image id
  227|      3|	if (id_length != 0)
  228|      3|	{
  229|      3|		id = (unsigned char*)malloc((id_length+1)*sizeof(unsigned char));
  230|      3|		fread (id, sizeof(unsigned char), id_length, ptr);
  231|      3|	}
  232|       |  
  233|       |	// image data
  234|      3|	resize_memory (width, height);
  235|      3|	w = width;
  236|      3|	h = height;
  237|      3|	if (color_map_type)
  238|      0|	{
  239|      0|		switch (color_map_entry_size)
  240|      0|		{
  241|      0|		case 8:
  242|      0|			color_map = new unsigned char[color_map_length];
  243|       |			//datas = new unsigned char[w*h];
  244|      0|			break;
  245|      0|		case 24:
  246|      0|			color_map = new unsigned char[3*color_map_length];
  247|       |			//datas = new unsigned char[3*w*h];
  248|      0|			break;
  249|      0|		case 32:
  250|      0|			color_map = new unsigned char[4*color_map_length];
  251|       |			//datas = new unsigned char[4*w*h];
  252|      0|			break;
  253|      0|		}
  254|       |		//assert (color_map);
  255|       |		//assert (datas);
  256|      0|    }
  257|      3|	else
  258|      3|    {
  259|       |/*
  260|       |		switch (pixel_depth)
  261|       |		{
  262|       |		case 8:
  263|       |			datas = new unsigned char[w*h];
  264|       |			break;
  265|       |		case 24:
  266|       |			datas = new unsigned char[3*w*h];
  267|       |			break;
  268|       |		case 32:
  269|       |			datas = new unsigned char[4*w*h];
  270|       |			break;
  271|       |		}
  272|       |		assert (datas);
  273|       |*/
  274|      3|	}
  275|       |
  276|       |	/******************/
  277|       |	/* TGA_TYPE_EMPTY */
  278|       |	/******************/
  279|      3|	if (image_type == TGA_TYPE_EMPTY)
  280|      0|	{
  281|      0|		printf ("No data included :(\n");
  282|      0|		fclose (ptr);
  283|      0|		return -1;
  284|      0|	}
  285|       |
  286|       |	/*******************/
  287|       |	/* TGA_TYPE_MAPPED */
  288|       |	/*******************/
  289|      3|	if (image_type == TGA_TYPE_MAPPED)
  290|      0|	{
  291|       |		// read the color map
  292|      0|		for (i=0; i<color_map_length; i++)
  293|      0|		{
  294|      0|			if (color_map_entry_size == 24)
  295|      0|			{
  296|      0|				fread (&color_map[3*i+2], sizeof(unsigned char), 1, ptr);
  297|      0|				fread (&color_map[3*i+1], sizeof(unsigned char), 1, ptr);
  298|      0|				fread (&color_map[3*i], sizeof(unsigned char), 1, ptr);
  299|      0|			}
  300|      0|		}
  301|       |      
  302|       |      // read the datas
  303|      0|      switch (image_origin)
  304|      0|	{
  305|      0|	case 0:
  306|      0|	  for (j=h-1; j>=0; j--)
  307|      0|	    for (i=0; i<w; i++)
  308|      0|	      {
  309|      0|			unsigned char index;
  310|      0|			fread (&index, sizeof(unsigned char), 1, ptr);
  311|      0|			if (color_map_entry_size == 24)
  312|      0|				  set_pixel (i, j, color_map[3*index], color_map[3*index+1], color_map[3*index+2], 255);
  313|      0|	      }
  314|      0|	  break;
  315|      0|	case 1:
  316|      0|	  for (j=h-1; j>=0; j--)
  317|      0|	    for (i=w-1; i>=0; i--)
  318|      0|	      {
  319|      0|			unsigned char index;
  320|      0|			fread (&index, sizeof(unsigned char), 1, ptr);
  321|      0|			if (color_map_entry_size == 24)
  322|      0|			  set_pixel (i, j, color_map[3*index], color_map[3*index+1], color_map[3*index+2], 255);
  323|      0|	      }
  324|      0|	  break;
  325|      0|	case 2:
  326|      0|	  for (j=0; j<h; j++)
  327|      0|	    for (i=0; i<w; i++)
  328|      0|	      {
  329|      0|		unsigned char index;
  330|      0|		fread (&index, sizeof(unsigned char), 1, ptr);
  331|      0|		if (color_map_entry_size == 24)
  332|      0|			  set_pixel (i, j, color_map[3*index], color_map[3*index+1], color_map[3*index+2], 255);
  333|      0|	      }
  334|      0|	  break;
  335|      0|	case 3:
  336|      0|	  for (j=0; j<h; j++)
  337|      0|	    for (i=w-1; i>=0; i--)
  338|      0|	      {
  339|      0|		unsigned char index;
  340|      0|		fread (&index, sizeof(unsigned char), 1, ptr);
  341|      0|		if (color_map_entry_size == 24)
  342|      0|		  set_pixel (i, j, color_map[3*index], color_map[3*index+1], color_map[3*index+2], 255);
  343|      0|	      }
  344|      0|	  break;
  345|      0|	default:
  346|      0|	  printf ("WARNING!!! bad \"image origin\" (%d)\n", image_origin);
  347|      0|	  fclose (ptr);
  348|      0|	  return -1;
  349|      0|	}
  350|      0|    }
  351|       |
  352|       |  /***********************/
  353|       |  /* TGA_TYPE_TRUE_COLOR */
  354|       |  /***********************/
  355|      3|	unsigned char c[4];
  356|      3|  if (image_type == TGA_TYPE_TRUE_COLOR)
  357|      0|    {
  358|      0|      switch (image_origin)
  359|      0|	{
  360|      0|	case 0:
  361|      0|	  for (j=h-1; j>=0; j--)
  362|      0|	    for (i=0; i<w; i++)
  363|      0|	      {
  364|      0|			  if (pixel_depth == 24)
  365|      0|			  {
  366|      0|				  fread (c, sizeof(unsigned char), 3, ptr);
  367|      0|				  set_pixel (i, j, c[0], c[1], c[2], 255);
  368|      0|			  }
  369|      0|			  else if (pixel_depth == 32)
  370|      0|			  {
  371|      0|				  fread (c, sizeof(unsigned char), 4, ptr);
  372|      0|				  set_pixel (i, j, c[0], c[1], c[2], c[3]);
  373|      0|			  }
  374|      0|	      }
  375|       |
  376|      0|	  break;
  377|      0|	case 1:
  378|      0|	  for (j=h-1; j>=0; j--)
  379|      0|	    for (i=w-1; i>=0; i--)
  380|      0|	      {
  381|      0|		if (pixel_depth == 24)
  382|      0|		  {
  383|      0|			  unsigned char r, g, b;
  384|      0|		    fread (&b, sizeof(unsigned char), 1, ptr);
  385|      0|		    fread (&g, sizeof(unsigned char), 1, ptr);
  386|      0|		    fread (&r, sizeof(unsigned char), 1, ptr);
  387|      0|			  set_pixel (i, j, r, g, b, 255);
  388|      0|		  }
  389|      0|		if (pixel_depth == 32)
  390|      0|		  {
  391|      0|			  unsigned char r, g, b, a;
  392|      0|		    fread (&b, sizeof(unsigned char), 1, ptr);
  393|      0|		    fread (&g, sizeof(unsigned char), 1, ptr);
  394|      0|		    fread (&r, sizeof(unsigned char), 1, ptr);
  395|      0|		    fread (&a, sizeof(unsigned char), 1, ptr);
  396|      0|			  set_pixel (i, j, r, g, b, a);
  397|      0|		  }
  398|      0|	      }
  399|      0|	  break;
  400|      0|	case 2:
  401|      0|	  for (j=0; j<h; j++)
  402|      0|	    for (i=0; i<w; i++)
  403|      0|	      {
  404|      0|		if (pixel_depth == 24)
  405|      0|		  {
  406|      0|			  unsigned char r, g, b;
  407|      0|		    fread (&b, sizeof(unsigned char), 1, ptr);
  408|      0|		    fread (&g, sizeof(unsigned char), 1, ptr);
  409|      0|		    fread (&r, sizeof(unsigned char), 1, ptr);
  410|      0|			  set_pixel (i, j, r, g, b, 255);
  411|      0|		  }
  412|      0|		if (pixel_depth == 32)
  413|      0|		  {
  414|      0|			  unsigned char r, g, b, a;
  415|      0|		    fread (&b, sizeof(unsigned char), 1, ptr);
  416|      0|		    fread (&g, sizeof(unsigned char), 1, ptr);
  417|      0|		    fread (&r, sizeof(unsigned char), 1, ptr);
  418|      0|		    fread (&a, sizeof(unsigned char), 1, ptr);
  419|      0|			  set_pixel (i, j, r, g, b, a);
  420|      0|		  }
  421|      0|	      }
  422|      0|	  break;
  423|      0|	case 3:
  424|      0|	  for (j=0; j<h; j++)
  425|      0|	    for (i=w-1; i>=0; i--)
  426|      0|	      {
  427|      0|			if (pixel_depth == 24)
  428|      0|			  {
  429|      0|				unsigned char r, g, b;
  430|      0|				fread (&b, sizeof(unsigned char), 1, ptr);
  431|      0|				fread (&g, sizeof(unsigned char), 1, ptr);
  432|      0|				fread (&r, sizeof(unsigned char), 1, ptr);
  433|      0|				set_pixel (i, j, r, g, b, 255);
  434|      0|			  }
  435|      0|			if (pixel_depth == 32)
  436|      0|			  {
  437|      0|				unsigned char r, g, b, a;
  438|      0|				fread (&b, sizeof(unsigned char), 1, ptr);
  439|      0|				fread (&g, sizeof(unsigned char), 1, ptr);
  440|      0|				fread (&r, sizeof(unsigned char), 1, ptr);
  441|      0|				fread (&a, sizeof(unsigned char), 1, ptr);
  442|      0|				set_pixel (i, j, r, g, b, a);
  443|      0|			  }
  444|      0|	      }
  445|      0|	  break;
  446|      0|	default:
  447|      0|	  printf ("WARNING!!! bad \"image origin\" (%d)\n", image_origin);
  448|      0|	  fclose (ptr);
  449|      0|	  return -1;
  450|      0|	}
  451|      0|    }
  452|       |
  453|       |  /*****************/
  454|       |  /* TGA_TYPE_GRAY */
  455|       |  /*****************/
  456|      3|  if (image_type == TGA_TYPE_GRAY)
  457|      0|    {
  458|      0|      printf ("TGA_TYPE_GRAY not yet implemented\n");
  459|      0|      fclose (ptr);
  460|      0|      return -1;
  461|      0|    }
  462|       |
  463|       |  /***********************/
  464|       |  /* TGA_TYPE_MAPPED_RLE */
  465|       |  /***********************/
  466|      3|  if (image_type == TGA_TYPE_MAPPED_RLE)
  467|      0|    {
  468|      0|      printf ("TGA_TYPE_MAPPED_RLE not yet implemented\n");
  469|      0|      fclose (ptr);
  470|      0|      return -1;
  471|      0|    }
  472|       |  
  473|       |	/***************************/
  474|       |	/* TGA_TYPE_TRUE_COLOR_RLE */
  475|       |	/***************************/
  476|      3|	if (image_type == TGA_TYPE_TRUE_COLOR_RLE)
  477|      3|    {
  478|      3|      unsigned int pixels_read = 0;
  479|      3|      unsigned char repetition_block;
  480|      3|      unsigned char pixel_count;
  481|      3|      int i = 0;
  482|      3|      unsigned char r,g,b,a;
  483|       |
  484|      3|      switch (image_origin)
  485|      3|	  {
  486|      3|	case 0:
  487|      3|	  {
  488|      3|	    unsigned short current_line = height-1;
  489|      3|	    unsigned short pixels_on_line = 0;
  490|  4.56k|	    while (pixels_read < w*h)
  491|  4.56k|	      {
  492|       |			// read a packet
  493|  4.56k|			fread (&repetition_block, sizeof(unsigned char), 1, ptr);
  494|  4.56k|			if ((repetition_block&0x80) == 0x80)
  495|  4.40k|			{
  496|       |				// run-length packet
  497|  4.40k|				pixel_count = repetition_block - 0x80 + 1;
  498|  4.40k|				fread (&b, sizeof(unsigned char), 1, ptr);
  499|  4.40k|				fread (&g, sizeof(unsigned char), 1, ptr);
  500|  4.40k|				fread (&r, sizeof(unsigned char), 1, ptr);
  501|  4.40k|				a = 255;
  502|  4.40k|				if (pixel_depth == 32)
  503|  2.04k|					fread (&a, sizeof(unsigned char), 1, ptr);
  504|  53.4k|				for (i=0; i<pixel_count; i++)
  505|  49.0k|					set_pixel (pixels_on_line+i, current_line, r, g, b, a);
  506|  4.40k|			}
  507|    154|			else
  508|    154|			{
  509|       |				// non-run-length packet
  510|    154|				pixel_count = repetition_block + 1;
  511|    308|				for (i=0; i<pixel_count; i++)
  512|    154|				{
  513|    154|					fread (&b, sizeof(unsigned char), 1, ptr);
  514|    154|					fread (&g, sizeof(unsigned char), 1, ptr);
  515|    154|					fread (&r, sizeof(unsigned char), 1, ptr);
  516|    154|					a = 255;
  517|    154|					if (pixel_depth == 32)
  518|      0|						fread (&a, sizeof(unsigned char), 1, ptr);
  519|    154|					set_pixel (pixels_on_line+i, current_line, r, g, b, a);
  520|    154|				}
  521|    154|			}
  522|  4.56k|			pixels_on_line += pixel_count;
  523|  4.56k|			if (pixels_on_line >= width)
  524|    333|			  {
  525|    333|				current_line--;
  526|    333|				pixels_on_line = 0;
  527|    333|			  }
  528|  4.56k|			pixels_read += pixel_count;
  529|  4.56k|	      }
  530|      3|	    printf ("pixels read: %d\n", pixels_read);
  531|      3|	    break;
  532|      0|	  }
  533|      0|	case 1:
  534|      0|	  printf ("not yet implemented :(\n");
  535|      0|	  fclose (ptr);
  536|      0|	  return -1;
  537|      0|	  break;
  538|      0|	case 2:
  539|      0|	  while (pixels_read < w*h)
  540|      0|	    {
  541|       |	      // read a packet
  542|      0|	      fread (&repetition_block, sizeof(unsigned char), 1, ptr);
  543|      0|	      if ((repetition_block&0x80) == 0x80)
  544|      0|		{
  545|       |		  // run-length packet
  546|      0|		  pixel_count = repetition_block - 0x80 + 1;
  547|      0|		  fread (&b, sizeof(unsigned char), 1, ptr);
  548|      0|		  fread (&g, sizeof(unsigned char), 1, ptr);
  549|      0|		  fread (&r, sizeof(unsigned char), 1, ptr);
  550|      0|		  a = 255;
  551|      0|		  if (pixel_depth == 32)
  552|      0|		    fread (&a, sizeof(unsigned char), 1, ptr);
  553|      0|		  for (i=0; i<pixel_count; i++)
  554|      0|		    {
  555|      0|				m_pPixels[4*(pixels_read+i)+3] = a;
  556|      0|				m_pPixels[4*(pixels_read+i)+2] = b;
  557|      0|				m_pPixels[4*(pixels_read+i)+1] = g;
  558|      0|				m_pPixels[4*(pixels_read+i)+0] = r;
  559|      0|		    }
  560|      0|		}
  561|      0|	      else
  562|      0|		{
  563|       |		  // non-run-length packet
  564|      0|		  pixel_count = repetition_block + 1;
  565|      0|		  for (i=0; i<pixel_count; i++)
  566|      0|		    {
  567|      0|				fread (&b, sizeof(unsigned char), 1, ptr);
  568|      0|				fread (&g, sizeof(unsigned char), 1, ptr);
  569|      0|				fread (&r, sizeof(unsigned char), 1, ptr);
  570|      0|				a = 255;
  571|      0|				if (pixel_depth == 32)
  572|      0|					fread (&a, sizeof(unsigned char), 1, ptr);
  573|       |				
  574|      0|				m_pPixels[4*(pixels_read+i)+3] = a;
  575|      0|				m_pPixels[4*(pixels_read+i)+2] = b;
  576|      0|				m_pPixels[4*(pixels_read+i)+1] = g;
  577|      0|				m_pPixels[4*(pixels_read+i)+0] = r;
  578|      0|		    }
  579|      0|		}
  580|      0|	      pixels_read += pixel_count;
  581|      0|	    }
  582|      0|	  printf ("pixels read: %d\n", pixels_read);
  583|      0|	  break;
  584|      0|	case 3:
  585|      0|	  printf ("not yet implemented :(\n");
  586|      0|	  fclose (ptr);
  587|      0|	  return -1;
  588|      0|	  break;
  589|      0|	default:
  590|      0|	  printf ("WARNING!!! bad \"image origin\" (%d)\n", image_origin);
  591|      0|	  fclose (ptr);
  592|      0|	  return -1;
  593|      3|	}
  594|      3|    }
  595|       |      
  596|       |  /*********************/
  597|       |  /* TGA_TYPE_GRAY_RLE */
  598|       |  /*********************/
  599|      3|  if (image_type == TGA_TYPE_GRAY_RLE)
  600|      0|    {
  601|      0|      printf ("TGA_TYPE_GRAY_RLE not yet implemented\n");
  602|      0|      fclose (ptr);
  603|      0|      return -1;
  604|      0|    }
  605|       |
  606|       |  /* On compte ce qui reste */
  607|      3|  i=0;
  608|  42.7k|  while (!feof(ptr))
  609|  42.7k|    {
  610|  42.7k|      unsigned char c;
  611|  42.7k|      fread (&c, sizeof(unsigned char), 1, ptr);
  612|  42.7k|      i++;
  613|  42.7k|    }
  614|      3|  printf ("reste: %d octets\n", i);
  615|       |  
  616|      3|  fclose (ptr);
  617|       |  
  618|      3|  return 0;
  619|      3|}
  620|       |
  621|       |void Img::compute_colormap (unsigned char **_colormap, unsigned short *_colormap_length)
  622|      0|{
  623|      0|  unsigned int i,j;
  624|      0|  unsigned short colormap_length = 0;
  625|      0|  unsigned char *colormap = (unsigned char*)malloc(3*sizeof(unsigned char));
  626|      0|  colormap_length++;
  627|      0|  colormap[0] = m_pPixels[0];
  628|      0|  colormap[1] = m_pPixels[1];
  629|      0|  colormap[2] = m_pPixels[2];
  630|      0|  for (i=1; i<m_iWidth*m_iHeight; i++)
  631|      0|    {
  632|      0|      unsigned char r_walk = m_pPixels[4*i];
  633|      0|      unsigned char g_walk = m_pPixels[4*i+1];
  634|      0|      unsigned char b_walk = m_pPixels[4*i+2];
  635|      0|      for (j=0; j<colormap_length; j++)
  636|      0|	{
  637|      0|	  if (colormap[3*j]   == r_walk &&
  638|      0|	      colormap[3*j+1] == g_walk &&
  639|      0|	      colormap[3*j+2] == b_walk)
  640|      0|	    break;
  641|      0|	}
  642|      0|      if (j == colormap_length)
  643|      0|	{
  644|      0|	  colormap = (unsigned char*)realloc(colormap,3*(colormap_length+1)*sizeof(unsigned char));
  645|      0|	  colormap[3*colormap_length]   = r_walk;
  646|      0|	  colormap[3*colormap_length+1] = g_walk;
  647|      0|	  colormap[3*colormap_length+2] = b_walk;
  648|      0|	  colormap_length++;
  649|      0|	}
  650|      0|    }
  651|      0|  *_colormap_length = colormap_length;
  652|      0|  *_colormap = colormap;
  653|      0|}
  654|       |
  655|       |int Img::export_tga (const char *filename)
  656|      0|{
  657|      0|	int mode = TGA_TYPE_TRUE_COLOR;
  658|       |
  659|      0|  FILE *ptr;
  660|      0|  unsigned int w,h;
  661|      0|  unsigned int i,j;
  662|       |
  663|      0|  ptr = fopen (filename, "wb");
  664|      0|  if (!ptr) return -1;
  665|      0|  w = m_iWidth;
  666|      0|  h = m_iHeight;
  667|       |
  668|      0|  unsigned short  x_origin, y_origin;
  669|      0|  unsigned char pixel_depth;
  670|      0|  unsigned char  image_descriptor;
  671|       |
  672|      0|  switch (mode)
  673|      0|    {
  674|      0|    case TGA_TYPE_TRUE_COLOR:
  675|      0|		{
  676|       |      // header
  677|      0|      unsigned char *id = (unsigned char*)strdup ("created by cgimg\0");
  678|      0|      size_t id_length = strlen ((char*)id)+1;
  679|      0|      fwrite (&id_length, sizeof(unsigned char), 1, ptr);
  680|       |      
  681|      0|      unsigned char color_map_type = 0;
  682|      0|      fwrite (&color_map_type, sizeof(unsigned char), 1, ptr);
  683|       |      
  684|      0|      unsigned char image_type = TGA_TYPE_TRUE_COLOR;
  685|      0|      fwrite (&image_type, sizeof(unsigned char), 1, ptr);
  686|       |      
  687|       |      // color map specifications
  688|      0|      unsigned short color_map_origin     = 0;
  689|      0|      unsigned short color_map_length     = 0;
  690|      0|      unsigned char  color_map_entry_size = 0;
  691|      0|      fwrite (&color_map_origin, sizeof(unsigned short), 1, ptr);
  692|      0|      fwrite (&color_map_length, sizeof(unsigned short), 1, ptr);
  693|      0|      fwrite (&color_map_entry_size, sizeof(unsigned char), 1, ptr);
  694|       |      
  695|       |      // image specification
  696|      0|      x_origin = y_origin = 0;
  697|      0|      fwrite (&x_origin, sizeof(unsigned short), 1, ptr);
  698|      0|      fwrite (&y_origin, sizeof(unsigned short), 1, ptr);
  699|      0|      fwrite (&m_iWidth, sizeof(unsigned short), 1, ptr);
  700|      0|      fwrite (&m_iHeight, sizeof(unsigned short), 1, ptr);
  701|      0|      pixel_depth = 24;   // RGB
  702|       |      //pixel_depth = 32; // RGBA
  703|      0|      fwrite (&pixel_depth, sizeof(unsigned char), 1, ptr);
  704|      0|      image_descriptor = (0x02)<<4|(0x00);
  705|      0|      fwrite (&image_descriptor, sizeof(unsigned char), 1, ptr);
  706|       |      
  707|      0|      if (id_length != 0)
  708|      0|	fwrite (id, sizeof(unsigned char), id_length, ptr);
  709|       |      
  710|      0|      for (j=0; j<h; j++)
  711|      0|	for (i=0; i<w; i++)
  712|      0|	  {
  713|      0|	    if (pixel_depth == 24)
  714|      0|	      {
  715|      0|		fwrite (&m_pPixels[4*(j*w+i)+2], sizeof(unsigned char), 1, ptr);
  716|      0|		fwrite (&m_pPixels[4*(j*w+i)+1], sizeof(unsigned char), 1, ptr);
  717|      0|		fwrite (&m_pPixels[4*(j*w+i)], sizeof(unsigned char), 1, ptr);
  718|      0|	      }
  719|      0|	    if (pixel_depth == 32)
  720|      0|	      {
  721|      0|		fwrite (&m_pPixels[4*(j*w+i)+2], sizeof(unsigned char), 1, ptr);
  722|      0|		fwrite (&m_pPixels[4*(j*w+i)+1], sizeof(unsigned char), 1, ptr);
  723|      0|		fwrite (&m_pPixels[4*(j*w+i)], sizeof(unsigned char), 1, ptr);
  724|      0|		fwrite (&m_pPixels[4*(j*w+i)+3], sizeof(unsigned char), 1, ptr);
  725|      0|	      }
  726|      0|	  }
  727|      0|		}
  728|      0|	break;
  729|      0|    case TGA_TYPE_MAPPED:
  730|      0|		{
  731|       |      // header
  732|      0|      unsigned char *id = (unsigned char*)strdup ("created by cl\0");
  733|      0|      size_t id_length = strlen ((char*)id)+1;
  734|      0|      fwrite (&id_length, sizeof(unsigned char), 1, ptr);
  735|       |      
  736|      0|      unsigned char color_map_type = 1;
  737|      0|      fwrite (&color_map_type, sizeof(unsigned char), 1, ptr);
  738|       |      
  739|      0|      unsigned char image_type = TGA_TYPE_MAPPED;
  740|      0|      fwrite (&image_type, sizeof(unsigned char), 1, ptr);
  741|       |      
  742|       |      // color map specifications
  743|      0|      unsigned char *colormap=NULL;
  744|      0|      unsigned short colormap_length;
  745|      0|      compute_colormap (&colormap, &colormap_length);
  746|       |      
  747|      0|      unsigned short color_map_origin     = 0;
  748|      0|      unsigned short color_map_length     = colormap_length;
  749|      0|      unsigned char color_map_entry_size = 24;
  750|      0|      fwrite (&color_map_origin, sizeof(unsigned short), 1, ptr);
  751|      0|      fwrite (&color_map_length, sizeof(unsigned short), 1, ptr);
  752|      0|      fwrite (&color_map_entry_size, sizeof(unsigned char), 1, ptr);
  753|       |      
  754|       |      // image specification
  755|      0|      x_origin = y_origin = 0;
  756|      0|      fwrite (&x_origin, sizeof(unsigned short), 1, ptr);
  757|      0|      fwrite (&y_origin, sizeof(unsigned short), 1, ptr);
  758|      0|      fwrite (&m_iWidth, sizeof(unsigned short), 1, ptr);
  759|      0|      fwrite (&m_iHeight, sizeof(unsigned short), 1, ptr);
  760|      0|      pixel_depth = 8; // index
  761|      0|      fwrite (&pixel_depth, sizeof(unsigned char), 1, ptr);
  762|      0|      image_descriptor = (0x02)<<4|(0x00);
  763|      0|      fwrite (&image_descriptor, sizeof(unsigned char), 1, ptr);
  764|       |      
  765|      0|      if (id_length != 0)
  766|      0|	fwrite (id, sizeof(unsigned char), id_length, ptr);
  767|       |
  768|       |      // write the color map
  769|      0|      for (i=0; i<colormap_length; i++)
  770|      0|	{
  771|      0|	  if (color_map_entry_size == 24)
  772|      0|	    {
  773|      0|	      fwrite (&colormap[3*i+2], sizeof(unsigned char), 1, ptr);
  774|      0|	      fwrite (&colormap[3*i+1], sizeof(unsigned char), 1, ptr);
  775|      0|	      fwrite (&colormap[3*i], sizeof(unsigned char), 1, ptr);
  776|      0|	    }
  777|      0|	}
  778|       |      
  779|       |      // write the datas
  780|      0|      for (j=0; j<h; j++)
  781|      0|	for (i=0; i<w; i++)
  782|      0|	  for (int index=0; index<colormap_length; index++)
  783|      0|	    {
  784|      0|	      if (m_pPixels[4*(j*w+i)]   == colormap[3*index] &&
  785|      0|		  m_pPixels[4*(j*w+i)+1] == colormap[3*index+1] &&
  786|      0|		  m_pPixels[4*(j*w+i)+2] == colormap[3*index+2])
  787|      0|		{
  788|      0|		  fwrite (&index, sizeof(unsigned char), 1, ptr);
  789|      0|		  break;
  790|      0|		}
  791|      0|	    }
  792|      0|		}
  793|      0|		break;
  794|      0|	default:
  795|      0|		break;
  796|      0|    }
  797|       |  
  798|      0|  fclose (ptr);
  799|       |
  800|      0|  return 0;
  801|      0|}

/workspaces/cg/src/cgimg/palette.cpp:
    1|       |#include <stdio.h>
    2|       |
    3|       |#include "palette.h"
    4|       |
    5|       |Palette::Palette ()
    6|      0|{
    7|      0|	m_nMaxColors = 256;
    8|      0|	m_nColors = 0;
    9|      0|	m_pColors = (Color*)malloc(m_nMaxColors*sizeof(Color));
   10|      0|}
   11|       |
   12|       |Palette::~Palette ()
   13|      0|{
   14|      0|	if (m_pColors)
   15|      0|		free (m_pColors);
   16|      0|}
   17|       |
   18|       |unsigned int Palette::AddColor (unsigned char r, unsigned char g, unsigned char b, unsigned char a)
   19|      0|{
   20|      0|	int index = IsPresent (r, g, b, a);
   21|      0|	if (index != -1)
   22|      0|		return index;
   23|       |
   24|      0|	if (m_nColors >= m_nMaxColors)
   25|      0|		return 0;
   26|      0|	m_pColors[m_nColors].SetRGBA (r, g, b, a);
   27|      0|	m_nColors++;
   28|       |
   29|      0|	return m_nColors-1;
   30|      0|}
   31|       |
   32|       |int Palette::IsPresent (unsigned char r, unsigned char g, unsigned char b, unsigned char a)
   33|      0|{
   34|      0|	for (unsigned int i=0; i<m_nColors; i++)
   35|      0|	{
   36|      0|		if (m_pColors[i].r() == r &&
   37|      0|		    m_pColors[i].g() == g && 
   38|      0|		    m_pColors[i].b() == b && 
   39|      0|		    m_pColors[i].a() == a)
   40|      0|			return i;
   41|      0|	}
   42|      0|	return -1;
   43|      0|}
   44|       |
   45|       |void Palette::dump (void)
   46|      0|{
   47|      0|	printf ("palette size : %d\n", m_nColors);
   48|      0|	for (unsigned int i=0; i<m_nColors; i++)
   49|      0|		printf ("color %d / %d : %d %d %d %d\n", i, m_nColors,
   50|      0|			m_pColors[i].r(), m_pColors[i].g(), m_pColors[i].b(), m_pColors[i].a() );
   51|      0|}
   52|       |

/workspaces/cg/src/cgimg/palette.h:
    1|       |#pragma once
    2|       |
    3|       |#include "color.h"
    4|       |
    5|       |class Palette
    6|       |{
    7|       |public:
    8|       |	Palette ();
    9|       |	~Palette ();
   10|       |
   11|       |	unsigned int AddColor (unsigned char r, unsigned char g, unsigned char b, unsigned char a);
   12|       |	int IsPresent (unsigned char r, unsigned char g, unsigned char b, unsigned char a);
   13|       |
   14|      0|	inline unsigned int NColors (void) { return m_nColors; };
   15|       |
   16|       |	void dump (void);
   17|       |	
   18|       |public:
   19|       |	unsigned int m_nColors;
   20|       |	unsigned int m_nMaxColors;
   21|       |	Color *m_pColors;
   22|       |};

/workspaces/cg/src/cgmath/TMatrix3.h:
    1|       |#ifndef __TMATRIX3_H__
    2|       |#define __TMATRIX3_H__
    3|       |
    4|       |#include "TVector3.h"
    5|       |#include "common.h"
    6|       |
    7|       |#include <iostream>
    8|       |using namespace std;
    9|       |
   10|       |// TMatrix3[n][m] addresses the following element :
   11|       |// n = row
   12|       |// m = column
   13|       |// ie
   14|       |// m_Mat[0][0] m_Mat[0][1] m_Mat[0][2]
   15|       |// m_Mat[1][0] m_Mat[1][1] m_Mat[1][2]
   16|       |// m_Mat[2][0] m_Mat[2][1] m_Mat[2][2]
   17|       |
   18|       |template <class TValue>
   19|       |class TMatrix3 
   20|       |{
   21|       |public:
   22|       |
   23|       |	//
   24|       |	// Constructors
   25|       |	//
   26|       |
   27|       |	TMatrix3<TValue>()
   28|       |	{
   29|       |		SetIdentity();
   30|       |	}
   31|       |
   32|       |	TMatrix3<TValue>(TValue *mat)
   33|       |	{
   34|       |		memcpy( m_Mat, mat, 9*sizeof(TValue) );
   35|       |	}
   36|       |
   37|       |	TMatrix3<TValue>(
   38|       |				TValue m0, TValue m3, TValue m6,
   39|       |				TValue m1, TValue m4, TValue m7,
   40|       |				TValue m2, TValue m5, TValue m8
   41|       |				)
   42|      4|	{
   43|      4|		m_Mat[0][0]=m0; m_Mat[0][1]=m3; m_Mat[0][2]=m6;
   44|      4|		m_Mat[1][0]=m1; m_Mat[1][1]=m4; m_Mat[1][2]=m7;
   45|      4|		m_Mat[2][0]=m2; m_Mat[2][1]=m5; m_Mat[2][2]=m8;
   46|      4|	}
   47|       |
   48|       |	//
   49|       |	// Destructor
   50|       |	//
   51|       |
   52|       |	~TMatrix3<TValue>()
   53|      4|	{
   54|      4|	}
   55|       |
   56|       |	//
   57|       |	// Operators
   58|       |	//
   59|       |
   60|       |	inline TMatrix3<TValue>& operator=(TValue *mat)
   61|       |	{
   62|       |		memcpy( m_Mat, mat, 9*sizeof(TValue) );
   63|       |		return *this;
   64|       |	}
   65|       |
   66|       |	inline TMatrix3<TValue>& operator=(const TMatrix3<TValue> &src)
   67|       |	{
   68|       |		for (int i=0; i<3; i++) 
   69|       |			for (int j=0; j<3; j++) 
   70|       |				m_Mat[i][j] = src.m_Mat[i][j];
   71|       |		//memcpy( m_Mat, src.m_Mat, 9*sizeof(TValue) );
   72|       |		return *this;
   73|       |	}
   74|       |
   75|       |	inline bool operator==(const TMatrix3<TValue> &right) const
   76|       |	{
   77|       |		for (int i=0; i<3; i++) 
   78|       |			for (int j=0; j<3; j++) 
   79|       |				if ( m_Mat[i][j] != right.m_Mat[i][j] )
   80|       |					return false;
   81|       |
   82|       |		return true;
   83|       |	}
   84|       |
   85|       |	inline bool operator!=(const TMatrix3<TValue> &right) const
   86|       |	{
   87|       |		for (int i=0; i<3; i++) 
   88|       |			for (int j=0; j<3; j++) 
   89|       |				if ( m_Mat[i][j] != right.m_Mat[i][j] )
   90|       |					return true;
   91|       |
   92|       |		return false;
   93|       |	}
   94|       |
   95|       |	inline TMatrix3<TValue>& operator+=(const TMatrix3<TValue>& right)
   96|       |	{
   97|       |		TMatrix3<TValue> res;
   98|       |
   99|       |		for (int i=0; i<3; i++) 
  100|       |			for (int j=0; j<3; j++) 
  101|       |				res.m_Mat[i][j] = m_Mat[i][j] + right.m_Mat[i][j];
  102|       |
  103|       |		*this = res;
  104|       |		return *this;
  105|       |	}
  106|       |
  107|       |	inline TMatrix3<TValue>& operator*=(const TMatrix3<TValue>& right)
  108|       |	{
  109|       |		TMatrix3<TValue> res;
  110|       |		int i,j,k;
  111|       |
  112|       |		for (i=0; i<3; i++) 
  113|       |			for (j=0; j<3; j++) 
  114|       |			{
  115|       |				res.m_Mat[i][j] = 0.0;
  116|       |				for (k=0; k<3; k++) 
  117|       |					res.m_Mat[i][j] += m_Mat[i][k] * (right.m_Mat[k][j]);
  118|       |			}
  119|       |
  120|       |		*this = res;
  121|       |		return *this;
  122|       |	}
  123|       |
  124|       |	inline TMatrix3<TValue>& operator*= (TValue s)
  125|       |	{
  126|       |		for (int i=0; i<3; i++) 
  127|       |			for (int j=0; j<3; j++) 
  128|       |				m_Mat[i][j] *= s;
  129|       |
  130|       |		return *this;
  131|       |	}
  132|       |
  133|       |	inline TMatrix3<TValue> operator* (TValue s)
  134|       |	{
  135|       |		return TMatrix3<TValue>(m_Mat[0][0]*s, m_Mat[0][1]*s, m_Mat[0][2]*s,
  136|       |	m_Mat[1][0]*s, m_Mat[1][1]*s, m_Mat[1][2]*s,
  137|       |	   m_Mat[2][0]*s, m_Mat[2][1]*s, m_Mat[2][2]*s);
  138|       |		}
  139|       |
  140|       |
  141|       |	TMatrix3<TValue> operator* (const TMatrix3<TValue>& right) const
  142|       |	{
  143|       |	TMatrix3<TValue> res;
  144|       |	int i,j,k;
  145|       |		
  146|       |		for (i=0; i<3; i++) 
  147|       |			for (j=0; j<3; j++) 
  148|       |			{
  149|       |				res.m_Mat[i][j] = 0.0;
  150|       |				for (k=0; k<3; k++) 
  151|       |					res.m_Mat[i][j] += m_Mat[i][k] * (right.m_Mat[k][j]);
  152|       |			}
  153|       |
  154|       |	return res;
  155|       |	}
  156|       |
  157|       |	//
  158|       |	// Set
  159|       |	//
  160|       |
  161|       |	inline void SetIdentity(void)
  162|      0|	{
  163|      0|		m_Mat[0][0]=1; m_Mat[0][1]=0; m_Mat[0][2]=0;
  164|      0|		m_Mat[1][0]=0; m_Mat[1][1]=1; m_Mat[1][2]=0;
  165|      0|		m_Mat[2][0]=0; m_Mat[2][1]=0; m_Mat[2][2]=1;
  166|      0|	}
  167|       |
  168|       |	inline void Set(
  169|       |				TValue m0, TValue m3, TValue m6,
  170|       |				TValue m1, TValue m4, TValue m7,
  171|       |				TValue m2, TValue m5, TValue m8
  172|       |				)
  173|      4|	{
  174|      4|		m_Mat[0][0]=m0; m_Mat[0][1]=m3; m_Mat[0][2]=m6;
  175|      4|		m_Mat[1][0]=m1; m_Mat[1][1]=m4; m_Mat[1][2]=m7;
  176|      4|		m_Mat[2][0]=m2; m_Mat[2][1]=m5; m_Mat[2][2]=m8;
  177|      4|	}
  178|       |
  179|       |	inline TValue *Multiply(TValue *mat)
  180|       |	{
  181|       |	TMatrix3<TValue> res;
  182|       |	int i,j,k;
  183|       |	TMatrix3<TValue> TempMatrice(mat);
  184|       |		
  185|       |		for (i=0; i<3; i++) 
  186|       |			for (j=0; j<3; j++) 
  187|       |			{
  188|       |				res.m_Mat[i][j] = 0.0;
  189|       |				for (k=0; k<3; k++) 
  190|       |					res.m_Mat[i][j] += m_Mat[i][k] * (TempMatrice.m_Mat[k][j]);
  191|       |			}
  192|       |
  193|       |		*this = res;
  194|       |
  195|       |		return (TMatrix3<TValue>)(&res.m_Mat[0][0]);
  196|       |	}
  197|       |
  198|       |
  199|       |	//
  200|       |	// ROTATION
  201|       |	//
  202|       |
  203|       |	/*! Create a rotation matrice
  204|       |	\param angle - Angle value for the rotation
  205|       |	\param x - X value rotation vector
  206|       |	\param y - Y Value rotation vector
  207|       |	\param z - Z Value rotation vector
  208|       |	*/
  209|       |	inline void SetRotation( TValue angle, TValue x, TValue y, TValue z )
  210|       |	{
  211|       |		TValue length;
  212|       |		TValue c,s,t;
  213|       |		TValue theta = 3.14159*angle/180.;//RS_DEGTORAD(angle);
  214|       |		
  215|       |		// Normalize
  216|       |		length = sqrtf(x*x + y*y + z*z);
  217|       |		
  218|       |		// Too close to 0, can't make a normalized vector
  219|       |		if (length < 0.000001f)
  220|       |			return;
  221|       |		
  222|       |		x /= length; y /= length; z /= length;
  223|       |		
  224|       |		// Do the trig
  225|       |		c = cosf(theta);
  226|       |		s = sinf(theta);
  227|       |		t = 1-c;   
  228|       |		
  229|       |		// Build the rotation matrix
  230|       |		m_Mat[0][0] = t*x*x + c;   m_Mat[0][1] = t*x*y - s*z; m_Mat[0][2] = t*x*z + s*y;
  231|       |		m_Mat[1][0] = t*x*y + s*z; m_Mat[1][1] = t*y*y + c;   m_Mat[1][2] = t*y*z - s*x;
  232|       |		m_Mat[2][0] = t*x*z - s*y; m_Mat[2][1] = t*y*z + s*x; m_Mat[2][2] = t*z*z + c;
  233|       |	}
  234|       |
  235|       |	/*! Create a rotation matrice
  236|       |	\param angle - Angle value for the rotation
  237|       |	\param x - X value rotation vector
  238|       |	\param y - Y Value rotation vector
  239|       |	\param z - Z Value rotation vector
  240|       |	*/
  241|       |	void SetRotation( TValue angle, TVector3<TValue> vRot )
  242|       |	{
  243|       |		SetRotation( angle, vRot.x, vRot.y, vRot.z );
  244|       |	}
  245|       |
  246|       |	/*! Create a rotation matrice around a single axis
  247|       |	\param angle - Angle value for the rotation around X Axis
  248|       |	*/
  249|       |	void SetRotation_X( TValue angle )
  250|       |	{
  251|       |		TValue s = (TValue)sin(DEGTORAD(angle));
  252|       |		TValue c = (TValue)cos(DEGTORAD(angle));
  253|       |
  254|       |		SetIdentity();
  255|       |
  256|       |		m_Mat[1][1] =  c;   m_Mat[1][2] = -s;
  257|       |		m_Mat[2][1] =  s;   m_Mat[2][2] =  c;
  258|       |	}
  259|       |
  260|       |	/*! Create a rotation matrice around a single axis
  261|       |	\param angle - Angle value for the rotation around Y Axis
  262|       |	*/
  263|       |	void SetRotation_Y( TValue angle )
  264|       |	{
  265|       |		TValue s = (TValue)sin(DEGTORAD(angle));
  266|       |		TValue c = (TValue)cos(DEGTORAD(angle));
  267|       |
  268|       |		SetIdentity();
  269|       |
  270|       |		m_Mat[0][0] =  c;   m_Mat[0][2] =  s;
  271|       |		m_Mat[2][0] = -s;   m_Mat[2][2] =  c;
  272|       |	}
  273|       |
  274|       |	/*! Create a rotation matrice around a single axis
  275|       |	\param angle - Angle value for the rotation around Z Axis
  276|       |	*/
  277|       |	void SetRotation_Z( TValue angle )
  278|       |	{
  279|       |		TValue s = (TValue)sin(DEGTORAD(angle));
  280|       |		TValue c = (TValue)cos(DEGTORAD(angle));
  281|       |
  282|       |		SetIdentity();
  283|       |
  284|       |		m_Mat[0][0] =  c;   m_Mat[1][1] = -s;
  285|       |		m_Mat[1][0] =  s;   m_Mat[1][1] =  c;
  286|       |	}
  287|       |	//
  288|       |	// ROTATION - END
  289|       |	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  290|       |
  291|       |	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  292|       |	// TRANSFORMATION
  293|       |	//
  294|       |	/*! Set the values for scaling
  295|       |	\
  296|       |	*/
  297|       |	inline void SetScale( TValue x, TValue y, TValue z )
  298|       |	{
  299|       |		m_Mat[0][0] = x;
  300|       |		m_Mat[1][1] = y;
  301|       |		m_Mat[2][2] = z;
  302|       |	}
  303|       |
  304|       |	/*! Transform a point or a vector using the matrix (Rotation scale and translation)
  305|       |	\param vec - The point/vector to transform
  306|       |	*/
  307|       |	inline void TransformPoint( TVector3<TValue> &vec )
  308|       |	{
  309|       |		TValue x = vec.x;
  310|       |		TValue y = vec.y;
  311|       |		TValue z = vec.z;
  312|       |
  313|       |		//Since it's a point we are computing using the translation
  314|       |		vec.x = x * m_Mat[0][0] + y * m_Mat[0][1] + z * m_Mat[0][2];
  315|       |		vec.y = x * m_Mat[1][0] + y * m_Mat[1][1] + z * m_Mat[1][2];
  316|       |		vec.z = x * m_Mat[2][0] + y * m_Mat[2][1] + z * m_Mat[2][2];
  317|       |	}
  318|       |
  319|       |	//Exactly the same function as above in the form of operator
  320|       |	inline friend TVector3<TValue> operator* (const TMatrix3<TValue> &mat,const TVector3<TValue> &t)
  321|       |	{
  322|       |		return TVector3<TValue>(
  323|       |				mat.m_Mat[0][0]*t.x + mat.m_Mat[0][1]*t.y + mat.m_Mat[0][2]*t.z,
  324|       |				mat.m_Mat[1][0]*t.x + mat.m_Mat[1][1]*t.y + mat.m_Mat[1][2]*t.z,
  325|       |				mat.m_Mat[2][0]*t.x + mat.m_Mat[2][1]*t.y + mat.m_Mat[2][2]*t.z
  326|       |				);
  327|       |	}
  328|       |
  329|       |
  330|       |	//
  331|       |	// TRANSFORMATION - END
  332|       |	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  333|       |
  334|       |	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  335|       |	// MATH
  336|       |	//
  337|       |
  338|       |
  339|       |	/*! isSymmetric
  340|       |	*/
  341|       |	bool isSymmetric (void)
  342|      0|	{
  343|      0|		if (m_Mat[0][1] == m_Mat[1][0] &&
  344|      0|			m_Mat[0][2] == m_Mat[2][0] &&
  345|      0|			m_Mat[1][2] == m_Mat[2][1] )
  346|      0|			return true;
  347|      0|		else
  348|      0|			return false;
  349|      0|	}
  350|       |
  351|       |	/*! Transpose the matrix
  352|       |	*/
  353|       |	void Transpose()
  354|       |	{
  355|       |		for (int i=0; i<3; i++ ) 
  356|       |			for (int j=i+1; j<3; j++ )
  357|       |			{
  358|       |				TValue tmp = m_Mat[i][j];
  359|       |				m_Mat[i][j] = m_Mat[j][i];
  360|       |				m_Mat[j][i] = tmp;
  361|       |			}
  362|       |	}
  363|       |
  364|       |	/*! Return transpose matrix
  365|       |	\param TransposeMatrix - The matrix to transpose
  366|       |	\return TValue* - Transpose matrix
  367|       |	*/
  368|       |	/*
  369|       |	TValue *GetTranspose(TValue *TransposeMatrix)
  370|       |	{
  371|       |		int i,j;
  372|       |		TMatrix3<TValue> TempMatrice(TransposeMatrix);
  373|       |			
  374|       |			for ( i=0; i<3; i++ ) 
  375|       |				for ( j=0; j<3; j++ ) 
  376|       |					TempMatrice.m_Mat[i][j]= m_Mat[j][i];
  377|       |
  378|       |			return (TMatrix3<TValue>)(&TempMatrice.m_Mat[0][0]);
  379|       |	}
  380|       |	*/
  381|       |
  382|       |	inline TValue Determinant()
  383|      4|	{
  384|      4|		TValue d = m_Mat[0][0] * (m_Mat[1][1]*m_Mat[2][2] - m_Mat[2][1]*m_Mat[1][2])
  385|      4|				 - m_Mat[1][0] * (m_Mat[0][1]*m_Mat[2][2] - m_Mat[2][1]*m_Mat[0][2])
  386|      4|				 + m_Mat[2][0] * (m_Mat[0][1]*m_Mat[1][2] - m_Mat[1][1]*m_Mat[0][2]);
  387|       |
  388|      4|		return d;
  389|      4|	}
  390|       |
  391|       |	/*! Inverse the matrix
  392|       |	\return Returns FALSE if there is no inverse matrix.
  393|       |	*/
  394|       |	inline bool Inverse(void)
  395|      4|	{
  396|       |		// Calculates the inverse of this Matrix 
  397|       |		// The inverse is calculated using Cramers rule.
  398|       |		// If no inverse exists then 'FALSE' is returned.
  399|       |
  400|      4|		TValue d = Determinant();
  401|      4|		if (d == 0.f)	//Impossible to inverse the matrix
  402|      0|			return false;
  403|       |
  404|       |		//To avoid multiple division
  405|      4|		d = 1. / d;
  406|       |
  407|       |		// http://fr.wikipedia.org/wiki/Matrice_inversible
  408|      4|		TValue m00 = (m_Mat[1][1]*m_Mat[2][2] - m_Mat[1][2]*m_Mat[2][1]) * d;
  409|      4|		TValue m01 = (m_Mat[0][2]*m_Mat[2][1] - m_Mat[0][1]*m_Mat[2][2]) * d;
  410|      4|		TValue m02 = (m_Mat[0][1]*m_Mat[1][2] - m_Mat[0][2]*m_Mat[1][1]) * d;
  411|       |		
  412|      4|		TValue m10 = (m_Mat[1][2]*m_Mat[2][0] - m_Mat[1][0]*m_Mat[2][2]) * d;
  413|      4|		TValue m11 = (m_Mat[0][0]*m_Mat[2][2] - m_Mat[0][2]*m_Mat[2][0]) * d;
  414|      4|		TValue m12 = (m_Mat[0][2]*m_Mat[1][0] - m_Mat[0][0]*m_Mat[1][2]) * d;
  415|       |		
  416|      4|		TValue m20 = (m_Mat[2][1]*m_Mat[1][0] - m_Mat[1][1]*m_Mat[2][0]) * d;
  417|      4|		TValue m21 = (m_Mat[0][1]*m_Mat[2][0] - m_Mat[0][0]*m_Mat[2][1]) * d;
  418|      4|		TValue m22 = (m_Mat[0][0]*m_Mat[1][1] - m_Mat[0][1]*m_Mat[1][0]) * d;
  419|       |
  420|      4|		Set (	m00, m01, m02,
  421|      4|				m10, m11, m12,
  422|      4|				m20, m21, m22	);
  423|       |
  424|      4|		return true;
  425|      4|	}
  426|       |
  427|       |	/*! Calculate the inverse of the current matrix
  428|       |	\param OutMatrix - In return contains the inverted matrix
  429|       |	\return Returns FALSE if there is no inverse matrix.
  430|       |	*/
  431|       |	inline bool GetInverse(TMatrix3<TValue>& OutMatrix)
  432|       |	{
  433|       |		// Calculates the inverse of this Matrix 
  434|       |		// The inverse is calculated using Cramers rule.
  435|       |		// If no inverse exists then 'FALSE' is returned.
  436|       |
  437|       |		const TMatrix3<TValue> &m = *this;
  438|       |
  439|       |		TValue d = Determinant();
  440|       |				
  441|       |			if (d == 0.f)	//Impossible to inverse the matrix
  442|       |				return false;
  443|       |
  444|       |			//To avoid multiple division
  445|       |			d = 1.f / d;
  446|       |
  447|       |/*
  448|       |  TValue inv[9];
  449|       |  TValue fdet, finvdet;
  450|       |  
  451|       |  inv[0] = m[4]*m[8] - m[5]*m[7];
  452|       |  inv[1] = m[2]*m[7] - m[1]*m[8];
  453|       |  inv[2] = m[1]*m[5] - m[2]*m[4];
  454|       |  inv[3] = m[5]*m[6] - m[3]*m[8];
  455|       |  inv[4] = m[0]*m[8] - m[2]*m[6];
  456|       |  inv[5] = m[2]*m[3] - m[0]*m[5];
  457|       |  inv[6] = m[3]*m[7] - m[4]*m[6];
  458|       |  inv[7] = m[1]*m[6] - m[0]*m[7];
  459|       |  inv[8] = m[0]*m[4] - m[1]*m[3];
  460|       |
  461|       |  fdet = m[0]*inv[0] + m[1]*inv[3] + m[2]*inv[6];
  462|       |  if (fdet == 0.0) return false;
  463|       |  finvdet = 1.0f/fdet;
  464|       |
  465|       |  m[0] = inv[0] * finvdet;
  466|       |  m[1] = inv[1] * finvdet;
  467|       |  m[2] = inv[2] * finvdet;
  468|       |  m[3] = inv[3] * finvdet;
  469|       |  m[4] = inv[4] * finvdet;
  470|       |  m[5] = inv[5] * finvdet;
  471|       |  m[6] = inv[6] * finvdet;
  472|       |  m[7] = inv[7] * finvdet;
  473|       |  m[8] = inv[8] * finvdet;
  474|       |
  475|       |  return true;
  476|       |*/
  477|       |		return true;
  478|       |	}
  479|       |
  480|       |	/*! Calculate the inverse of the current matrix and assign
  481|       |	the result to our object
  482|       |	\return Returns FALSE if there is no inverse matrix.
  483|       |	*/
  484|       |	inline bool SetInverse()
  485|       |	{
  486|       |		TMatrix3<TValue> OutMatrix;
  487|       |
  488|       |		bool bRet = GetInverse( OutMatrix );
  489|       |
  490|       |		*this = OutMatrix;
  491|       |		return bRet;
  492|       |	}
  493|       |
  494|       |	//
  495|       |	// MATH - END
  496|       |	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  497|       |
  498|       |	/*! Return a pointer to the array of value used as our matrix
  499|       |	\return TValue* - Pointer to a linear array of value
  500|       |	*/
  501|       |	inline TValue *GetMatPtr()
  502|       |	{
  503|       |		return &m_Mat[0][0];
  504|       |	}
  505|       |
  506|       |	/*! Return a pointer to the array of value used as our matrix
  507|       |	\return TValue* - Pointer to a linear array of value
  508|       |	*/
  509|       |	inline operator TValue* ()
  510|       |	{
  511|       |		return &m_Mat[0][0];
  512|       |	}   
  513|       |
  514|       |	//
  515|       |	// Algebra
  516|       |	//
  517|       |/**
  518|       |* Used by the method solving the eigensystem.
  519|       |*/
  520|       |void tridiagonal (TValue diag[3], TValue subd[3])
  521|      0|{
  522|      0|  TValue fm00 = m_Mat[0][0];
  523|      0|  TValue fm01 = m_Mat[0][1];
  524|      0|  TValue fm02 = m_Mat[0][2];
  525|      0|  TValue fm11 = m_Mat[1][1];
  526|      0|  TValue fm12 = m_Mat[1][2];
  527|      0|  TValue fm22 = m_Mat[2][2];
  528|       |  
  529|      0|  diag[0] = fm00;
  530|      0|  subd[2] = 0.0;
  531|      0|  if (fm02 != 0.0)
  532|      0|  {
  533|      0|      TValue length = sqrt (fm01*fm01 + fm02*fm02);
  534|      0|      TValue invlength = 1.0 / length;
  535|      0|      TValue q;
  536|      0|      fm01 *= invlength;
  537|      0|      fm02 *= invlength;
  538|      0|      q = 2.0*fm01*fm12 + fm02*(fm22-fm11);
  539|      0|      diag[1] = fm11+fm02*q;
  540|      0|      diag[2] = fm22-fm02*q;
  541|      0|      subd[0] = length;
  542|      0|      subd[1] = fm12-fm01*q;
  543|      0|	  Set (	1.0, 0.0, 0.0,
  544|      0|			0.0, fm01, fm02,
  545|      0|			0.0, fm02, -fm01	);
  546|      0|  }
  547|      0|  else
  548|      0|  {
  549|      0|      diag[1] = fm11;
  550|      0|      diag[2] = fm22;
  551|      0|      subd[0] = fm01;
  552|      0|      subd[1] = fm12;
  553|      0|	  SetIdentity ();
  554|      0|  }
  555|      0|}
  556|       |
  557|       |/**
  558|       |* QL algorithm. This transform is used to solve the eigensystem.
  559|       |*/
  560|       |bool QLalgorithm (TValue diag[3], TValue subd[3])
  561|      0|{
  562|      0|	int imaxiter = 32;
  563|      0|	int i0, i1=0, i2, i3, i4;
  564|       |	
  565|      0|	for (i0=0; i0<3; i0++)
  566|      0|    {
  567|      0|		TValue G, R;
  568|      0|		TValue sinus, cosinus, P;
  569|       |		
  570|      0|		for (i2=i0; i2<=1; i2++)
  571|      0|		{
  572|      0|			TValue tmp = fabs (diag[i2]) + fabs(diag[i2+1]);
  573|      0|			if (fabs(subd[i2])+tmp == tmp)
  574|      0|				break;
  575|      0|		}
  576|      0|		if (i2 == i0)
  577|      0|			break;
  578|       |		
  579|      0|		G = (diag[i0+1] - diag[i0]) / (2.0*subd[i0]);
  580|      0|		R = sqrt (G*G+1.0);
  581|      0|		if (G < 0.0)
  582|      0|			G = diag[i2] - diag[i0] + subd[i0] / (G - R);
  583|      0|		else
  584|      0|			G = diag[i2] - diag[i0] + subd[i0] / (G + R);
  585|       |		
  586|      0|		sinus = 1.0;
  587|      0|		cosinus = 1.0;
  588|      0|		P = 0.0;
  589|       |		
  590|      0|		for (i3=i2-1; i3>=i0; i3--)
  591|      0|		{
  592|      0|			TValue F = sinus*subd[i3];
  593|      0|			TValue B = cosinus*subd[i3];
  594|      0|			if (fabs(F) >= fabs(G))
  595|      0|			{
  596|      0|				cosinus = G/F;
  597|      0|				R = sqrt(cosinus*cosinus + 1.0);
  598|      0|				subd[i3+1] = F*R;
  599|      0|				sinus = 1.0/R;
  600|      0|				cosinus *= sinus;
  601|      0|			}
  602|      0|			else
  603|      0|			{
  604|      0|				sinus = F/G;
  605|      0|				R = sqrt (sinus*sinus + 1.0);
  606|      0|				subd[i3+1]=G*R;
  607|      0|				cosinus = 1.0/R;
  608|      0|				sinus *= cosinus;
  609|      0|			}
  610|      0|			G = diag[i3+1] - P;
  611|      0|			R = (diag[i3] - G)*sinus + 2.0*B*cosinus;
  612|      0|			P = sinus*R;
  613|      0|			diag[i3+1] = G + P;
  614|      0|			G = cosinus*R - B;
  615|       |			
  616|      0|			for (i4=0; i4<3; i4++)
  617|      0|			{
  618|      0|				F = m_Mat[i4][i3+1];
  619|      0|				m_Mat[i4][i3+1] = sinus*m_Mat[i4][i3] + cosinus*F;
  620|      0|				m_Mat[i4][i3] = cosinus*m_Mat[i4][i3] - sinus*F;
  621|      0|			}
  622|      0|		}
  623|      0|		diag[i0] -= P;
  624|      0|		subd[i0] = G;
  625|      0|		subd[i2] = 0.0;
  626|      0|    }
  627|      0|	if (i1 == imaxiter)
  628|      0|		return false;
  629|       |	
  630|      0|	return true;
  631|      0|}
  632|       |
  633|       |/**
  634|       |* Used by the method solving the eigensystem.
  635|       |*/
  636|       |void decreasingsort (TValue diag[3], TValue subd[3])
  637|      0|{
  638|      0|  int i0, i1, i2;
  639|       |
  640|      0|  for (i0=0, i1; i0<=1; i0++)
  641|      0|    {
  642|      0|      TValue max;
  643|      0|      i1 = i0;
  644|      0|      max = diag[i1];
  645|      0|      for (i2=i0+1; i2<3; i2++)
  646|      0|	{
  647|      0|	  if (diag[i2] > max)
  648|      0|	    {
  649|      0|	      i1 = i2;
  650|      0|	      max = diag[i1];
  651|      0|	    }
  652|      0|	}
  653|       |      
  654|      0|      if (i1 != i0)
  655|      0|	{
  656|      0|	  diag[i1] = diag[i0];
  657|      0|	  diag[i0] = max;
  658|       |
  659|      0|	  for (i2=0; i2<3; i2++)
  660|      0|	    {
  661|      0|	      TValue tmp = m_Mat[i2][i0];
  662|      0|	      m_Mat[i2][i0] = m_Mat[i2][i1];
  663|      0|		  m_Mat[i2][i1] = tmp;
  664|      0|	    }
  665|      0|	}
  666|      0|    }
  667|      0|}
  668|       |
  669|       |/**
  670|       |* Solve the eigensystem based on the matrix.
  671|       |*
  672|       |* The steps followed by the algorithm are :
  673|       |*
  674|       |* tridiagonal.
  675|       |*
  676|       |* QLalgorithm.
  677|       |*
  678|       |* decreasingsort.
  679|       |*
  680|       |* The vector v contains the 3 eigenvalues.
  681|       |* The eigenvectors associated to the eigenvalues are stored in the
  682|       |* vectors e1, e2 and e3.
  683|       |*
  684|       |* \returns false if the eigensystem can't be solved , true otherwise.
  685|       |*/
  686|       |int SolveEigensystem (TVector3<TValue>& e1, TVector3<TValue>& e2, TVector3<TValue>& e3, TVector3<TValue>& v)
  687|      0|{
  688|      0|  if (Determinant() == 0)
  689|      0|  {
  690|      0|	  return false;
  691|      0|  }
  692|       |
  693|      0|  if (isSymmetric ())
  694|      0|  {
  695|      0|	  TMatrix3<TValue> tmp (*this);
  696|       |
  697|      0|	  TValue diag[3] = {0.0, 0.0, 0.0};
  698|      0|	  TValue subd[3] = {0.0, 0.0, 0.0};
  699|      0|	  tmp.tridiagonal    (diag, subd);
  700|      0|	  tmp.QLalgorithm    (diag, subd);
  701|      0|	  tmp.decreasingsort (diag, subd);
  702|       |
  703|      0|	  e1.Set (tmp.m_Mat[0][0], tmp.m_Mat[1][0], tmp.m_Mat[2][0]);
  704|      0|	  e2.Set (tmp.m_Mat[0][1], tmp.m_Mat[1][1], tmp.m_Mat[2][1]);
  705|      0|	  e3.Set (tmp.m_Mat[0][2], tmp.m_Mat[1][2], tmp.m_Mat[2][2]);
  706|      0|	  v.Set (diag[0], diag[1], diag[2]);
  707|      0|	  return true;
  708|      0|  }
  709|      0|  else
  710|      0|  {
  711|      0|	  return false;
  712|      0|  }
  713|      0|}
  714|       |
  715|       |/**
  716|       |* Solve the linear system based on the matrix.
  717|       |*
  718|       |* The vector right contains the right part of the linear system.
  719|       |* The vector sol contains the solution.
  720|       |*
  721|       |* \returns false if the linear system can't be solved , true otherwise.
  722|       |*/
  723|       |	bool SolveLinearsystem (TVector3<TValue> right, TVector3<TValue> &sol)
  724|       |	{
  725|       |		TValue det = Determinant ();
  726|       |		if (!det)
  727|       |		{
  728|       |		  return false;
  729|       |		}
  730|       |
  731|       |		det = 1./det;
  732|       |
  733|       |		// Cramer's rule
  734|       |		TMatrix3<TValue> tmp;
  735|       |		tmp.Set (right.x, m_Mat[0][1], m_Mat[0][2],
  736|       |			right.y, m_Mat[1][1], m_Mat[1][2],
  737|       |			right.z, m_Mat[2][1], m_Mat[2][2]);
  738|       |		TValue resultx = tmp.Determinant () * det;
  739|       |
  740|       |		tmp.Set (m_Mat[0][0], right.x, m_Mat[0][2],
  741|       |			m_Mat[1][0], right.y, m_Mat[1][2],
  742|       |			m_Mat[2][0], right.z, m_Mat[2][2]);
  743|       |		TValue resulty = tmp.Determinant () * det;
  744|       |
  745|       |		tmp.Set (m_Mat[0][0], m_Mat[0][1], right.x,
  746|       |			m_Mat[1][0], m_Mat[1][1], right.y,
  747|       |			m_Mat[2][0], m_Mat[2][1], right.z);
  748|       |		TValue resultz = tmp.Determinant () * det;
  749|       |
  750|       |		sol.Set (resultx, resulty, resultz);
  751|       |
  752|       |		return true;
  753|       |	}
  754|       |
  755|       |	//
  756|       |	// IOstream
  757|       |	//
  758|       |
  759|       |	friend ostream & operator << ( ostream & out, const TMatrix3<TValue> &right)
  760|       |	{
  761|       |		return out << "( " << right.m_Mat[0][0] << " , " << right.m_Mat[0][1] << " , " << right.m_Mat[0][2] << " )" << endl \
  762|       |			<< "( " << right.m_Mat[1][0] << " , " << right.m_Mat[1][1] << " , " << right.m_Mat[1][2] << " )" << endl \
  763|       |			<< "( " << right.m_Mat[2][0] << " , " << right.m_Mat[2][1] << " , " << right.m_Mat[2][2] << " )";
  764|       |	}
  765|       |
  766|       |public:
  767|       |
  768|       |	TValue m_Mat[3][3];
  769|       |};
  770|       |
  771|       |typedef TMatrix3<int>    Matrix3i;
  772|       |typedef TMatrix3<float>  Matrix3f;
  773|       |typedef TMatrix3<double> Matrix3d;
  774|       |typedef TMatrix3<float>  Matrix3;
  775|       |
  776|       |#endif	// __TMATRIX3_H__

/workspaces/cg/src/cgmath/TVector2.h:
    1|       |#ifndef __TVECTOR2_H__
    2|       |#define __TVECTOR2_H__
    3|       |
    4|       |#include <iostream>
    5|       |using namespace std;
    6|       |
    7|       |template <class TValue>
    8|       |class TVector2
    9|       |{
   10|       |public:
   11|       |	TVector2(TValue _x = (TValue)0, TValue _y = (TValue)0)
   12|      0|	{ x = _x; y = _y; }
   13|       |
   14|       |	template <class S>
   15|       |	TVector2(const TVector2<S> &src)
   16|       |	{ x = src.x; y = src.y; }
   17|       |
   18|      0|	~TVector2() {};
   19|       |
   20|       |	//
   21|       |	// Operators
   22|       |	//
   23|       |	template <class S>
   24|       |	inline TVector2<TValue> &operator= (const TVector2<S>& right)
   25|       |	{
   26|       |		x = (TValue)right.x;
   27|       |		y = (TValue)right.y;
   28|       |		return *this;
   29|       |	}
   30|       |
   31|       |	template <class S>
   32|       |	inline TVector2<TValue> operator+ (const TVector2<S> &right) const
   33|       |	{
   34|       |		return TVector2(x + (TValue)right.x, y + (TValue)right.y);
   35|       |	}
   36|       |
   37|       |	template <class S>
   38|       |	inline TVector2<TValue> operator- (const TVector2<S> &right) const
   39|       |	{
   40|       |		return TVector2(x - (TValue)right.x, y - (TValue)right.y);
   41|       |	}
   42|       |
   43|       |	inline TVector2<TValue> operator * (const TValue s)
   44|       |	{
   45|       |		return TVector2<TValue>(x*s, y*s);
   46|       |	}
   47|       |
   48|       |	template <class S>
   49|       |	inline TValue operator * (const TVector2<S> &right)
   50|       |	{
   51|       |		return TValue(x*right.x + y*right.y);
   52|       |	}
   53|       |
   54|       |	inline TVector2<TValue>  operator / (const TValue s)
   55|       |	{
   56|       |		return (s)? TVector2<TValue>(x/s,y/s) : TVector2<TValue>(0,0);
   57|       |	}
   58|       |
   59|       |	template <class S>
   60|       |	inline TVector2<TValue> &operator += (const TVector2<S> &right)
   61|       |	{
   62|       |		x+=(TValue)right.x;
   63|       |		y+=(TValue)right.y;
   64|       |		return *this;
   65|       |	}
   66|       |
   67|       |	template <class S>
   68|       |	inline TVector2<TValue> &operator -= (const TVector2<S> &right)
   69|       |	{
   70|       |		x-=(TValue)right.x;
   71|       |		y-=(TValue)right.y;
   72|       |		return *this;
   73|       |	}
   74|       |
   75|       |	inline TVector2<TValue> &operator *= (const TValue s)
   76|       |	{
   77|       |		x*=s;
   78|       |		y*=s;
   79|       |		return *this;
   80|       |	}
   81|       |
   82|       |	inline TVector2<TValue> &operator /= (const TValue s)
   83|       |	{
   84|       |		if(s)
   85|       |		{
   86|       |			x/=s;
   87|       |			y/=s;
   88|       |		}
   89|       |		return *this;
   90|       |	}
   91|       |
   92|       |	inline operator const TValue*() const
   93|       |	{
   94|       |		return &x;
   95|       |	}
   96|       |
   97|       |    inline operator TValue*()
   98|       |	{
   99|       |		return &x;
  100|       |	}   
  101|       |
  102|       |	inline const TValue operator[](int i) const
  103|       |	{
  104|       |		return (i==0 || i==1)? ((TValue*)&x)[i] : ((TValue*)&x)[0];
  105|       |	}
  106|       |
  107|       |	inline TValue &operator[](int i)
  108|      0|	{
  109|      0|		return (i==0 || i==1)? ((TValue*)&x)[i] : ((TValue*)&x)[0];
  110|      0|	}
  111|       |
  112|       |	template <class S>
  113|       |	bool operator == (const TVector2<S> &right)
  114|       |	{
  115|       |		return (x == right.x && y == right.y);
  116|       |	}
  117|       |
  118|       |	template <class S>
  119|       |	bool operator != (const TVector2<S> &right)
  120|       |	{
  121|       |		return !(x == right.x && y == right.y );
  122|       |	}
  123|       |
  124|       |	//
  125|       |	// Set
  126|       |	//
  127|       |
  128|       |	void Set(TValue _x, TValue _y)
  129|       |	{
  130|       |		x = _x;
  131|       |		y = _y;
  132|       |	}
  133|       |
  134|       |	//
  135|       |	// Utils
  136|       |	//
  137|       |
  138|       |	inline void Clamp(TValue min, TValue max)
  139|       |	{
  140|       |		x = (x > max)? max : (x < min)? min : x;
  141|       |		y = (y > max)? max : (y < min)? min : y;
  142|       |	}
  143|       |
  144|       |	inline TVector2<TValue> &Normalize()
  145|       |	{
  146|       |		TValue length = getLength();
  147|       |
  148|       |		if(!length)
  149|       |		{
  150|       |			Set(0,0);
  151|       |		}
  152|       |		else
  153|       |		{
  154|       |			x/=length;
  155|       |			y/=length;
  156|       |		}
  157|       |
  158|       |		return *this;
  159|       |	}
  160|       |
  161|       |	inline const TValue getLength2() const
  162|       |	{
  163|       |		return  x*x + y*y;
  164|       |	}
  165|       |
  166|       |	inline const TValue getLength() const
  167|       |	{
  168|       |		return sqrt(getLength2());
  169|       |	}
  170|       |
  171|       |	template <class S>
  172|       |	inline const TValue DotProduct(const TVector2<S> &t) const
  173|       |	{
  174|       |		return x*t.x + y*t.y;
  175|       |	}
  176|       |
  177|       |	template <class S>
  178|       |	inline const TValue getDistance(const TVector2<S> &v2)  const 
  179|       |	{
  180|       |		return sqrt(
  181|       |				(v2.x - x) * (v2.x - x) +
  182|       |				(v2.y - y) * (v2.y - y)
  183|       |				);
  184|       |	}
  185|       |	
  186|       |	template <class S>
  187|       |	inline const TValue getAngle(const TVector2<S> &v2)  const 
  188|       |	{             
  189|       |		return acos( DotProduct(v2) / (getLength() * v2.getLength()));
  190|       |	}
  191|       |
  192|       |	//
  193|       |	// IOstream
  194|       |	//
  195|       |
  196|       |	friend ostream & operator << ( ostream & out, const TVector2<TValue> &right)
  197|       |	{
  198|       |		return out << "( " << right.x << " , " << right.y <<" )";
  199|       |	}
  200|       |
  201|       |	friend istream & operator >> (istream & in, TVector2<TValue> &right)
  202|       |	{
  203|       |		return in >> right.x >> right.y;
  204|       |	}
  205|       |
  206|       |public:
  207|       |
  208|       |	TValue x, y;
  209|       |};
  210|       |
  211|       |typedef TVector2<int> Vector2i;
  212|       |typedef TVector2<float> Vector2f;
  213|       |typedef TVector2<double> Vector2d;
  214|       |typedef TVector2<float> Vector2;
  215|       |
  216|       |#endif	// __TVECTOR2_H__

/workspaces/cg/src/cgmath/TVector3.h:
    1|       |#ifndef __TVECTOR3_H__
    2|       |#define __TVECTOR3_H__
    3|       |
    4|       |#include <math.h>
    5|       |#include <iostream>
    6|       |using namespace std;
    7|       |
    8|       |template <class TValue>
    9|       |class TVector3
   10|       |{
   11|       |public:
   12|       |	TVector3<TValue>(TValue _x = 0, TValue _y = 0, TValue _z = 0)
   13|  12.3M|	{ x = _x; y = _y; z = _z; }
  ------------------
  | _ZN8TVector3IfEC2Efff:
  |   13|  12.3M|	{ x = _x; y = _y; z = _z; }
  ------------------
  | Unexecuted instantiation: _ZN8TVector3IdEC2Eddd
  ------------------
   14|       |
   15|       |	template <class S>
   16|       |	TVector3<TValue>(const TVector3<S> &src)
   17|       |	{
   18|       |		x = (TValue)src.x;
   19|       |		y = (TValue)src.y;
   20|       |		z = (TValue)src.z;
   21|       |	}
   22|       |
   23|       |	//
   24|       |	// Operators
   25|       |	//
   26|       |	inline TVector3<TValue> &operator = (const TVector3<TValue> &right)
   27|  2.70M|	{
   28|  2.70M|		x = (TValue)right.x;
   29|  2.70M|		y = (TValue)right.y;
   30|  2.70M|		z = (TValue)right.z;
   31|  2.70M|		return *this;
   32|  2.70M|	}
  ------------------
  | _ZN8TVector3IfEaSERKS0_:
  |   27|  2.70M|	{
  |   28|  2.70M|		x = (TValue)right.x;
  |   29|  2.70M|		y = (TValue)right.y;
  |   30|  2.70M|		z = (TValue)right.z;
  |   31|  2.70M|		return *this;
  |   32|  2.70M|	}
  ------------------
  | Unexecuted instantiation: _ZN8TVector3IdEaSERKS0_
  ------------------
   33|       |
   34|       |	inline TVector3<TValue> operator + (const TVector3<TValue> &right)
   35|       |	{
   36|       |		return TVector3(x + (TValue)right.x, y + (TValue)right.y, z + (TValue)right.z);
   37|       |	}
   38|       |
   39|       |	inline TVector3<TValue> operator - (const TVector3<TValue> &right)
   40|      0|	{
   41|      0|		return TVector3<TValue>(x - (TValue)right.x, y - (TValue)right.y, z - (TValue)right.z);
   42|      0|	}
  ------------------
  | Unexecuted instantiation: _ZN8TVector3IfEmiERKS0_
  ------------------
  | Unexecuted instantiation: _ZN8TVector3IdEmiERKS0_
  ------------------
   43|       |
   44|       |	inline TVector3<TValue> operator * (const TValue s)
   45|       |	{
   46|       |		return TVector3<TValue>(x*s, y*s, z*s);
   47|       |	}
   48|       |
   49|       |	// dot product
   50|       |	template <class S>
   51|       |	inline TValue operator * (const TVector3<S> &right)
   52|      0|	{
   53|      0|		return (x*(TValue)right.x + y*(TValue)right.y + z*(TValue)right.z);
   54|      0|	}
   55|       |
   56|       |	inline TVector3<TValue>  operator / (const TValue s)
   57|       |	{
   58|       |		return s ? TVector3<TValue>(x/s, y/s, z/s) : TVector3<TValue>(0, 0, 0);
   59|       |	}
   60|       |
   61|       |	template <class S>
   62|       |	inline TVector3<TValue> &operator += (const TVector3<S> &right)
   63|      0|	{
   64|      0|		x+=(TValue)right.x;
   65|      0|		y+=(TValue)right.y;
   66|      0|		z+=(TValue)right.z;
   67|      0|		return *this;
   68|      0|	}
   69|       |
   70|       |	inline TVector3<TValue> &operator += (const TValue xyz)
   71|       |	{
   72|       |		x += xyz;
   73|       |		y += xyz;
   74|       |		z += xyz;
   75|       |		return *this;
   76|       |	}
   77|       |
   78|       |	template <class S>
   79|       |	inline TVector3<TValue> &operator -= (const TVector3<S> &right)
   80|       |	{
   81|       |		x-=(TValue)right.x;
   82|       |		y-=(TValue)right.y;
   83|       |		z-=(TValue)right.z;
   84|       |		return *this;
   85|       |	}
   86|       |
   87|       |	inline TVector3<TValue> &operator -= (const TValue xyz)
   88|       |	{
   89|       |		x -= xyz;
   90|       |		y -= xyz;
   91|       |		z -= xyz;
   92|       |		return *this;
   93|       |	}
   94|       |
   95|       |	inline TVector3<TValue> &operator *= (const TValue s) 
   96|       |	{
   97|       |		x*=s;
   98|       |		y*=s;
   99|       |		z*=s;
  100|       |		return *this;
  101|       |	}
  102|       |
  103|       |	inline TVector3<TValue> &operator /= (const TValue s)
  104|       |	{
  105|       |		if (s) 
  106|       |		{
  107|       |			TValue t = 1./s;
  108|       |			x*=t;
  109|       |			y*=t;
  110|       |			z*=t;
  111|       |		}
  112|       |		return *this;
  113|       |	}
  114|       |
  115|       |	template <class S>
  116|       |	bool operator == (const TVector3<S> &right)
  117|       |	{ return (x == right.x && y == right.y && z == right.z); }
  118|       |
  119|       |	template <class S>
  120|       |	bool operator != (const TVector3<S> &right)
  121|       |	{ return !(x == right.x && y == right.y && z == right.z); }
  122|       |
  123|       |	inline operator const TValue*() const { return &x; }
  124|       |	inline operator TValue*() { return &x; }
  125|       |	inline const TValue operator[](int i) const { return ((TValue*)&x)[i]; }
  126|      0|	inline TValue &operator[](int i) { return ((TValue*)&x)[i]; }
  127|       |
  128|       |	//
  129|       |	// Set
  130|       |	//
  131|       |
  132|       |	inline void Set(const TValue _x, const TValue _y, const TValue _z)
  133|  91.6k|	{ x = _x; y = _y; z = _z; }
  ------------------
  | _ZN8TVector3IfE3SetEfff:
  |  133|  91.6k|	{ x = _x; y = _y; z = _z; }
  ------------------
  | Unexecuted instantiation: _ZN8TVector3IdE3SetEddd
  ------------------
  134|       |
  135|       |	inline void Set(const TValue xyz)
  136|       |	{ x = y = z = xyz; }
  137|       |
  138|       |	template <class S>
  139|       |	inline void Set(const TVector3<S> & t)
  140|       |	{ x = t.x; y = t.y; z = t.z; }
  141|       |
  142|       |	//
  143|       |	// Utils
  144|       |	//
  145|       |
  146|       |	inline void Clamp(TValue min, TValue max)
  147|       |	{
  148|       |		x = (x > max)? max : (x < min)? min : x;
  149|       |		y = (y > max)? max : (y < min)? min : y;
  150|       |		z = (z > max)? max : (z < min)? min : z;
  151|       |	}
  152|       |
  153|       |	inline TVector3<TValue> &Normalize()
  154|      0|	{
  155|      0|		TValue l = getLength();
  156|       |
  157|      0|		if(!l)
  158|      0|		{
  159|      0|			Set(0,0,0);
  160|      0|		}
  161|      0|		else
  162|      0|		{
  163|      0|			TValue t = (TValue)(1.)/l;
  164|      0|			x*=t;
  165|      0|			y*=t;
  166|      0|			z*=t;
  167|      0|		}
  168|       |
  169|      0|		return *this;
  170|      0|	}
  171|       |
  172|       |	inline const TValue getLength2() const
  173|      0|	{
  174|      0|		return  x*x + y*y + z*z;
  175|      0|	}
  ------------------
  | Unexecuted instantiation: _ZNK8TVector3IfE10getLength2Ev
  ------------------
  | Unexecuted instantiation: _ZNK8TVector3IdE10getLength2Ev
  ------------------
  176|       |
  177|       |	inline const TValue getLength() const
  178|      0|	{
  179|      0|		return sqrt(getLength2());
  180|      0|	}
  ------------------
  | Unexecuted instantiation: _ZNK8TVector3IfE9getLengthEv
  ------------------
  | Unexecuted instantiation: _ZNK8TVector3IdE9getLengthEv
  ------------------
  181|       |
  182|       |	template <class S>
  183|       |	inline const TValue DotProduct(const TVector3<S> &t) const
  184|       |	{
  185|       |		return x*t.x + y*t.y + z*t.z;
  186|       |	}
  187|       |
  188|       |	template <class S>
  189|       |	static inline TValue DotProduct(const TVector3<S> &u, const TVector3<S> &v)
  190|       |	{
  191|       |		return u.x*v.x + u.y*v.y + u.z*v.z;
  192|       |	}
  193|       |
  194|       |	template <class S>
  195|       |	inline TVector3<TValue> operator ^(const TVector3<S> &t)
  196|       |	{
  197|       |		return TVector3<TValue>(
  198|       |					y   * t.z  -  z   * t.y,
  199|       |					t.x * z    -  t.z * x,
  200|       |					x   * t.y  -  y   * t.x
  201|       |					);
  202|       |	}  
  203|       |
  204|       |	template <class S>
  205|       |	inline TVector3<TValue> &operator ^=(const TVector3<S> &t)
  206|       |	{
  207|       |		Set(
  208|       |			y   * t.z - z   * t.y,
  209|       |			t.x * z   - t.z * x,
  210|       |			x   * t.y - y   * t.x
  211|       |			);
  212|       |		return *this;
  213|       |	}
  214|       |
  215|       |	template <class S>
  216|       |	inline void CrossProduct(const TVector3<S> &t1, const TVector3<S> &t2)
  217|       |	{
  218|       |		x = t1.y * t2.z - t1.z * t2.y;
  219|       |		y = t1.z * t2.x - t1.x * t2.z;
  220|       |		z = t1.x * t2.y - t1.y * t2.x;
  221|       |	}
  222|       |
  223|       |	template <class S>
  224|       |	inline TVector3<TValue> CrossProduct(const TVector3<S> &p) const
  225|       |	{
  226|       |		const TValue val1 = y * p.z - z * p.y;
  227|       |		const TValue val2 = p.x * z - p.z * x;
  228|       |		const TValue val3 = x * p.y - y * p.x;
  229|       |		return TVector3<TValue>( val1, val2, val3 );
  230|       |	}
  231|       |
  232|       |	template <class S>
  233|       |	inline const TValue getDistance(const TVector3<S> &v2)  const 
  234|       |	{
  235|       |		return sqrt(
  236|       |				(v2.x - x) * (v2.x - x) +
  237|       |				(v2.y - y) * (v2.y - y) +
  238|       |				(v2.z - z) * (v2.z - z)
  239|       |				);
  240|       |	}
  241|       |
  242|       |	template <class S>
  243|       |	inline const TValue getAngle(const TVector3<S> &v2)  const 
  244|       |	{             
  245|       |		return acos( DotProduct(v2) / (getLength() * v2.getLength()));
  246|       |	}
  247|       |
  248|       |	inline TVector3<TValue> &clamp(TValue min, TValue max)
  249|       |	{
  250|       |		x = (x > max) ? max : (x < min) ? min  : x;
  251|       |		y = (y > max) ? max : (y < min) ? min  : y;
  252|       |		z = (z > max) ? max : (z < min) ? min  : z;
  253|       |		return *this;
  254|       |	}
  255|       |
  256|       |	template <class S>
  257|       |	TVector3<TValue> &Barycenter ( TVector3<S> v1, TVector3<S> v2, TVector3<S> v3)
  258|       |	{
  259|       |		x = (v1.x + v2.x + v3.x) / 3.0;
  260|       |		y = (v1.y + v2.y + v3.y) / 3.0;
  261|       |		z = (v1.z + v2.z + v3.z) / 3.0;
  262|       |		return *this;
  263|       |	}
  264|       |
  265|       |	//
  266|       |	// IOstream
  267|       |	//
  268|       |
  269|       |	friend ostream & operator << ( ostream & out, const TVector3<TValue> &right)
  270|       |	{
  271|       |		return out << "( " << right.x << " , " << right.y << " , " << right.z <<" )";
  272|       |	}
  273|       |
  274|       |	friend istream & operator >> (istream & in, TVector3<TValue> &right)
  275|       |	{
  276|       |		return in >> right.x >> right.y >> right.z;
  277|       |	}
  278|       |
  279|       |public:
  280|       |
  281|       |    TValue x, y, z;
  282|       |};
  283|       |
  284|       |typedef TVector3<int>		Vector3i;
  285|       |typedef TVector3<float>		Vector3f;
  286|       |typedef TVector3<double>	Vector3d;
  287|       |typedef TVector3<float>		Vector3;
  288|       |
  289|       |#endif	// __TVECTOR3_H__
  290|       |

/workspaces/cg/src/cgmath/aabox.cpp:
    1|       |#include <stdio.h>
    2|       |#include <assert.h>
    3|       |#include <iostream>
    4|       |
    5|       |#include "aabox.h"
    6|       |#include "geometry.h"
    7|       |
    8|       |void AABox::Dump (void)
    9|      0|{
   10|      0|	std::cout << parameters[0].x << " " << parameters[0].y << " " << parameters[0].z << std::endl;
   11|      0|	std::cout << parameters[1].x << " " << parameters[1].y << " " << parameters[1].z << std::endl;
   12|      0|}
   13|       |
   14|       |void AABox::AddVertex (float x, float y, float z)
   15|  6.42M|{
   16|  6.42M|	if (parameters[0].x > x)
   17|  2.46M|			parameters[0].x = x;
   18|  6.42M|	if (parameters[0].y > y)
   19|  2.27M|			parameters[0].y = y;
   20|  6.42M|	if (parameters[0].z > z)
   21|  2.25M|			parameters[0].z = z;
   22|       |
   23|  6.42M|	if (parameters[1].x < x)
   24|  2.88M|			parameters[1].x = x;
   25|  6.42M|	if (parameters[1].y < y)
   26|  3.23M|			parameters[1].y = y;
   27|  6.42M|	if (parameters[1].z < z)
   28|  2.77M|			parameters[1].z = z;
   29|  6.42M|}
   30|       |
   31|       |bool AABox::contains (float x, float y, float z) const
   32|  13.5k|{
   33|  13.5k|	return ((x >= parameters[0].x) && (x <= parameters[1].x) &&
   34|  13.5k|			(y >= parameters[0].y) && (y <= parameters[1].y) &&
   35|  13.5k|			(z >= parameters[0].z) && (z <= parameters[1].z));
   36|  13.5k|}
   37|       |
   38|       |/*
   39|       | * Ray-box intersection using IEEE numerical properties to ensure that the
   40|       | * test is both robust and efficient, as described in:
   41|       | *
   42|       | *      Amy Williams, Steve Barrus, R. Keith Morley, and Peter Shirley
   43|       | *      "An Efficient and Robust Ray-Box Intersection Algorithm"
   44|       | *      Journal of graphics tools, 10(1):49-54, 2005
   45|       | *
   46|       | */
   47|       |bool AABox::intersection (const Ray &r, float t0, float t1) const
   48|  1.24M|{
   49|  1.24M|	float tmin, tmax, tymin, tymax, tzmin, tzmax;
   50|       |
   51|  1.24M|	tmin = (parameters[r.sign[0]].x - r.origin.x) * r.inv_direction.x;
   52|  1.24M|	tmax = (parameters[1-r.sign[0]].x - r.origin.x) * r.inv_direction.x;
   53|  1.24M|	tymin = (parameters[r.sign[1]].y - r.origin.y) * r.inv_direction.y;
   54|  1.24M|	tymax = (parameters[1-r.sign[1]].y - r.origin.y) * r.inv_direction.y;
   55|  1.24M|	if ( (tmin > tymax) || (tymin > tmax) ) 
   56|   944k|		return false;
   57|   295k|	if (tymin > tmin)
   58|   289k|		tmin = tymin;
   59|   295k|	if (tymax < tmax)
   60|   266k|		tmax = tymax;
   61|   295k|	tzmin = (parameters[r.sign[2]].z - r.origin.z) * r.inv_direction.z;
   62|   295k|	tzmax = (parameters[1-r.sign[2]].z - r.origin.z) * r.inv_direction.z;
   63|   295k|	if ( (tmin > tzmax) || (tzmin > tmax) ) 
   64|   163k|		return false;
   65|   131k|	if (tzmin > tmin)
   66|  2.36k|		tmin = tzmin;
   67|   131k|	if (tzmax < tmax)
   68|  13.4k|		tmax = tzmax;
   69|   131k|	return ( (tmin < t1) && (tmax > t0) );
   70|   295k|}
   71|       |
   72|       |bool AABox::contains (const Triangle &tri) const
   73|  11.1k|{
   74|  11.1k|	return (contains(tri.m_v[0][0], tri.m_v[0][1], tri.m_v[0][2]) && 
   75|  11.1k|			contains(tri.m_v[1][0], tri.m_v[1][1], tri.m_v[1][2]) &&
   76|  11.1k|			contains(tri.m_v[2][0], tri.m_v[2][1], tri.m_v[2][2]));
   77|  11.1k|}
   78|       |
   79|       |//
   80|       |// References :
   81|       |// http://fileadmin.cs.lth.se/cs/Personal/Tomas_Akenine-Moller/pubs/tribox.pdf
   82|       |// http://fileadmin.cs.lth.se/cs/Personal/Tomas_Akenine-Moller/code/
   83|       |//
   84|  70.4k|#define X 0
   85|  84.6k|#define Y 1
   86|  95.5k|#define Z 2
   87|       |
   88|       |#define CROSS(dest,v1,v2) \
   89|    957|          dest[0]=v1[1]*v2[2]-v1[2]*v2[1]; \
   90|    957|          dest[1]=v1[2]*v2[0]-v1[0]*v2[2]; \
   91|    957|          dest[2]=v1[0]*v2[1]-v1[1]*v2[0]; 
   92|       |
   93|  1.91k|#define DOT(v1,v2) (v1[0]*v2[0]+v1[1]*v2[1]+v1[2]*v2[2])
   94|       |
   95|       |#define FINDMINMAX(x0,x1,x2,min,max) \
   96|  3.63k|  min = max = x0;   \
   97|  3.63k|  if(x1<min) min=x1;\
   98|  3.63k|  if(x1>max) max=x1;\
   99|  3.63k|  if(x2<min) min=x2;\
  100|  3.63k|  if(x2>max) max=x2;
  101|       |
  102|       |static int planeBoxOverlap(float normal[3], float vert[3], float maxbox[3])
  103|    957|{
  104|    957|  int q;
  105|    957|  float vmin[3],vmax[3],v;
  106|  3.82k|  for(q=X;q<=Z;q++)
  107|  2.87k|  {
  108|  2.87k|    v=vert[q];
  109|  2.87k|    if(normal[q]>0.0f)
  110|  1.21k|    {
  111|  1.21k|      vmin[q]=-maxbox[q] - v;
  112|  1.21k|      vmax[q]= maxbox[q] - v;
  113|  1.21k|    }
  114|  1.65k|    else
  115|  1.65k|    {
  116|  1.65k|      vmin[q]= maxbox[q] - v;
  117|  1.65k|      vmax[q]=-maxbox[q] - v;
  118|  1.65k|    }
  119|  2.87k|  }
  120|    957|  if(DOT(normal,vmin)>0.0f) return 0;
  121|    957|  if(DOT(normal,vmax)>=0.0f) return 1;
  122|       |  
  123|      0|  return 0;
  124|    957|}
  125|       |
  126|       |
  127|       |/*======================== X-tests ========================*/
  128|       |#define AXISTEST_X01(a, b, fa, fb)			   \
  129|  13.2k|	p0 = a*v0[Y] - b*v0[Z];			       	   \
  130|  13.2k|	p2 = a*v2[Y] - b*v2[Z];			       	   \
  131|  13.2k|        if(p0<p2) {min=p0; max=p2;} else {min=p2; max=p0;} \
  132|  13.2k|	rad = fa * boxhalfsize[Y] + fb * boxhalfsize[Z];   \
  133|  13.2k|	if(min>rad || max<-rad) return 0;
  134|       |
  135|       |#define AXISTEST_X2(a, b, fa, fb)			   \
  136|  1.79k|	p0 = a*v0[Y] - b*v0[Z];			           \
  137|  1.79k|	p1 = a*v1[Y] - b*v1[Z];			       	   \
  138|  1.79k|        if(p0<p1) {min=p0; max=p1;} else {min=p1; max=p0;} \
  139|  1.79k|	rad = fa * boxhalfsize[Y] + fb * boxhalfsize[Z];   \
  140|  1.79k|	if(min>rad || max<-rad) return 0;
  141|       |
  142|       |/*======================== Y-tests ========================*/
  143|       |#define AXISTEST_Y02(a, b, fa, fb)			   \
  144|  8.33k|	p0 = -a*v0[X] + b*v0[Z];		      	   \
  145|  8.33k|	p2 = -a*v2[X] + b*v2[Z];	       	       	   \
  146|  8.33k|        if(p0<p2) {min=p0; max=p2;} else {min=p2; max=p0;} \
  147|  8.33k|	rad = fa * boxhalfsize[X] + fb * boxhalfsize[Z];   \
  148|  8.33k|	if(min>rad || max<-rad) return 0;
  149|       |
  150|       |#define AXISTEST_Y1(a, b, fa, fb)			   \
  151|  1.53k|	p0 = -a*v0[X] + b*v0[Z];		      	   \
  152|  1.53k|	p1 = -a*v1[X] + b*v1[Z];	     	       	   \
  153|  1.53k|        if(p0<p1) {min=p0; max=p1;} else {min=p1; max=p0;} \
  154|  1.53k|	rad = fa * boxhalfsize[X] + fb * boxhalfsize[Z];   \
  155|  1.53k|	if(min>rad || max<-rad) return 0;
  156|       |
  157|       |/*======================== Z-tests ========================*/
  158|       |#define AXISTEST_Z12(a, b, fa, fb)			   \
  159|  5.44k|	p1 = a*v1[X] - b*v1[Y];			           \
  160|  5.44k|	p2 = a*v2[X] - b*v2[Y];			       	   \
  161|  5.44k|        if(p2<p1) {min=p2; max=p1;} else {min=p1; max=p2;} \
  162|  5.44k|	rad = fa * boxhalfsize[X] + fb * boxhalfsize[Y];   \
  163|  5.44k|	if(min>rad || max<-rad) return 0;
  164|       |
  165|       |#define AXISTEST_Z0(a, b, fa, fb)			   \
  166|  1.97k|	p0 = a*v0[X] - b*v0[Y];				   \
  167|  1.97k|	p1 = a*v1[X] - b*v1[Y];			           \
  168|  1.97k|        if(p0<p1) {min=p0; max=p1;} else {min=p1; max=p0;} \
  169|  1.97k|	rad = fa * boxhalfsize[X] + fb * boxhalfsize[Y];   \
  170|  1.97k|	if(min>rad || max<-rad) return 0;
  171|       |
  172|       |bool AABox::intersection (Triangle &tri) const
  173|  10.1k|{
  174|       |	//float boxcenter[3],float boxhalfsize[3],float triverts[3][3]
  175|       |
  176|       |  /*    use separating axis theorem to test overlap between triangle and box */
  177|       |  /*    need to test for overlap in these directions: */
  178|       |  /*    1) the {x,y,z}-directions (actually, since we use the AABB of the triangle */
  179|       |  /*       we do not even need to test these) */
  180|       |  /*    2) normal of the triangle */
  181|       |  /*    3) crossproduct(edge from tri, {x,y,z}-directin) */
  182|       |  /*       this gives 3x3=9 more tests */
  183|  10.1k|   vec3 v0,v1,v2;
  184|  10.1k|   float min,max,p0,p1,p2,rad,fex,fey,fez;
  185|  10.1k|   vec3 normal,e0,e1,e2;
  186|       |
  187|       |   // redefine the aabox
  188|  10.1k|   vec3 boxcenter, boxhalfsize;
  189|  10.1k|   vec3_init (boxcenter, .5*(parameters[0].x+parameters[1].x), .5*(parameters[0].y+parameters[1].y), .5*(parameters[0].z+parameters[1].z));
  190|  10.1k|   vec3_init (boxhalfsize, .5*(parameters[1].x-parameters[0].x), .5*(parameters[1].y-parameters[0].y), .5*(parameters[1].z-parameters[0].z));
  191|       |
  192|       |   /* This is the fastest branch on Sun */
  193|       |   /* move everything so that the boxcenter is in (0,0,0) */
  194|  10.1k|   vec3_subtraction (v0, tri.m_v[0], boxcenter);
  195|  10.1k|   vec3_subtraction (v1, tri.m_v[1], boxcenter);
  196|  10.1k|   vec3_subtraction (v2, tri.m_v[2], boxcenter);
  197|       |
  198|       |   /* compute triangle edges */
  199|  10.1k|   vec3_subtraction (e0,v1,v0);      /* tri edge 0 */
  200|  10.1k|   vec3_subtraction (e1,v2,v1);      /* tri edge 1 */
  201|  10.1k|   vec3_subtraction (e2,v0,v2);      /* tri edge 2 */
  202|       |
  203|       |   /* Bullet 3:  */
  204|       |   /*  test the 9 tests first (this was faster) */
  205|  10.1k|   fex = fabsf(e0[X]);
  206|  10.1k|   fey = fabsf(e0[Y]);
  207|  10.1k|   fez = fabsf(e0[Z]);
  208|  10.1k|   AXISTEST_X01(e0[Z], e0[Y], fez, fey);
  209|  6.01k|   AXISTEST_Y02(e0[Z], e0[X], fez, fex);
  210|  4.02k|   AXISTEST_Z12(e0[Y], e0[X], fey, fex);
  211|       |
  212|  3.04k|   fex = fabsf(e1[X]);
  213|  3.04k|   fey = fabsf(e1[Y]);
  214|  3.04k|   fez = fabsf(e1[Z]);
  215|  3.04k|   AXISTEST_X01(e1[Z], e1[Y], fez, fey);
  216|  2.32k|   AXISTEST_Y02(e1[Z], e1[X], fez, fex);
  217|  1.97k|   AXISTEST_Z0(e1[Y], e1[X], fey, fex);
  218|       |
  219|  1.79k|   fex = fabsf(e2[X]);
  220|  1.79k|   fey = fabsf(e2[Y]);
  221|  1.79k|   fez = fabsf(e2[Z]);
  222|  1.79k|   AXISTEST_X2(e2[Z], e2[Y], fez, fey);
  223|  1.53k|   AXISTEST_Y1(e2[Z], e2[X], fez, fex);
  224|  1.41k|   AXISTEST_Z12(e2[Y], e2[X], fey, fex);
  225|       |
  226|       |   /* Bullet 1: */
  227|       |   /*  first test overlap in the {x,y,z}-directions */
  228|       |   /*  find min, max of the triangle each direction, and test for overlap in */
  229|       |   /*  that direction -- this is equivalent to testing a minimal AABB around */
  230|       |   /*  the triangle against the AABB */
  231|       |
  232|       |   /* test in X-direction */
  233|  1.34k|   FINDMINMAX(v0[X],v1[X],v2[X],min,max);
  234|  1.34k|   if(min>boxhalfsize[X] || max<-boxhalfsize[X]) return false;
  235|       |
  236|       |   /* test in Y-direction */
  237|  1.22k|   FINDMINMAX(v0[Y],v1[Y],v2[Y],min,max);
  238|  1.22k|   if(min>boxhalfsize[Y] || max<-boxhalfsize[Y]) return false;
  239|       |
  240|       |   /* test in Z-direction */
  241|  1.06k|   FINDMINMAX(v0[Z],v1[Z],v2[Z],min,max);
  242|  1.06k|   if(min>boxhalfsize[Z] || max<-boxhalfsize[Z]) return false;
  243|       |
  244|       |   /* Bullet 2: */
  245|       |   /*  test if the box intersects the plane of the triangle */
  246|       |   /*  compute plane equation of triangle: normal*x+d=0 */
  247|    957|   CROSS(normal,e0,e1);
  248|    957|   if(!planeBoxOverlap(normal,v0,boxhalfsize)) return false;
  249|       |
  250|    957|   return true;
  251|    957|}
  252|       |

/workspaces/cg/src/cgmath/aabox.h:
    1|       |#pragma once
    2|       |
    3|       |#include "TVector3.h"
    4|       |#include "ray.h"
    5|       |class Triangle;
    6|       |
    7|       |class AABox {
    8|       |public:
    9|      0|	AABox() { AddVertex (0., 0., 0.); }
   10|  3.40M|	AABox(float x, float y, float z) {
   11|  3.40M|		parameters[0].x = x;
   12|  3.40M|		parameters[0].y = y;
   13|  3.40M|		parameters[0].z = z;
   14|       |
   15|  3.40M|		parameters[1].x = x;
   16|  3.40M|		parameters[1].y = y;
   17|  3.40M|		parameters[1].z = z;
   18|  3.40M|	}
   19|    161|	AABox(const Vector3 &min, const Vector3 &max) {
   20|    161|		parameters[0] = min;
   21|    161|		parameters[1] = max;
   22|    161|	}
   23|       |
   24|       |	void AddVertex (float x, float y, float z);
   25|       |	bool contains (float x, float y, float z) const;
   26|       |
   27|       |	void Dump (void);
   28|       |
   29|       |	bool intersection (const Ray &, float t0, float t1) const; // (t0, t1) is the interval for valid hits
   30|       |
   31|       |	// 
   32|       |	bool contains (const Triangle &) const;
   33|       |	bool intersection (Triangle &) const;
   34|       |	
   35|       |	// corners
   36|       |	Vector3 parameters[2];
   37|       |};

/workspaces/cg/src/cgmath/algebra_matrix3.cpp:
    1|       |#include "common.h"
    2|       |#include "algebra_matrix3.h"
    3|       |#include "algebra_quaternion.h"
    4|       |
    5|       |int mat3_init (mat3 m,
    6|       |	       float m00, float m01, float m02,
    7|       |	       float m10, float m11, float m12,
    8|       |	       float m20, float m21, float m22)
    9|      0|{
   10|      0|	m[0][0] = m00; m[0][1] = m01; m[0][2] = m02;
   11|      0|	m[1][0] = m10; m[1][1] = m11; m[1][2] = m12;
   12|      0|	m[2][0] = m20; m[2][1] = m21; m[2][2] = m22;
   13|      0|	return 0;
   14|      0|}
   15|       |
   16|       |int mat3_init_array (mat3 m, float *array)
   17|      0|{
   18|      0|	m[0][0] = array[0]; m[0][1] = array[1]; m[0][2] = array[2];
   19|      0|	m[1][0] = array[3]; m[1][1] = array[4]; m[1][2] = array[5];
   20|      0|	m[2][0] = array[6]; m[2][1] = array[7]; m[2][2] = array[8];
   21|       |
   22|      0|	return 1;
   23|      0|}
   24|       |
   25|       |int mat3_init_identity (mat3 m)
   26|      0|{
   27|      0|	for (unsigned int i=0; i<3; i++)
   28|      0|		for (unsigned int j=0; j<3; j++)
   29|      0|			m[i][j] = 0.;
   30|      0|	for (unsigned int i=0; i<3; i++)
   31|      0|		m[i][i] = 1.;
   32|      0|	return 0;
   33|      0|}
   34|       |
   35|       |void mat3_transpose(mat3 m)
   36|      0|{
   37|      0|	SWAP(m[0][1], m[1][0]);
   38|      0|	SWAP(m[0][2], m[2][0]);
   39|      0|	SWAP(m[1][2], m[2][1]);
   40|      0|}
   41|       |
   42|       |int mat3_init_rotation_from_vec3_to_vec3 (mat3 m, vec3 vDir1, vec3 vDir2)
   43|      0|{
   44|      0|	vec3_normalize (vDir1);
   45|      0|	vec3_normalize (vDir2);
   46|      0|	vec3 axis;
   47|      0|	vec3_cross_product (axis, vDir1, vDir2);
   48|      0|	if (fabs (vec3_length (axis)) < 1e-5)
   49|      0|	{
   50|      0|		mat3_init_identity (m);
   51|      0|		if (vec3_dot_product (vDir1, vDir2) == -1.0)
   52|      0|		{
   53|      0|			m[1][1] = -1.;
   54|      0|			m[2][2] = -1.;
   55|      0|		}
   56|      0|	}
   57|      0|	else
   58|      0|	{
   59|      0|		quaternion q;
   60|      0|		vec3_normalize (axis);
   61|      0|		float cosangle = vec3_dot_product (vDir1, vDir2);
   62|      0|		if (cosangle > 1.)
   63|      0|			cosangle = 1.;
   64|      0|		if (cosangle < -1.)
   65|      0|			cosangle = -1.;
   66|      0|		float angle = acos (cosangle);
   67|      0|		quaternion_init_axis_angle (q, axis, angle);
   68|      0|		quaternion_normalize (q);
   69|      0|		quaternion_convert_to_matrix3 (q, m);
   70|      0|	}
   71|      0|	return 0;
   72|      0|}
   73|       |
   74|       |//
   75|       |// Reference : http://www.flipcode.com/documents/matrfaq.html#Q36
   76|       |//
   77|       |int mat3_init_rotation_from_euler_angles (mat3 m, float rotx, float roty, float rotz)
   78|      1|{
   79|      1|    float A = cos(rotx);
   80|      1|    float B = sin(rotx);
   81|      1|    float C = cos(roty);
   82|      1|    float D = sin(roty);
   83|      1|    float E = cos(rotz);
   84|      1|    float F = sin(rotz);
   85|       |
   86|      1|    float AD = A * D;
   87|      1|    float BD = B * D;
   88|       |
   89|      1|    m[0][0] =  C * E;
   90|      1|    m[0][1] = -C * F;
   91|      1|    m[0][2] = -D;
   92|      1|    m[1][0] = -BD * E + A * F;
   93|      1|    m[1][1] =  BD * F + A * E;
   94|      1|    m[1][2] =  -B * C;
   95|      1|    m[2][0] =  AD * E + B * F;
   96|      1|    m[2][1] = -AD * F + B * E;
   97|      1|    m[2][2] =   A * C;
   98|       |
   99|      1|    return 0;
  100|      1|}					  
  101|       |
  102|       |void mat3_transform(vec3 r, mat3 m, vec3 v)
  103|  1.98k|{
  104|  1.98k|	vec3 t;
  105|       |
  106|  1.98k|	t[0] = m[0][0] * v[0] + m[0][1] * v[1] + m[0][2] * v[2];
  107|  1.98k|	t[1] = m[1][0] * v[0] + m[1][1] * v[1] + m[1][2] * v[2];
  108|  1.98k|	t[2] = m[2][0] * v[0] + m[2][1] * v[1] + m[2][2] * v[2];
  109|       |
  110|  1.98k|	memcpy(r, t, sizeof(vec3));
  111|  1.98k|}
  112|       |
  113|       |void mat3_dump (mat3 m)
  114|      0|{
  115|      0|	for (unsigned int i=0; i<3; i++)
  116|      0|	{
  117|      0|		for (unsigned int j=0; j<3; j++)
  118|      0|		{
  119|      0|			printf ("%.3f ", m[i][j]);
  120|      0|		}
  121|      0|		printf ("\n");
  122|      0|	}
  123|      0|}
  124|       |
  125|       |float mat3_determinant (mat3 m)
  126|      0|{
  127|      0|	return  m[0][0] * (m[1][1]*m[2][2] - m[2][1]*m[1][2]) -
  128|      0|		m[1][0] * (m[0][1]*m[2][2] - m[2][1]*m[0][2]) +
  129|      0|		m[2][0] * (m[0][1]*m[1][2] - m[1][1]*m[0][2]);
  130|      0|}
  131|       |
  132|       |int mat3_inverse (mat3 m)
  133|      0|{
  134|      0|	float fdet, finvdet;
  135|       |
  136|      0|	fdet = mat3_determinant(m);
  137|       |	
  138|      0|	if (fdet == 0.f)	//Impossible to inverse the matrix
  139|      0|		return -1;
  140|       |	
  141|       |	//To avoid multiple division
  142|      0|	finvdet = 1.f / fdet;
  143|       |
  144|      0|	mat3 tmp;
  145|      0|	tmp[0][0] = m[2][2]*m[1][1] - m[2][1]*m[1][2];
  146|      0|	tmp[0][1] = m[2][1]*m[0][2] - m[2][2]*m[0][1];
  147|      0|	tmp[0][2] = m[1][2]*m[0][1] - m[1][1]*m[0][2];
  148|      0|	tmp[1][0] = m[2][0]*m[1][2] - m[2][2]*m[1][0];
  149|      0|	tmp[1][1] = m[2][2]*m[0][0] - m[2][0]*m[0][2];
  150|      0|	tmp[1][2] = m[1][0]*m[0][2] - m[1][2]*m[0][0];
  151|      0|	tmp[2][0] = m[2][1]*m[1][0] - m[2][0]*m[1][1];
  152|      0|	tmp[2][1] = m[2][0]*m[0][1] - m[2][1]*m[0][0];
  153|      0|	tmp[2][2] = m[1][1]*m[0][0] - m[1][0]*m[0][1];
  154|       |	
  155|      0|	for (unsigned int i=0; i<3; i++)
  156|      0|		for (unsigned int j=0; j<3; j++)
  157|      0|			m[i][j] = tmp[i][j] * finvdet;
  158|       |
  159|      0|	return 0;
  160|      0|}
  161|       |
  162|       |void mat3_mul(mat3 r, mat3 a, mat3 b)
  163|      0|{
  164|      0|	int i, j;
  165|      0|	mat3 t;
  166|       |
  167|      0|	for (i = 0; i < 3; i++)
  168|      0|		for (j = 0; j < 3; j++) {
  169|      0|			t[i][j] = a[i][0] * b[0][j] +
  170|      0|				  a[i][1] * b[1][j] +
  171|      0|				  a[i][2] * b[2][j];
  172|      0|		}
  173|      0|	memcpy(r, t, sizeof(mat3));
  174|      0|}
  175|       |
  176|       |void mat3_scale(mat3 res, mat3 src, float s)
  177|      0|{
  178|      0|	int i,j;
  179|      0|	for (i = 0; i < 3; i++)
  180|      0|		for (j = 0; j < 3; j++)
  181|      0|				res[i][j] = s * src[i][j];
  182|      0|}
  183|       |
  184|       |int mat3_is_symmetric (mat3 m)
  185|      0|{
  186|      0|	if (m[0][1] == m[1][0] &&
  187|      0|	    m[0][2] == m[2][0] &&
  188|      0|	    m[1][2] == m[2][1] )
  189|      0|		return 1;
  190|      0|	else
  191|      0|		return 0;
  192|      0|}
  193|       |
  194|       |//
  195|       |//
  196|       |//
  197|       |static void mat3_tridiagonal (mat3 m, vec3 diag, vec3 subd)
  198|      0|{
  199|      0|  float fm00 = m[0][0];
  200|      0|  float fm01 = m[0][1];
  201|      0|  float fm02 = m[0][2];
  202|      0|  float fm11 = m[1][1];
  203|      0|  float fm12 = m[1][2];
  204|      0|  float fm22 = m[2][2];
  205|       |  
  206|      0|  diag[0] = fm00;
  207|      0|  subd[2] = 0.0;
  208|      0|  if (fm02 != 0.0)
  209|      0|  {
  210|      0|      float length = sqrt (fm01*fm01 + fm02*fm02);
  211|      0|      float invlength = 1.0 / length;
  212|      0|      float q;
  213|      0|      fm01 *= invlength;
  214|      0|      fm02 *= invlength;
  215|      0|      q = 2.0*fm01*fm12 + fm02*(fm22-fm11);
  216|      0|      diag[1] = fm11+fm02*q;
  217|      0|      diag[2] = fm22-fm02*q;
  218|      0|      subd[0] = length;
  219|      0|      subd[1] = fm12-fm01*q;
  220|      0|      mat3_init ( m,
  221|      0|		   1.0, 0.0, 0.0,
  222|      0|		   0.0, fm01, fm02,
  223|      0|		   0.0, fm02, -fm01 );
  224|      0|  }
  225|      0|  else
  226|      0|  {
  227|      0|      diag[1] = fm11;
  228|      0|      diag[2] = fm22;
  229|      0|      subd[0] = fm01;
  230|      0|      subd[1] = fm12;
  231|      0|      mat3_init_identity (m);
  232|      0|  }
  233|      0|}
  234|       |
  235|       |//
  236|       |//
  237|       |//
  238|       |static int mat3_QLalgorithm (mat3 m, vec3 diag, vec3 subd)
  239|      0|{
  240|      0|	int imaxiter = 32;
  241|      0|	int i0, i1=0, i2, i3, i4;
  242|       |	
  243|      0|	for (i0=0; i0<3; i0++)
  244|      0|	{
  245|      0|		float G, R;
  246|      0|		float sinus, cosinus, P;
  247|       |		
  248|      0|		for (i2=i0; i2<=1; i2++)
  249|      0|		{
  250|      0|			float tmp = fabs (diag[i2]) + fabs(diag[i2+1]);
  251|      0|			if (fabs(subd[i2])+tmp == tmp)
  252|      0|				break;
  253|      0|		}
  254|      0|		if (i2 == i0)
  255|      0|			break;
  256|       |		
  257|      0|		G = (diag[i0+1] - diag[i0]) / (2.0*subd[i0]);
  258|      0|		R = sqrt (G*G+1.0);
  259|      0|		if (G < 0.0)
  260|      0|			G = diag[i2] - diag[i0] + subd[i0] / (G - R);
  261|      0|		else
  262|      0|			G = diag[i2] - diag[i0] + subd[i0] / (G + R);
  263|       |		
  264|      0|		sinus = 1.0;
  265|      0|		cosinus = 1.0;
  266|      0|		P = 0.0;
  267|       |		
  268|      0|		for (i3=i2-1; i3>=i0; i3--)
  269|      0|		{
  270|      0|			float F = sinus*subd[i3];
  271|      0|			float B = cosinus*subd[i3];
  272|      0|			if (fabs(F) >= fabs(G))
  273|      0|			{
  274|      0|				cosinus = G/F;
  275|      0|				if (fabs(F) < 0.00001)
  276|      0|				     cosinus = -1.;
  277|      0|				R = sqrt(cosinus*cosinus + 1.0);
  278|      0|				subd[i3+1] = F*R;
  279|      0|				sinus = 1.0/R;
  280|      0|				cosinus *= sinus;
  281|      0|			}
  282|      0|			else
  283|      0|			{
  284|      0|				sinus = F/G;
  285|      0|				R = sqrt (sinus*sinus + 1.0);
  286|      0|				subd[i3+1]=G*R;
  287|      0|				cosinus = 1.0/R;
  288|      0|				sinus *= cosinus;
  289|      0|			}
  290|      0|			G = diag[i3+1] - P;
  291|      0|			R = (diag[i3] - G)*sinus + 2.0*B*cosinus;
  292|      0|			P = sinus*R;
  293|      0|			diag[i3+1] = G + P;
  294|      0|			G = cosinus*R - B;
  295|       |			
  296|      0|			for (i4=0; i4<3; i4++)
  297|      0|			{
  298|      0|				F = m[i4][i3+1];
  299|      0|				m[i4][i3+1] = sinus*m[i4][i3] + cosinus*F;
  300|      0|				m[i4][i3] = cosinus*m[i4][i3] - sinus*F;
  301|      0|			}
  302|      0|		}
  303|      0|		diag[i0] -= P;
  304|      0|		subd[i0] = G;
  305|      0|		subd[i2] = 0.0;
  306|      0|	}
  307|      0|	if (i1 == imaxiter)
  308|      0|		return -1;
  309|       |	
  310|      0|	return 0;
  311|      0|}
  312|       |
  313|       |//
  314|       |//
  315|       |//
  316|       |static void mat3_decreasingsort (mat3 m, vec3 diag)
  317|      0|{
  318|      0|  int i0, i1, i2;
  319|       |
  320|      0|  for (i0=0, i1; i0<=1; i0++)
  321|      0|    {
  322|      0|      float max;
  323|      0|      i1 = i0;
  324|      0|      max = diag[i1];
  325|      0|      for (i2=i0+1; i2<3; i2++)
  326|      0|	{
  327|      0|	  if (diag[i2] > max)
  328|      0|	    {
  329|      0|	      i1 = i2;
  330|      0|	      max = diag[i1];
  331|      0|	    }
  332|      0|	}
  333|       |      
  334|      0|      if (i1 != i0)
  335|      0|	{
  336|      0|	  diag[i1] = diag[i0];
  337|      0|	  diag[i0] = max;
  338|       |
  339|      0|	  for (i2=0; i2<3; i2++)
  340|      0|	    {
  341|      0|	      float tmp = m[i2][i0];
  342|      0|	      m[i2][i0] = m[i2][i1];
  343|      0|	      m[i2][i1] = tmp;
  344|      0|	    }
  345|      0|	}
  346|      0|    }
  347|      0|}
  348|       |
  349|       |//
  350|       |// Solve the eigensystem based on the matrix.
  351|       |//
  352|       |// The steps followed by the algorithm are :
  353|       |// tridiagonal, QLalgorithm, decreasingsort.
  354|       |//
  355|       |// returns 0 if the eigensystem is solved, -1 if the eigensystem can't be solved
  356|       |//
  357|       |// The vector evalues contains the 3 eigenvalues.
  358|       |// The eigenvectors associated to the eigenvalues are stored in the
  359|       |// vectors evector1, evector2 and evector3.
  360|       |//
  361|       |int mat3_solve_eigensystem (mat3 m,
  362|       |			     vec3 evalues,
  363|       |			     vec3 evector1,
  364|       |			     vec3 evector2,
  365|       |			     vec3 evector3)
  366|      0|{
  367|      0|	if (mat3_determinant(m) == 0.)
  368|      0|	{
  369|      0|		return -1;
  370|      0|	}
  371|       |	
  372|      0|	if (mat3_is_symmetric (m))
  373|      0|	{
  374|      0|		vec3 diag = {0.0, 0.0, 0.0};
  375|      0|		vec3 subd = {0.0, 0.0, 0.0};
  376|      0|		vec3_init (diag, 0., 0., 0.);
  377|      0|		vec3_init (subd, 0., 0., 0.);
  378|       |
  379|      0|		mat3_tridiagonal    (m, diag, subd);
  380|      0|		mat3_QLalgorithm    (m, diag, subd);
  381|      0|		mat3_decreasingsort (m, diag);
  382|       |		
  383|      0|		vec3_init (evector1, m[0][0], m[1][0], m[2][0]);
  384|      0|		vec3_init (evector2, m[0][1], m[1][1], m[2][1]);
  385|      0|		vec3_init (evector3, m[0][2], m[1][2], m[2][2]);
  386|      0|		vec3_init (evalues, diag[0], diag[1], diag[2]);
  387|      0|		return 0;
  388|      0|	}
  389|      0|	else
  390|      0|	{
  391|      0|		return -1;
  392|      0|	}
  393|      0|	return -1;
  394|      0|}
  395|       |
  396|       |
  397|       |//
  398|       |// solve a linear system based on the matrix m and the right element right
  399|       |// the result is given in res
  400|       |//
  401|       |// return :
  402|       |// 0 if ko
  403|       |// 1 if ok
  404|       |//
  405|       |int mat3_solve_linearsystem (mat3 m, vec3 right, vec3 res)
  406|      0|{
  407|      0|	float det = mat3_determinant(m);
  408|      0|	if (det == 0.0f)
  409|      0|		return 0;
  410|       |
  411|      0|	det = 1.0f / det;
  412|       |
  413|       |	// Cramer's rule
  414|      0|	mat3 tmp;
  415|      0|	mat3_init (tmp,
  416|      0|		    right[0], m[0][1], m[0][2],
  417|      0|		    right[1], m[1][1], m[1][2],
  418|      0|		    right[2], m[2][1], m[2][2]);
  419|      0|	float resultx = mat3_determinant(tmp) * det;
  420|       |	
  421|      0|	mat3_init (tmp,
  422|      0|		    m[0][0], right[0], m[0][2],
  423|      0|		    m[1][0], right[1], m[1][2],
  424|      0|		    m[2][0], right[2], m[2][2]);
  425|      0|	float resulty = mat3_determinant(tmp) * det;
  426|       |	
  427|      0|	mat3_init (tmp,
  428|      0|		    m[0][0], m[0][1], right[0],
  429|      0|		    m[1][0], m[1][1], right[1],
  430|      0|		    m[2][0], m[2][1], right[2]);
  431|      0|	float resultz = mat3_determinant(tmp) * det;
  432|       |	
  433|      0|	vec3_init (res, resultx, resulty, resultz);
  434|       |	
  435|      0|	return 1;
  436|      0|}

/workspaces/cg/src/cgmath/algebra_matrix3.h:
    1|       |#ifndef __ALGEBRA_MATRIC_H__
    2|       |#define __ALGEBRA_MATRIC_H__
    3|       |
    4|       |#include <string.h>
    5|       |
    6|       |#include "algebra_vector3.h"
    7|       |
    8|       |typedef float mat3[3][3];
    9|       |// fmat3[n][m] addresses the following elements :
   10|       |// n = row
   11|       |// m = column
   12|       |// ie
   13|       |// ( fmat3[0][0] fmat3[0][1] fmat3[0][2] )
   14|       |// ( fmat3[1][0] fmat3[1][1] fmat3[1][2] )
   15|       |// ( fmat3[2][0] mat3[2][1] mat3[2][2] )
   16|       |
   17|       |extern int mat3_init (mat3 m,
   18|       |		       float m00, float m01, float m02,
   19|       |		       float m10, float m11, float m12,
   20|       |		       float m20, float m21, float m22);
   21|       |extern int mat3_init_array (mat3 m, float *array);
   22|       |extern int mat3_init_identity (mat3 m);
   23|       |extern int mat3_init_rotation_from_vec3_to_vec3 (mat3 m, vec3 vDir1, vec3 vDir2);
   24|       |extern int mat3_init_rotation_from_euler_angles (mat3 m, float rotx, float roty, float rotz);
   25|       |
   26|       |extern void mat3_transform(vec3 r, mat3 m, vec3 v);
   27|       |
   28|       |
   29|       |extern void mat3_dump (mat3 m);
   30|       |
   31|       |extern void mat3_mul(mat3 r, mat3 a, mat3 b);
   32|       |extern void mat3_scale(mat3 res, mat3 src, float s);
   33|       |
   34|       |extern void mat3_transpose(mat3 m);
   35|       |
   36|       |static inline void mat3_copy(mat3 d, mat3 s)
   37|      0|{
   38|      0|	memcpy(d, s, sizeof(mat3));
   39|      0|}
  ------------------
  | Unexecuted instantiation: tu_cgimg_io.cpp:_ZL9mat3_copyPA3_fS0_
  ------------------
  | Unexecuted instantiation: tu_cgmesh_audio.cpp:_ZL9mat3_copyPA3_fS0_
  ------------------
  | Unexecuted instantiation: tu_cgmesh_io.cpp:_ZL9mat3_copyPA3_fS0_
  ------------------
  | Unexecuted instantiation: tu_cgmesh_raytracer.cpp:_ZL9mat3_copyPA3_fS0_
  ------------------
  | Unexecuted instantiation: tu_cgmesh_surface_basic.cpp:_ZL9mat3_copyPA3_fS0_
  ------------------
  | Unexecuted instantiation: algebra_matrix3.cpp:_ZL9mat3_copyPA3_fS0_
  ------------------
  | Unexecuted instantiation: algebra_quaternion.cpp:_ZL9mat3_copyPA3_fS0_
  ------------------
  | Unexecuted instantiation: image.cpp:_ZL9mat3_copyPA3_fS0_
  ------------------
  | Unexecuted instantiation: image_io.cpp:_ZL9mat3_copyPA3_fS0_
  ------------------
  | Unexecuted instantiation: image_io_bmp.cpp:_ZL9mat3_copyPA3_fS0_
  ------------------
  | Unexecuted instantiation: image_io_pnm.cpp:_ZL9mat3_copyPA3_fS0_
  ------------------
  | Unexecuted instantiation: image_io_tga.cpp:_ZL9mat3_copyPA3_fS0_
  ------------------
  | Unexecuted instantiation: audio_convert.cpp:_ZL9mat3_copyPA3_fS0_
  ------------------
  | Unexecuted instantiation: audio_io.cpp:_ZL9mat3_copyPA3_fS0_
  ------------------
  | Unexecuted instantiation: mesh.cpp:_ZL9mat3_copyPA3_fS0_
  ------------------
  | Unexecuted instantiation: mesh_half_edge.cpp:_ZL9mat3_copyPA3_fS0_
  ------------------
  | Unexecuted instantiation: mesh_io.cpp:_ZL9mat3_copyPA3_fS0_
  ------------------
  | Unexecuted instantiation: mesh_io_u3d.cpp:_ZL9mat3_copyPA3_fS0_
  ------------------
  | Unexecuted instantiation: mesh_transform.cpp:_ZL9mat3_copyPA3_fS0_
  ------------------
  | Unexecuted instantiation: object3D.cpp:_ZL9mat3_copyPA3_fS0_
  ------------------
  | Unexecuted instantiation: octree.cpp:_ZL9mat3_copyPA3_fS0_
  ------------------
  | Unexecuted instantiation: raytracer.cpp:_ZL9mat3_copyPA3_fS0_
  ------------------
  | Unexecuted instantiation: scene.cpp:_ZL9mat3_copyPA3_fS0_
  ------------------
  | Unexecuted instantiation: surface_basic.cpp:_ZL9mat3_copyPA3_fS0_
  ------------------
  | Unexecuted instantiation: material.cpp:_ZL9mat3_copyPA3_fS0_
  ------------------
   40|       |
   41|       |extern int mat3_inverse (mat3 m);
   42|       |extern int mat3_is_symmetric (mat3 m);
   43|       |extern float mat3_determinant (mat3 m);
   44|       |extern int mat3_solve_eigensystem (mat3 m,
   45|       |				    vec3 evalues,
   46|       |				    vec3 evector1,
   47|       |				    vec3 evector2,
   48|       |				    vec3 evector3);
   49|       |extern int mat3_solve_linearsystem (mat3 m, vec3 right, vec3 res);
   50|       |
   51|       |#endif // __ALGEBRA_MATRIC_H__

/workspaces/cg/src/cgmath/algebra_matrix4.cpp:
    1|       |#include <string.h>
    2|       |
    3|       |#include "algebra_matrix4.h"
    4|       |
    5|       |int mat4_init (mat4 m,
    6|       |		       float m00, float m01, float m02, float m03,
    7|       |		       float m10, float m11, float m12, float m13,
    8|       |		       float m20, float m21, float m22, float m23,
    9|       |		       float m30, float m31, float m32, float m33)
   10|      0|{
   11|      0|	m[0]  = m00; m[1]  = m01; m[2]  = m02; m[3]  = m03;
   12|      0|	m[4]  = m10; m[5]  = m11; m[6]  = m12; m[7]  = m13;
   13|      0|	m[8]  = m20; m[9]  = m21; m[10] = m22; m[11] = m23;
   14|      0|	m[12] = m30; m[13] = m31; m[14] = m32; m[15] = m33;
   15|       |
   16|      0|	return 1;
   17|      0|}
   18|       |
   19|       |int mat4_set_identity (float *m)
   20|      0|{
   21|      0|	memset (m, 0, 16*sizeof(float));
   22|      0|	m[0] = 1.;
   23|      0|	m[5] = 1.;
   24|      0|	m[10] = 1.;
   25|      0|	m[15] = 1.;
   26|       |
   27|      0|	return 1;
   28|      0|}
   29|       |
   30|       |int mat4_get_inverse (float *_dst, float *_src)
   31|      0|{
   32|      0|	int i,j;
   33|      0|	float tmp[12]; // temp array for pairs
   34|      0|	float src[16]; // array of transpose source matrix
   35|      0|	float dst[16];
   36|      0|	float det;     // determinant
   37|       |
   38|      0|	float tmp2[16];
   39|      0|	for (int i=0; i<16; i++)
   40|      0|		tmp2[i] = _src[i];
   41|       |
   42|       |	// transpose matrix
   43|      0|	for (i = 0; i < 4; i++)
   44|      0|	{
   45|      0|		src[i]      = tmp2[i*4];
   46|      0|		src[i + 4]  = tmp2[i*4 + 1];
   47|      0|		src[i + 8]  = tmp2[i*4 + 2];
   48|      0|		src[i + 12] = tmp2[i*4 + 3];
   49|      0|	}
   50|       |
   51|       |	// calculate pairs for first 8 elements (cofactors)
   52|      0|	tmp[0]  = src[10] * src[15];
   53|      0|	tmp[1]  = src[11] * src[14];
   54|      0|	tmp[2]  = src[9]  * src[15];
   55|      0|	tmp[3]  = src[11] * src[13];
   56|      0|	tmp[4]  = src[9]  * src[14];
   57|      0|	tmp[5]  = src[10] * src[13];
   58|      0|	tmp[6]  = src[8]  * src[15];
   59|      0|	tmp[7]  = src[11] * src[12];
   60|      0|	tmp[8]  = src[8]  * src[14];
   61|      0|	tmp[9]  = src[10] * src[12];
   62|      0|	tmp[10] = src[8]  * src[13];
   63|      0|	tmp[11] = src[9]  * src[12];
   64|       |
   65|       |	// calculate first 8 elements (cofactors)
   66|      0|	dst[0] =  tmp[0]*src[5] + tmp[3]*src[6] + tmp[4]*src[7];
   67|      0|	dst[0] -= tmp[1]*src[5] + tmp[2]*src[6] + tmp[5]*src[7];
   68|      0|	dst[1] =  tmp[1]*src[4] + tmp[6]*src[6] + tmp[9]*src[7];
   69|      0|	dst[1] -= tmp[0]*src[4] + tmp[7]*src[6] + tmp[8]*src[7];
   70|      0|	dst[2] =  tmp[2]*src[4] + tmp[7]*src[5] + tmp[10]*src[7];
   71|      0|	dst[2] -= tmp[3]*src[4] + tmp[6]*src[5] + tmp[11]*src[7];
   72|      0|	dst[3] =  tmp[5]*src[4] + tmp[8]*src[5] + tmp[11]*src[6];
   73|      0|	dst[3] -= tmp[4]*src[4] + tmp[9]*src[5] + tmp[10]*src[6];
   74|      0|	dst[4] =  tmp[1]*src[1] + tmp[2]*src[2] + tmp[5]*src[3];
   75|      0|	dst[4] -= tmp[0]*src[1] + tmp[3]*src[2] + tmp[4]*src[3];
   76|      0|	dst[5] =  tmp[0]*src[0] + tmp[7]*src[2] + tmp[8]*src[3];
   77|      0|	dst[5] -= tmp[1]*src[0] + tmp[6]*src[2] + tmp[9]*src[3];
   78|      0|	dst[6] =  tmp[3]*src[0] + tmp[6]*src[1] + tmp[11]*src[3];
   79|      0|	dst[6] -= tmp[2]*src[0] + tmp[7]*src[1] + tmp[10]*src[3];
   80|      0|	dst[7] =  tmp[4]*src[0] + tmp[9]*src[1] + tmp[10]*src[2];
   81|      0|	dst[7] -= tmp[5]*src[0] + tmp[8]*src[1] + tmp[11]*src[2];
   82|       |
   83|       |	// calculate pairs for second 8 elements (cofactors)
   84|      0|	tmp[0] = src[2]*src[7];
   85|      0|	tmp[1] = src[3]*src[6];
   86|      0|	tmp[2] = src[1]*src[7];
   87|      0|	tmp[3] = src[3]*src[5];
   88|      0|	tmp[4] = src[1]*src[6];
   89|      0|	tmp[5] = src[2]*src[5];
   90|      0|	tmp[6] = src[0]*src[7];
   91|      0|	tmp[7] = src[3]*src[4];
   92|      0|	tmp[8] = src[0]*src[6];
   93|      0|	tmp[9] = src[2]*src[4];
   94|      0|	tmp[10] = src[0]*src[5];
   95|      0|	tmp[11] = src[1]*src[4];
   96|       |
   97|       |	// calculate second 8 elements (cofactors)
   98|      0|	dst[8] = tmp[0]*src[13] + tmp[3]*src[14] + tmp[4]*src[15];
   99|      0|	dst[8] -= tmp[1]*src[13] + tmp[2]*src[14] + tmp[5]*src[15];
  100|      0|	dst[9] = tmp[1]*src[12] + tmp[6]*src[14] + tmp[9]*src[15];
  101|      0|	dst[9] -= tmp[0]*src[12] + tmp[7]*src[14] + tmp[8]*src[15];
  102|      0|	dst[10] = tmp[2]*src[12] + tmp[7]*src[13] + tmp[10]*src[15];
  103|      0|	dst[10]-= tmp[3]*src[12] + tmp[6]*src[13] + tmp[11]*src[15];
  104|      0|	dst[11] = tmp[5]*src[12] + tmp[8]*src[13] + tmp[11]*src[14];
  105|      0|	dst[11]-= tmp[4]*src[12] + tmp[9]*src[13] + tmp[10]*src[14];
  106|      0|	dst[12] = tmp[2]*src[10] + tmp[5]*src[11] + tmp[1]*src[9];
  107|      0|	dst[12]-= tmp[4]*src[11] + tmp[0]*src[9] + tmp[3]*src[10];
  108|      0|	dst[13] = tmp[8]*src[11] + tmp[0]*src[8] + tmp[7]*src[10];
  109|      0|	dst[13]-= tmp[6]*src[10] + tmp[9]*src[11] + tmp[1]*src[8];
  110|      0|	dst[14] = tmp[6]*src[9] + tmp[11]*src[11] + tmp[3]*src[8];
  111|      0|	dst[14]-= tmp[10]*src[11] + tmp[2]*src[8] + tmp[7]*src[9];
  112|      0|	dst[15] = tmp[10]*src[10] + tmp[4]*src[8] + tmp[9]*src[9];
  113|      0|	dst[15]-= tmp[8]*src[9] + tmp[11]*src[10] + tmp[5]*src[8];
  114|       |
  115|       |	// calculate determinant
  116|      0|	det=src[0]*dst[0]+src[1]*dst[1]+src[2]*dst[2]+src[3]*dst[3];
  117|      0|	if (det == 0.0)
  118|      0|		return 0;
  119|       |
  120|       |	// calculate matrix inverse
  121|      0|	det = 1/det;
  122|      0|	for (j = 0; j < 16; j++)
  123|      0|		_dst[j] = dst[j] * det;
  124|       |	
  125|      0|	return 1;
  126|      0|}
  127|       |
  128|       |int mat4_transform (float *dst, float *m, float *v)
  129|      0|{
  130|      0|	float t[4];
  131|      0|	t[0] = m[0] * v[0] + m[1] * v[1] + m[2] * v[2];// + m[3];
  132|      0|	t[1] = m[4] * v[0] + m[5] * v[1] + m[6] * v[2];// + m[7];
  133|      0|	t[2] = m[8] * v[0] + m[9] * v[1] + m[10] * v[2];// + m[11];
  134|      0|	t[3] = m[12] * v[0] + m[13] * v[1] + m[14] * v[2] + m[15];
  135|       |
  136|      0|	dst[0] = t[0] / t[3];
  137|      0|	dst[1] = t[1] / t[3];
  138|      0|	dst[2] = t[2] / t[3];
  139|       |
  140|      0|	return 1;
  141|      0|}

/workspaces/cg/src/cgmath/algebra_quaternion.cpp:
    1|       |#include "algebra_quaternion.h"
    2|       |
    3|       |void quaternion_init (quaternion q, float w, float x, float y, float z)
    4|      0|{
    5|      0|	if (q == NULL)
    6|      0|		return;
    7|       |
    8|      0|	q[0] = x;
    9|      0|	q[1] = y;
   10|      0|	q[2] = z;
   11|      0|	q[3] = w;
   12|      0|}
   13|       |
   14|       |void quaternion_init_axis_angle (quaternion q, vec3 axis, float angle)
   15|      0|{
   16|      0|	if (q == NULL)
   17|      0|		return;
   18|       |
   19|      0|	float sin_a = sin (angle / 2.);
   20|      0|	float cos_a = cos (angle / 2.);
   21|       |
   22|      0|	vec3_normalize (axis);
   23|      0|	q[0] = axis[0] * sin_a;
   24|      0|	q[1] = axis[1] * sin_a;
   25|      0|	q[2] = axis[2] * sin_a;
   26|      0|	q[3] = cos_a;
   27|      0|}
   28|       |
   29|       |
   30|       |int quaternion_init_matrix3 (quaternion q, mat3 m)
   31|      0|{
   32|      0|	float trace = 1.0 + m[0][0] + m[1][1] + m[2][2];
   33|      0|	if (trace > 0.)
   34|      0|	{
   35|      0|		float s = 0.5/sqrt(trace);
   36|      0|		q[3] = 0.25 / s;
   37|      0|		q[0] = (m[2][1] - m[1][2]) * s;
   38|      0|		q[1] = (m[0][2] - m[2][0]) * s;
   39|      0|		q[2] = (m[1][0] - m[0][1]) * s;
   40|      0|	}
   41|      0|	else
   42|      0|	{
   43|      0|		if (m[0][0] > m[1][1] && m[0][0] > m[2][2]) // m[0][0]
   44|      0|		{
   45|      0|			float s = sqrt( 1.0 + m[0][0] - m[1][1] - m[2][2] ) * 2.;
   46|       |			
   47|      0|			q[0] = 0.5 / s;
   48|      0|			q[1] = (m[0][1] + m[1][0] ) / s;
   49|      0|			q[2] = (m[0][2] + m[2][0] ) / s;
   50|      0|			q[3] = (m[1][2] + m[2][1] ) / s;
   51|      0|		}
   52|      0|		else if (m[1][1] > m[2][2]) // m[1][1]
   53|      0|		{
   54|      0|			float s = sqrt( 1.0 + m[1][1] - m[0][0] - m[2][2] ) * 2.;
   55|       |			
   56|      0|			q[0] = (m[0][1] + m[1][0] ) / s;
   57|      0|			q[1] = 0.5 / s;
   58|      0|			q[2] = (m[1][2] + m[2][1] ) / s;
   59|      0|			q[3] = (m[0][2] + m[2][0] ) / s;
   60|      0|		}
   61|      0|		else // m[2][2]
   62|      0|		{
   63|      0|			float s = sqrt( 1.0 + m[2][2] - m[0][0] - m[1][1] ) * 2.;
   64|       |			
   65|      0|			q[0] = (m[0][2] + m[2][0] ) / s;
   66|      0|			q[1] = (m[1][2] + m[2][1] ) / s;
   67|      0|			q[2] = 0.5 / s;
   68|      0|			q[3] = (m[0][1] + m[1][0] ) / s;
   69|      0|		}
   70|      0|	}
   71|       |	
   72|      0|	quaternion_normalize (q);
   73|      0|	return 1;
   74|      0|}
   75|       |
   76|       |//
   77|       |// Spherical Linear intERPolation
   78|       |// SLERP (p,q,t,theta) = ( p sin((1-t)theta)+q sin(t theta) ) / sin (theta)
   79|       |// Reference : http://en.wikipedia.org/wiki/Slerp
   80|       |//
   81|       |int quaternion_init_slerp (quaternion res, quaternion p, quaternion q, float t)
   82|      0|{
   83|       |	// clamp the t parameter
   84|      0|	if (t < 0.) t = 0.;
   85|      0|	if (t > 1.) t = 1.;
   86|       |	
   87|       |	// calculate the angle between the two rotations
   88|      0|	float costheta = p[3] * q[3] + p[0] * q[0] + p[1] * q[1] + p[2] * q[2];
   89|      0|	if (costheta >= 1.)
   90|      0|		costheta = 1.;
   91|      0|	if (costheta < -1.)
   92|      0|		costheta = -1.;
   93|      0|	float theta = acos(costheta);
   94|       |	
   95|       |	// if theta = 0 then return q
   96|      0|	if (fabs(theta) < 0.00001)
   97|      0|	{
   98|      0|		quaternion_init (res, p[3], p[0], p[1], p[2]);
   99|      0|		return 1;
  100|      0|	}
  101|       |	
  102|       |	// calculate temporary values.
  103|      0|	float sinTheta = sqrt(1.0 - costheta*costheta);
  104|       |
  105|       |	// if theta*2 = 180 degrees then result is undefined
  106|      0|	if (fabs(sinTheta) < 0.0001)
  107|      0|	{
  108|      0|		quaternion_init (res,
  109|      0|				 (p[3] * 0.5 + q[3] * 0.5),
  110|      0|				 (p[0] * 0.5 + q[0] * 0.5),
  111|      0|				 (p[1] * 0.5 + q[1] * 0.5),
  112|      0|				 (p[2] * 0.5 + q[2] * 0.5) );
  113|      0|		return 1;
  114|      0|	}
  115|      0|	float ratioA = sin((1 - t) * theta) / sinTheta;
  116|      0|	float ratioB = sin(t * theta) / sinTheta;
  117|       |	
  118|       |	// calculate the interpolated rotation
  119|      0|	quaternion_init (res,
  120|      0|			 (p[3] * ratioA + q[3] * ratioB),
  121|      0|			 (p[0] * ratioA + q[0] * ratioB),
  122|      0|			 (p[1] * ratioA + q[1] * ratioB),
  123|      0|			 (p[2] * ratioA + q[2] * ratioB) );
  124|      0|	return 1;
  125|      0|}
  126|       |
  127|       |void quaternion_copy (quaternion copy, quaternion source)
  128|      0|{
  129|      0|	if (!copy || !source)
  130|      0|		return;
  131|       |
  132|      0|	copy[3] = source[3];
  133|      0|	copy[0] = source[0];
  134|      0|	copy[1] = source[1];
  135|      0|	copy[2] = source[2];
  136|      0|}
  137|       |
  138|       |float quaternion_norm (quaternion q)
  139|      0|{
  140|      0|	if (q == NULL)
  141|      0|		return -1.;
  142|       |
  143|      0|	return sqrt(q[0]*q[0] + q[1] *q[1] + q[2]*q[2] + q[3]*q[3]);
  144|      0|}
  145|       |
  146|       |int quaternion_normalize (quaternion q)
  147|      0|{
  148|      0|	if (q == NULL)
  149|      0|		return -1;
  150|       |
  151|      0|	float norm = quaternion_norm (q);
  152|      0|	if (norm == 0.)
  153|      0|		return 0;
  154|       |
  155|      0|	q[0] /= norm;
  156|      0|	q[1] /= norm;
  157|      0|	q[2] /= norm;
  158|      0|	q[3] /= norm;
  159|       |
  160|      0|	return 1;
  161|      0|}
  162|       |
  163|       |void quaternion_convert_to_matrix3 (quaternion q, mat3 M)
  164|      0|{
  165|      0|        float n, s;
  166|      0|        float xs, ys, zs;
  167|      0|        float wx, wy, wz;
  168|      0|        float xx, xy, xz;
  169|      0|        float yy, yz, zz;
  170|       |
  171|       |	// compute rotation matrix
  172|      0|        n = (q[0] * q[0]) + (q[1] * q[1]) + (q[2] * q[2]) + (q[3] * q[3]);
  173|      0|        s = (n > 0.0f) ? (2.0f / n) : 0.0f;
  174|       |
  175|      0|        xs = q[0] * s;
  176|      0|        ys = q[1] * s;
  177|      0|        zs = q[2] * s;
  178|      0|        wx = q[3] * xs;
  179|      0|        wy = q[3] * ys;
  180|      0|        wz = q[3] * zs;
  181|      0|        xx = q[0] * xs;
  182|      0|        xy = q[0] * ys;
  183|      0|        xz = q[0] * zs;
  184|      0|        yy = q[1] * ys;
  185|      0|        yz = q[1] * zs;
  186|      0|        zz = q[2] * zs;
  187|       |	
  188|      0|        M[0][0] = 1.0f - (yy + zz);
  189|      0|        M[1][0] = xy + wz;
  190|      0|        M[2][0] = xz - wy;
  191|       |	       
  192|      0|        M[0][1] = xy - wz;
  193|      0|        M[1][1] = 1.0f - (xx + zz);
  194|      0|        M[2][1] = yz + wx;
  195|       |	       
  196|      0|        M[0][2] = xz + wy;
  197|      0|        M[1][2] = yz - wx;
  198|      0|        M[2][2] = 1.0f - (xx + yy);
  199|      0|}
  200|       |
  201|       |void quaternion_dump (quaternion q)
  202|      0|{
  203|      0|	printf ("quaternion : %f %f %f %f", q[0], q[1], q[2], q[3]);
  204|      0|}
  205|       |
  206|       |int  quaternion_rotate (quaternion q, vec3 res, vec3 orig)
  207|      0|{
  208|      0|	quaternion qtmp;
  209|      0|	quaternion_init (qtmp, orig[0], orig[1], orig[2], 0.0);
  210|      0|	quaternion quat_pt_rotated;
  211|      0|	printf ("[quaternion_rotate] TODO\n");
  212|       |	//quat_pt_rotated = *this * qtmp * GetInverse();
  213|      0|	vec3_copy (res, quat_pt_rotated);
  214|       |
  215|      0|	return 0;
  216|      0|}
  217|       |

/workspaces/cg/src/cgmath/algebra_vector2.h:
    1|       |#ifndef __ALGEBRA_VECTOR2_H__
    2|       |#define __ALGEBRA_VECTOR2_H__
    3|       |
    4|       |#include <stdio.h>
    5|       |#include <math.h>
    6|       |
    7|       |typedef float vec2[2];
    8|       |
    9|       |inline void vec2_init (vec2 v, float x, float y)
   10|      0|{
   11|      0|	v[0] = x;
   12|      0|	v[1] = y;
   13|      0|}
   14|       |
   15|       |inline void vec2_copy (vec2 res, vec2 u)
   16|      0|{
   17|      0|	res[0] = u[0];
   18|      0|	res[1] = u[1];
   19|      0|}
   20|       |
   21|       |inline float vec2_length (vec2 v)
   22|      0|{
   23|      0|	return sqrtf (v[0]*v[0] + v[1]*v[1]);
   24|      0|}
   25|       |
   26|       |inline float vec2_length2 (vec2 v)
   27|      0|{
   28|      0|	return (v[0]*v[0] + v[1]*v[1]);
   29|      0|}
   30|       |
   31|       |inline void vec2_subtraction (vec2 res, vec2 v1, vec2 v2)
   32|      0|{
   33|      0|	res[0] = v1[0] - v2[0];
   34|      0|	res[1] = v1[1] - v2[1];
   35|      0|}
   36|       |
   37|       |inline void vec2_addition (vec2 res, vec2 v1, vec2 v2)
   38|      0|{
   39|      0|	res[0] = v1[0] + v2[0];
   40|      0|	res[1] = v1[1] + v2[1];
   41|      0|}
   42|       |
   43|       |inline void vec2_scalar (vec2 res, vec2 v1, float s)
   44|      0|{
   45|      0|	res[0] = s*v1[0];
   46|      0|	res[1] = s*v1[1];
   47|      0|}
   48|       |
   49|       |inline float vec2_distance (vec2 v1, vec2 v2)
   50|      0|{
   51|      0|	vec2 v1v2;
   52|      0|	vec2_subtraction (v1v2, v2, v1);
   53|      0|	return vec2_length (v1v2);
   54|      0|}
   55|       |
   56|       |inline float vec2_dot_product (vec2 u, vec2 v)
   57|      0|{
   58|      0|	return (u[0]*v[0] + u[1]*v[1]);
   59|      0|}
   60|       |
   61|       |inline void vec2_normalize (vec2 v)
   62|      0|{
   63|      0|	float l = vec2_length (v);
   64|      0|	if (l == 0.) return;
   65|      0|	v[0] /= l;
   66|      0|	v[1] /= l;
   67|      0|}
   68|       |
   69|       |inline void vec2_dump (vec2 v)
   70|      0|{
   71|      0|	printf ("vec2 : %f %f\n", v[0], v[1]);
   72|      0|}
   73|       |
   74|       |// 2d segment
   75|       |typedef struct seg2
   76|       |{
   77|       |	vec2 vs;
   78|       |	vec2 ve;
   79|       |} seg2;
   80|       |
   81|       |#endif // __ALGEBRA_VECTOR2_H__

/workspaces/cg/src/cgmath/algebra_vector3.cpp:
    1|       |#include "algebra_vector3.h"
    2|       |
    3|       |void vec3_triangle_normal (vec3 n, vec3 v1, vec3 v2, vec3 v3)
    4|      0|{
    5|      0|	double ux, uy, uz;
    6|      0|	double vx, vy, vz;
    7|      0|	double nx, ny, nz;
    8|      0|	nx = ny = nz = 0.0f;
    9|       |
   10|      0|	ux = v2[0] - v1[0];
   11|      0|	uy = v2[1] - v1[1];
   12|      0|	uz = v2[2] - v1[2];
   13|       |	
   14|      0|	vx = v3[0] - v1[0];
   15|      0|	vy = v3[1] - v1[1];
   16|      0|	vz = v3[2] - v1[2];
   17|       |
   18|      0|	nx = (uy * vz) - (uz * vy);
   19|      0|	ny = (uz * vx) - (ux * vz);
   20|      0|	nz = (ux * vy) - (uy * vx);
   21|       |
   22|      0|	vec3_init (n, (float)nx, (float)ny, (float)nz);
   23|       |	
   24|      0|	return;
   25|      0|	vec3 v1v2, v1v3;
   26|      0|	vec3_subtraction (v1v2, v2, v1);
   27|      0|	vec3_subtraction (v1v3, v3, v1);
   28|      0|	vec3_cross_product (n, v1v2, v1v3);
   29|      0|}

/workspaces/cg/src/cgmath/algebra_vector3.h:
    1|       |#ifndef __ALGEBRA_VECTOR3_H__
    2|       |#define __ALGEBRA_VECTOR3_H__
    3|       |
    4|       |#include <stdio.h>
    5|       |#include <math.h>
    6|       |
    7|       |#include "common.h"
    8|       |
    9|       |//
   10|       |//
   11|       |//
   12|       |typedef float vec3[3];
   13|       |
   14|       |inline void vec3_init (vec3 v, float x, float y, float z)
   15|  10.7M|{
   16|  10.7M|	v[0] = x;
   17|  10.7M|	v[1] = y;
   18|  10.7M|	v[2] = z;
   19|  10.7M|}
   20|       |inline void vec3_copy (vec3 res, vec3 u)
   21|  70.8k|{
   22|  70.8k|	res[0] = u[0];
   23|  70.8k|	res[1] = u[1];
   24|  70.8k|	res[2] = u[2];
   25|  70.8k|}
   26|       |inline void vec3_subtraction (vec3 res, vec3 u, vec3 v)
   27|  10.5M|{
   28|  10.5M|	res[0] = u[0] - v[0];
   29|  10.5M|	res[1] = u[1] - v[1];
   30|  10.5M|	res[2] = u[2] - v[2];
   31|  10.5M|}
   32|       |inline void vec3_addition (vec3 res, vec3 u, vec3 v)
   33|      0|{
   34|      0|	res[0] = u[0] + v[0];
   35|      0|	res[1] = u[1] + v[1];
   36|      0|	res[2] = u[2] + v[2];
   37|      0|}
   38|       |inline void vec3_cross_product (vec3 res, vec3 u, vec3 v)
   39|  3.02M|{
   40|  3.02M|	res[0] = u[1]*v[2] - u[2]*v[1];
   41|  3.02M|	res[1] = u[2]*v[0] - u[0]*v[2];
   42|  3.02M|	res[2] = u[0]*v[1] - u[1]*v[0];
   43|  3.02M|}
   44|       |inline void vec3_scale (vec3 res, vec3 v, float s)
   45|      0|{
   46|      0|	res[0] = s * v[0];
   47|      0|	res[1] = s * v[1];
   48|      0|	res[2] = s * v[2];
   49|      0|}
   50|       |inline float vec3_dot_product (vec3 u, vec3 v)
   51|  19.6M|{
   52|  19.6M|	return (u[0]*v[0] + u[1]*v[1] + u[2]*v[2]);
   53|  19.6M|}
   54|       |inline float vec3_length (vec3 v)
   55|  6.18M|{
   56|  6.18M|	return sqrt (vec3_dot_product(v, v));
   57|  6.18M|}
   58|       |inline float vec3_length2 (vec3 v)
   59|      0|{
   60|      0|	return vec3_dot_product(v, v);
   61|      0|}
   62|       |extern void vec3_triangle_normal (vec3 n, vec3 v1, vec3 v2, vec3 v3);
   63|       |inline void vec3_barycenter (vec3 b, vec3 v1, vec3 v2, vec3 v3)
   64|      0|{
   65|      0|	vec3_init (b,
   66|      0|		   (v1[0]+v2[0]+v3[0])/3.,
   67|      0|		   (v1[1]+v2[1]+v3[1])/3.,
   68|      0|		   (v1[2]+v2[2]+v3[2])/3.);
   69|      0|}
   70|       |inline float vec3_triangle_area (vec3 v1, vec3 v2, vec3 v3)
   71|      0|{
   72|      0|	vec3 n;
   73|      0|	vec3_triangle_normal (n, v1, v2, v3);
   74|      0|	return .5*vec3_length (n);
   75|      0|}
   76|       |inline void vec3_normalize (vec3 v)
   77|  3.16M|{
   78|  3.16M|	float l = vec3_length (v);
   79|  3.16M|	if (l == 0.) return;
   80|  3.16M|	v[0] /= l;
   81|  3.16M|	v[1] /= l;
   82|  3.16M|	v[2] /= l;
   83|  3.16M|}
   84|       |inline float vec3_distance (vec3 v1, vec3 v2)
   85|      0|{
   86|      0|	vec3 v1v2;
   87|      0|	vec3_subtraction (v1v2, v2, v1);
   88|      0|	return vec3_length (v1v2);
   89|      0|}
   90|       |inline float vec3_distance2 (vec3 v1, vec3 v2)
   91|      0|{
   92|      0|	vec3 v1v2;
   93|      0|	vec3_subtraction (v1v2, v2, v1);
   94|      0|	return vec3_length2 (v1v2);
   95|      0|}
   96|       |inline void vec3_dump (vec3 v)
   97|      0|{
   98|      0|	printf ("vec3 : %f %f %f\n", v[0], v[1], v[2]);
   99|      0|}
  100|       |
  101|       |#endif // __ALGEBRA_VECTOR3_H__

/workspaces/cg/src/cgmath/algebra_vector4.h:
    1|       |#ifndef __ALGEBRA_PLANE_H__
    2|       |#define __ALGEBRA_PLANE_H__
    3|       |
    4|       |#include "algebra_vector3.h"
    5|       |
    6|       |typedef float vec4[4];
    7|       |
    8|       |inline void vec4_init (vec4 v, float x, float y, float z, float w)
    9|      0|{
   10|      0|	v[0] = x;
   11|      0|	v[1] = y;
   12|      0|	v[2] = z;
   13|      0|	v[3] = w;
   14|      0|}
   15|       |
   16|       |extern void plane_init(vec4 plane, vec3 v1, vec3 v2, vec3 v3);
   17|       |
   18|       |#endif // __ALGEBRA_PLANE_H__

/workspaces/cg/src/cgmath/berstein.cpp:
    1|       |#include "berstein.h"
    2|       |
    3|       |// factorials until 20!
    4|       |//long factorials[21] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800,
    5|       |//					39916800, 479001600, 6227020800, 87178291200, 1307674368000, 20922789888000, 355687428096000,
    6|       |//					6402373705728000, 121645100408832000, 2432902008176640000};
    7|       |long factorials[11] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800};
    8|       |
    9|       |/**
   10|       |* factorial
   11|       |*/
   12|       |double
   13|       |factorial (unsigned int n)
   14|      0|{
   15|      0|	return (n >= 21)? (factorial(n) * factorial(n-1)) : factorials[n];
   16|      0|}
   17|       |
   18|       |// binomial coefficient (n,k) with n>=k. If n<k, the coefficient is invalid => returns -1.0
   19|       |static int binomialCoefficients[21][21] = {{1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
   20|       |{1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
   21|       |{1, 2, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
   22|       |{1, 3, 3, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
   23|       |{1, 4, 6, 4, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
   24|       |{1, 5, 10, 10, 5, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
   25|       |{1, 6, 15, 20, 15, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
   26|       |{1, 7, 21, 35, 35, 21, 7, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
   27|       |{1, 8, 28, 56, 70, 56, 28, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
   28|       |{1, 9, 36, 84, 126, 126, 84, 36, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
   29|       |{1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
   30|       |{1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
   31|       |{1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1, -1, -1, -1, -1, -1, -1,-1, -1},
   32|       |{1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1, -1, -1, -1, -1, -1, -1, -1},
   33|       |{1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1, -1, -1, -1, -1, -1, -1},
   34|       |{1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1, -1, -1, -1, -1, -1},
   35|       |{1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1, -1, -1, -1, -1},
   36|       |{1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1, -1, -1, -1},
   37|       |{1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1, -1, -1},
   38|       |{1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1, -1},
   39|       |{1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1}};
   40|       |
   41|       |/**
   42|       |* binomial coefficient
   43|       |*/
   44|       |int binomialCoefficient (int n, int k)
   45|      0|{
   46|      0|	return binomialCoefficients[n][k];
   47|       |	//return (factorial(n) / (factorial(k) * factorial(n-k)));
   48|      0|}
   49|       |
   50|       |/**
   51|       |* Berstein polynomial
   52|       |*/
   53|       |double bersteinPolynomial (int par_maxDegree, int par_degree, float par_value)
   54|      0|{
   55|      0|	return binomialCoefficient (par_maxDegree, par_degree) * pow (par_value, par_degree) * pow (1-par_value,par_maxDegree-par_degree);
   56|      0|}
   57|       |

/workspaces/cg/src/cgmath/common.cpp:
    1|       |#include <stdio.h>
    2|       |#include <stdlib.h>
    3|       |
    4|       |#include "common.h"
    5|       |
    6|       |float search_max (float *array, int n)
    7|      0|{
    8|      0|	float max = array[0];
    9|      0|	for (int i=1; i<n; i++)
   10|      0|		if (max < array[i])
   11|      0|			max = array[i];
   12|      0|	return max;
   13|      0|}
   14|       |
   15|       |float search_min (float *array, int n)
   16|      0|{
   17|      0|	float min = array[0];
   18|      0|	for (int i=1; i<n; i++)
   19|      0|		if (min > array[i])
   20|      0|			min = array[i];
   21|      0|	return min;
   22|      0|}
   23|       |
   24|       |void convolution (float *signal, int n, float **_convolution)
   25|      0|{
   26|      0|	float *convolution = (float*)malloc(n*sizeof(float));
   27|       |
   28|      0|	for (int i=0; i<n; i++)
   29|      0|	{
   30|      0|		convolution[i] = 0.;
   31|      0|		for (int j=0; j<n; j++)
   32|      0|			convolution[i] += signal[j]*signal[(j+i)%n];
   33|      0|	}
   34|       |
   35|      0|	*_convolution = convolution;
   36|      0|}
   37|       |
   38|       |
   39|       |float
   40|       |smoothstep (float a, float b, float x)
   41|      0|{
   42|      0|  if (x<a)
   43|      0|    return 0.0;
   44|      0|  if (x>b)
   45|      0|    return 1.0;
   46|      0|  x = (x-a) / (b-a);
   47|      0|  return (x*x*(3-2*x));
   48|      0|}
   49|       |
   50|       |float
   51|       |interpolation_linear (float a, float b, float x)
   52|      0|{
   53|      0|  return a*(1.0-x) + b*x;
   54|      0|}
   55|       |
   56|       |float
   57|       |interpolation_cosine (float a, float b, float x)
   58|      0|{
   59|      0|  float w = x*3.1415927;
   60|      0|  float t = (1.0 - cos(w))*0.5;
   61|      0|  return a*(1.0 - t) + b*t;
   62|      0|}
   63|       |
   64|       |float
   65|       |interpolation_cubic (float a, float b, float c, float d, float x)
   66|      0|{
   67|      0|  float p = (d-c) - (a-b);
   68|      0|  float q = (a-b) - p;
   69|      0|  float r = c-a;
   70|      0|  float s = b;
   71|      0|  return p*x*x*x + q*x*x + r*x + s;
   72|      0|}
   73|       |
   74|       |//
   75|       |// filters
   76|       |//
   77|       |
   78|       |// http://www.scicos.org/ScicosModNum/modnum_web/src/modnum_422/interf/scicos/help/eng/htm/RCF_c.htm
   79|       |float filter_raised_cosine_filter (float T, float alpha, float x)
   80|      0|{
   81|      0|	float fabsx = fabs(x);
   82|      0|	if (fabsx < (1.-alpha)/(2.*T))
   83|      0|		return 1.;
   84|      0|	else if (fabsx >= (1.-alpha)/(2.*T) && fabsx <= (1.+alpha)/(2.*T))
   85|      0|		return 0.5 * (1. + cos ((M_PI*T/alpha)*(x-(1.-alpha)/(2*T))));
   86|      0|	else // if (fabsx > (1.+alpha)/(2.*T))
   87|      0|		return 0.;
   88|       |	
   89|      0|}
   90|       |
   91|       |// output
   92|       |void output_1array (float *signal, int size, char *filename)
   93|      0|{
   94|      0|  FILE *ptr = fopen (filename, "w");
   95|      0|  for (int i=0; i<size; i++)
   96|      0|    fprintf (ptr, "%f\n", signal[i]);
   97|      0|  fclose (ptr);
   98|      0|}
   99|       |
  100|       |void output_2array (float *signal1, float *signal2, int size, char *filename)
  101|      0|{
  102|      0|  FILE *ptr = fopen (filename, "w");
  103|      0|  for (int i=0; i<size; i++)
  104|      0|    fprintf (ptr, "%f %f\n", signal1[i], signal2[i]);
  105|      0|  fclose (ptr);
  106|      0|}
  107|       |
  108|       |// sort
  109|       |static void _quicksort_indices_aux (float *array, int *indices, int l, int r)
  110|      0|{
  111|      0|  float pivot;
  112|      0|  int ulo, uhi;
  113|      0|  int ieq;
  114|      0|  float temp;
  115|      0|  int temp2;
  116|       |
  117|      0|  if (l >= r) return;
  118|      0|  pivot = array[(l+r)/2];
  119|      0|  ieq = ulo = l;
  120|      0|  uhi = r;
  121|       |  
  122|      0|  while (ulo <= uhi)
  123|      0|    {
  124|      0|      if (array[uhi] > pivot) uhi--;
  125|      0|      else
  126|      0|	{
  127|       |	  /* swap array */
  128|      0|	  temp = array[ulo];
  129|      0|	  array[ulo] = array[uhi];
  130|      0|	  array[uhi] = temp;
  131|       |	  /* swap indices */
  132|      0|	  temp2 = indices[ulo];
  133|      0|	  indices[ulo] = indices[uhi];
  134|      0|	  indices[uhi] = temp2;
  135|       |
  136|      0|	  if (array[ulo] < pivot)
  137|      0|	    {
  138|       |	      /* swap array */
  139|      0|	      temp = array[ieq];
  140|      0|	      array[ieq] = array[ulo];
  141|      0|	      array[ulo] = temp;
  142|       |	      /* swap indices */
  143|      0|	      temp2 = indices[ieq];
  144|      0|	      indices[ieq] = indices[ulo];
  145|      0|	      indices[ulo] = temp2;
  146|       |
  147|      0|	      ieq++;
  148|      0|	    }
  149|      0|	  ulo++;
  150|      0|	}
  151|      0|    }
  152|      0|  _quicksort_indices_aux (array, indices, l, ieq-1);
  153|      0|  _quicksort_indices_aux (array, indices, uhi+1, r);
  154|      0|}      
  155|       |
  156|       |int*
  157|       |quicksort_indices (float *array, int size)
  158|      0|{
  159|      0|  int i;
  160|      0|  int *indices = (int*)malloc(size*sizeof(int));
  161|      0|  if (!indices) return NULL;
  162|      0|  for (i=0; i<size; i++)
  163|      0|    indices[i] = i;
  164|       |
  165|      0|  float *array_copy = (float*)malloc(size*sizeof(float));
  166|      0|  if (!array_copy) return NULL;
  167|      0|  for (i=0; i<size; i++)
  168|      0|    array_copy[i] = array[i];
  169|       |  /*
  170|       |  printf ("before\n");
  171|       |  for (int i=0; i<size; i++)
  172|       |    printf ("%d -> %d -> %f\n", i, indices[i], array[i]);
  173|       |  */
  174|      0|  _quicksort_indices_aux (array_copy, indices, 0, size-1);
  175|       |  /*
  176|       |  printf ("after\n");
  177|       |  for (int i=0; i<size; i++)
  178|       |    printf ("%d -> %d -> %f\n", i, indices[i], array[i]);
  179|       |  */
  180|      0|  return indices;
  181|      0|}
  182|       |
  183|       |void
  184|       |sort (int *array, int n)
  185|      0|{
  186|      0|  for (int j=n-1; j>0; j--)
  187|      0|    for (int i=0; i<j; i++)
  188|      0|      if (array[i+1] < array[i])
  189|      0|	{
  190|      0|	  int tmp = array[i+1];
  191|      0|	  array[i+1] = array[i];
  192|      0|	  array[i] = tmp;
  193|      0|	}
  194|      0|}
  195|       |
  196|       |void
  197|       |sort_2arrays (float *array1, float *array2, int n)
  198|      0|{
  199|      0|  float tmp;
  200|      0|  for (int j=n-1; j>0; j--)
  201|      0|    for (int i=0; i<j; i++)
  202|      0|      if (array1[i+1] < array1[i])
  203|      0|	{
  204|      0|	  tmp = array1[i+1];
  205|      0|	  array1[i+1] = array1[i];
  206|      0|	  array1[i] = tmp;
  207|       |
  208|      0|	  tmp = array2[i+1];
  209|      0|	  array2[i+1] = array2[i];
  210|      0|	  array2[i] = tmp;
  211|      0|	}
  212|      0|}
  213|       |
  214|       |
  215|       |IDGenerator *IDGenerator::m_pInstance = new IDGenerator;

/workspaces/cg/src/cgmath/common.h:
    1|       |#ifndef __COMMON_H__
    2|       |#define __COMMON_H__
    3|       |
    4|       |#include <stdlib.h>
    5|       |#include <math.h>
    6|       |#include <float.h>
    7|       |
    8|       |#ifdef _MSC_VER
    9|       |
   10|       |#pragma warning (disable : 4244) // disable : "conversion from 'double' to 'float', possible loss of data
   11|       |#pragma warning (disable : 4305) // disable : "truncation from 'double' to 'float'
   12|       |#pragma warning (disable : 4530) // disable : "C++ exception handler used"
   13|       |
   14|       |#endif // _MSC_VER
   15|       |
   16|       |
   17|       |// Constants rounded for 21 decimals
   18|       |#ifndef M_E
   19|       |#define M_E 2.71828182845904523536
   20|       |#endif // M_E
   21|       |
   22|       |#ifndef M_LOG2E
   23|       |#define M_LOG2E 1.44269504088896340736
   24|       |#endif // M_LOG2E
   25|       |
   26|       |#ifndef M_LOG10E
   27|       |#define M_LOG10E 0.434294481903251827651
   28|       |#endif // M_LOG10E
   29|       |
   30|       |#ifndef M_LN2
   31|       |#define M_LN2 0.693147180559945309417
   32|       |#endif // M_LN2
   33|       |
   34|       |#define M_LN10 2.30258509299404568402
   35|       |#ifndef M_PI
   36|       |#define M_PI 3.14159265358979323846
   37|       |#endif // M_PI
   38|       |#define M_PI_2 1.57079632679489661923
   39|       |
   40|       |#ifndef M_PI_4
   41|       |#define M_PI_4 0.785398163397448309616
   42|       |#endif // M_PI_4
   43|       |
   44|       |#ifndef M_1_PI
   45|       |#define M_1_PI 0.318309886183790671538
   46|       |#endif // M_1_PI
   47|       |
   48|       |#ifndef M_2_PI
   49|       |#define M_2_PI 0.636619772367581343076
   50|       |#endif // M_2_PI
   51|       |
   52|       |#define M_1_SQRTPI 0.564189583547756286948
   53|       |#define M_2_SQRTPI 1.12837916709551257390
   54|       |#define M_SQRT2 1.41421356237309504880
   55|       |#define M_SQRT_2 0.707106781186547524401
   56|       |
   57|       |#define DEGTORAD(x) ((x)*M_PI/180.)
   58|       |#define RADTODEG(x) ((x)*180./M_PI)
   59|       |
   60|       |#ifndef DBL_EPSILON
   61|       |#define DBL_EPSILON 2.2204460492503131e-16
   62|       |#endif
   63|       |#ifndef FLT_EPSILON
   64|       |#define FLT_EPSILON 1.1920928955078125e-07
   65|       |#endif
   66|       |#define EPSILON FLT_EPSILON
   67|       |
   68|       |/* standard macros */
   69|       |#ifndef ABS
   70|       |#define ABS(a) (((a) < 0) ? -(a) : (a))
   71|       |#endif
   72|       |#ifndef MIN
   73|  8.32k|#define MIN(a, b)  (((a) < (b)) ? (a) : (b))
   74|       |#endif
   75|       |#ifndef MAX
   76|  8.32k|#define MAX(a, b)  (((a) > (b)) ? (a) : (b))
   77|       |#endif
   78|       |#ifndef MIN3
   79|  4.16k|#define MIN3(a, b, c)  (MIN (MIN( (a) , (b) ) , (c) ))
   80|       |#endif
   81|       |#ifndef MAX3
   82|  4.16k|#define MAX3(a, b, c)  (MAX (MAX( (a) , (b) ) , (c) ))
   83|       |#endif
   84|       |
   85|       |#define CLAMP(x, low, high)  (((x) > (high)) ? (high) : (((x) < (low)) ? (low) : (x)))
   86|       |
   87|       |#ifdef WIN32
   88|       |#define SWAP(a, b) do { decltype(a) __tmp = a; a = b; b = __tmp; } while(0)
   89|       |#else
   90|      0|#define SWAP(a, b) do { __typeof__(a) __tmp = a; a = b; b = __tmp; } while(0)
   91|       |#endif
   92|       |
   93|       |#define SAFE_DELETE(pointer)       if ((pointer) != NULL) { delete (pointer);    (pointer) = NULL; }
   94|       |#define SAFE_ARRAY_DELETE(pointer) if ((pointer) != NULL) { delete [] (pointer); (pointer) = NULL; }
   95|       |#define SAFE_FREE(pointer)         if ((pointer) != NULL) { free (pointer);      (pointer) = NULL; }
   96|       |
   97|       |
   98|       |#ifdef _DEBUG
   99|       |#define DASSERT(x) assert(x)
  100|       |#define DPRINTF(x) printf(x)
  101|       |#else
  102|       |#define DASSERT(x)
  103|       |#define DPRINTF(x)
  104|       |#endif
  105|       |
  106|       |static inline int sign(float number)
  107|      0|{
  108|      0|	if (number > 0.0f)
  109|      0|		return 1;
  110|      0|	if (number < 0.0f)
  111|      0|		return -1;
  112|      0|	else
  113|      0|		return 0;
  114|      0|}
  ------------------
  | Unexecuted instantiation: tu_cgimg_io.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: tu_cgmath_aabox.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: tu_cgmath_algebra_vector3.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: tu_cgmath_triangle.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: tu_cgmesh_audio.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: tu_cgmesh_io.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: tu_cgmesh_raytracer.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: tu_cgmesh_surface_basic.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: aabox.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: algebra_matrix3.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: algebra_quaternion.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: geometry.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: plane.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: image.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: image_io.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: image_io_bmp.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: image_io_pnm.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: image_io_tga.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: palette.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: color.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: audio_convert.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: audio_io.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: mesh.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: mesh_half_edge.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: mesh_io.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: mesh_io_u3d.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: mesh_transform.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: object3D.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: octree.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: raytracer.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: scene.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: surface_basic.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: material.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: algebra_vector3.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: common.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: curve_bezier.cpp:_ZL4signf
  ------------------
  | Unexecuted instantiation: random_generator.cpp:_ZL4signf
  ------------------
  115|       |
  116|       |// interpolations
  117|       |extern float smoothstep (float a, float b, float x);
  118|       |
  119|       |extern float interpolation_linear (float a, float b, float x);
  120|       |extern float interpolation_cosine (float a, float b, float x);
  121|       |extern float interpolation_cubic  (float a, float b, float c, float d, float x);
  122|       |
  123|       |// filters
  124|       |extern float filter_raised_cosine_filter (float T, float alpha, float x);
  125|       |
  126|       |// output
  127|       |extern void output_1array (float *signal, int size, char *filename);
  128|       |extern void output_2array (float *signal1, float *signal2, int size, char *filename);
  129|       |
  130|       |// sort
  131|       |extern int* quicksort_indices (float *array, int size);
  132|       |
  133|       |extern void sort (int *array, int n);
  134|       |
  135|       |// sort array1 and update array2
  136|       |extern void sort_2arrays (float *array1, float *array2, int n);
  137|       |
  138|       |float search_min (float *array, int n);
  139|       |float search_max (float *array, int n);
  140|       |void convolution (float *signal, int n, float **_convolution);
  141|       |
  142|       |// compute 1/sqrt(x) using SSE instructions for efficiency
  143|       |// from Nick nicolas@capens.net
  144|       |inline float rsq (float x)
  145|      0|{
  146|      0|#ifdef SSE
  147|      0|	__asm
  148|      0|	{
  149|      0|		movss xmm0, x
  150|      0|		rsqrtss xmm0, xmm0
  151|      0|		movss x, xmm0
  152|      0|	}
  153|      0|	return x;
  154|      0|#else
  155|      0|	return 1.0f / sqrt (x);
  156|      0|#endif
  157|      0|}
  158|       |
  159|       |// unique IDs generator (singleton)
  160|       |class IDGenerator
  161|       |{
  162|       |private:
  163|      1|	IDGenerator () : m_iCurrentId(0) {};
  164|      0|	~IDGenerator () {};
  165|       |public:
  166|      0|	static IDGenerator* getInstance (void) { return m_pInstance; }
  167|       |
  168|      0|	unsigned int newId (void) { return m_iCurrentId++; };
  169|       |private:
  170|       |	unsigned int m_iCurrentId;
  171|       |	static IDGenerator *m_pInstance;
  172|       |};
  173|       |
  174|       |#ifdef _MSC_VER
  175|       |
  176|       |//const double infmyreal = std::numeric_limits<double>::infinity();
  177|       |//const double nanmyreal = std::numeric_limits<double>::quiet_NaN();
  178|       |
  179|       |//const double inf = (std::numeric_limits<double>::infinity());
  180|       |//const double nan = (std::numeric_limits<double>::quiet_NaN());
  181|       |//const double NAN = (std::numeric_limits<double>::quiet_NaN());
  182|       |
  183|       |#ifndef INFINITY
  184|       |#define INFINITY numeric_limits<float>::infinity()
  185|       |#endif // INFINITY
  186|       |
  187|       |#ifdef WIN32
  188|       |    #ifndef NAN
  189|       |        static const unsigned long __nan[2] = {0xffffffff, 0x7fffffff};
  190|       |        #define NAN (*(const float *) __nan)
  191|       |    #endif
  192|       |#endif
  193|       |
  194|       |#define isnan(x) ((x) != (x))
  195|       |
  196|       |#else
  197|       |
  198|       |// On linux, the std constants are incorrect, so we have
  199|       |// to trick the compiler into producing inf and nan without
  200|       |// producing a compile-time warning. Since sin (0.0) = 0.0,
  201|       |// dividing byt it hides the divide by zero at compile time
  202|       |// but procudes the correct constants.
  203|       |
  204|       |/*
  205|       |const double infmyreal = 1.0 / sin (0.0);
  206|       |const double nanmyreal = 0.0 / sin (0.0);
  207|       |const double inf = 1.0 / sin (0.0);
  208|       |const double nan = 0.0 / sin (0.0);
  209|       |*/
  210|       |
  211|       |#endif // _MSC_VER
  212|       |
  213|       |#endif // __COMMON_H__

/workspaces/cg/src/cgmath/curve.h:
    1|       |#ifndef __CURVE_H__
    2|       |#define __CURVE_H__
    3|       |
    4|       |class Curve
    5|       |{
    6|       |public:
    7|      0|	Curve () {};
    8|      0|	virtual ~Curve () {};
    9|       |
   10|       |	// To be defined
   11|       |	virtual void GetPosition (float t, float p[3]) const = 0;
   12|       |	virtual void GetVelocity (float t, float v[3]) const = 0;
   13|       |	virtual void GetAcceleration (float t, float a[3]) const = 0;
   14|       |	virtual void GetJerk (float t, float j[3]) const = 0;
   15|       |	virtual void GetSpeed (float t, float *s) const = 0;
   16|       |	virtual void GetArclength (float t, float *s) const = 0;
   17|       |
   18|       |	// Don't need to be defined
   19|       |	void GetUnitTangentVector (float t, float T[3]);
   20|       |	void GetUnitBinormalVector (float t, float B[3]);
   21|       |	void GetUnitPrincipalNormalVector (float t, float N[3]);
   22|       |
   23|       |	// To be defined
   24|       |	virtual void GetCurvature (float t, float *kappa) const = 0;
   25|       |	virtual void GetTorsion (float t, float *nu) const = 0;
   26|       |	virtual void GetTangentialAcceleration (float t, float aT[3]) const = 0;
   27|       |	virtual void GetNormalAcceleration (float t, float aT[3]) const = 0;
   28|       |
   29|       |	void Export (char *filename);
   30|       |};
   31|       |
   32|       |//
   33|       |//
   34|       |//
   35|       |class Curve01 : public Curve
   36|       |{
   37|       |public:
   38|      0|	Curve01 () : Curve() { m_m = 12; m_a = 1; m_r = 6.; };
   39|      0|	virtual ~Curve01 () {};
   40|       |	
   41|       |	virtual void GetPosition (float t, float p[3]) const;
   42|       |	virtual void GetVelocity (float t, float v[3]) const;
   43|       |	virtual void GetAcceleration (float t, float a[3]) const;
   44|       |	virtual void GetJerk (float t, float j[3]) const;
   45|       |	virtual void GetSpeed (float t, float *s) const;
   46|       |	virtual void GetArclength (float t, float *s) const;
   47|       |
   48|       |	//void GetUnitTangentVector (float t, float T[3]);
   49|       |	//void GetUnitBinormalVector (float t, float B[3]);
   50|       |	//void GetUnitPrincipalNormalVector (float t, float N[3]);
   51|       |
   52|       |	virtual void GetCurvature (float t, float *kappa) const;
   53|       |	virtual void GetTorsion (float t, float *nu) const;
   54|       |	virtual void GetTangentialAcceleration (float t, float aT[3]) const;
   55|       |	virtual void GetNormalAcceleration (float t, float aT[3]) const;
   56|       |
   57|       |private:
   58|       |	float m_r; // radius
   59|       |	float m_m; // angular rate
   60|       |	float m_a; // amplitude
   61|       |};
   62|       |
   63|       |//
   64|       |// CurveHelical
   65|       |//
   66|       |class CurveHelical : public Curve
   67|       |{
   68|       |public:
   69|      0|	CurveHelical () : Curve() { m = 3.; n = 2.; };
   70|      0|	virtual ~CurveHelical() {};
   71|       |	
   72|       |	virtual void GetPosition (float t, float p[3]) const;
   73|       |	virtual void GetVelocity (float t, float v[3]) const;
   74|       |	virtual void GetAcceleration (float t, float a[3]) const;
   75|       |	virtual void GetJerk (float t, float j[3]) const;
   76|       |	virtual void GetSpeed (float t, float *s) const;
   77|       |	virtual void GetArclength (float t, float *s) const;
   78|       |
   79|       |	//void GetUnitTangentVector (float t, float T[3]);
   80|       |	//void GetUnitBinormalVector (float t, float B[3]);
   81|       |	//void GetUnitPrincipalNormalVector (float t, float N[3]);
   82|       |
   83|       |	virtual void GetCurvature (float t, float *kappa) const;
   84|       |	virtual void GetTorsion (float t, float *nu) const;
   85|       |	virtual void GetTangentialAcceleration (float t, float aT[3]) const;
   86|       |	virtual void GetNormalAcceleration (float t, float aT[3]) const;
   87|       |
   88|       |private:
   89|       |	float m; // angular rate
   90|       |	float n; // height
   91|       |};
   92|       |
   93|       |//
   94|       |// WindingLineOnTorus
   95|       |// ref : http://www.maplesoft.com/applications/view.aspx?SID=4019&view=html
   96|       |//
   97|       |class CurveWindingLineOnTorus : public Curve
   98|       |{
   99|       |public:
  100|      0|	CurveWindingLineOnTorus () { p=4; q=1; m=2; n=10; };
  101|      0|	virtual ~CurveWindingLineOnTorus () {};
  102|       |
  103|       |	virtual void GetPosition (float t, float p[3]) const;
  104|       |	virtual void GetVelocity (float t, float v[3]) const;
  105|       |	virtual void GetAcceleration (float t, float a[3]) const;
  106|       |	virtual void GetJerk (float t, float j[3]) const;
  107|       |	virtual void GetSpeed (float t, float *s) const;
  108|       |	virtual void GetArclength (float t, float *s) const;
  109|       |	//void GetUnitTangentVector (float t, float T[3]);
  110|       |	//void GetUnitBinormalVector (float t, float B[3]);
  111|       |	//void GetUnitPrincipalNormalVector (float t, float N[3]);
  112|       |	virtual void GetCurvature (float t, float *kappa) const;
  113|       |	virtual void GetTorsion (float t, float *nu) const;
  114|       |	virtual void GetTangentialAcceleration (float t, float aT[3]) const;
  115|       |	virtual void GetNormalAcceleration (float t, float aT[3]) const;
  116|       |
  117|       |private:
  118|       |	float p; // big radius
  119|       |	float q; // small radius
  120|       |	float m; // angular rate
  121|       |	float n; // angular rate
  122|       |};
  123|       |
  124|       |#endif // __CURVE_H__

/workspaces/cg/src/cgmath/curve_bezier.cpp:
    1|       |#include <stdio.h>
    2|       |#include <stdlib.h>
    3|       |#include <assert.h>
    4|       |#include <math.h>
    5|       |#include <string.h>
    6|       |
    7|       |#include "curve_bezier.h"
    8|       |#include "berstein.h"
    9|       |#include "algebra_vector3.h"
   10|       |
   11|       |/**
   12|       |* Constructor
   13|       |*/
   14|       |CurveBezier::CurveBezier ()
   15|      0|{
   16|      0|	m_nMaxControlPoints = 4;
   17|      0|	m_controlPoints = (vec3*)malloc(m_nMaxControlPoints*sizeof(vec3));
   18|      0|	assert (m_controlPoints);
   19|      0|	m_nControlPoints = 0;
   20|      0|}
   21|       |
   22|       |/**
   23|       |* Copy Constructor
   24|       |*/
   25|       |CurveBezier::CurveBezier (const CurveBezier &par_curveBezier)
   26|      0|{
   27|      0|	m_nMaxControlPoints = par_curveBezier.m_nMaxControlPoints;
   28|      0|	m_controlPoints = (vec3*)malloc(m_nMaxControlPoints*sizeof(vec3));
   29|      0|	assert (m_controlPoints);
   30|      0|	memcpy (m_controlPoints, par_curveBezier.m_controlPoints, m_nMaxControlPoints*sizeof(vec3));
   31|      0|	m_nControlPoints = par_curveBezier.m_nControlPoints;
   32|      0|}
   33|       |
   34|       |/**
   35|       |* Destructor
   36|       |*/
   37|       |CurveBezier::~CurveBezier ()
   38|      0|{
   39|      0|	if (m_controlPoints) free (m_controlPoints);
   40|      0|}
   41|       |
   42|       |/**
   43|       |* add a new control point
   44|       |*
   45|       |* /return 1 if the new control point is correctly added, 0 otherwise
   46|       |*/
   47|       |int CurveBezier::addControlPoint (vec3 v)
   48|      0|{
   49|      0|	return addControlPoint (v[0], v[1], v[2]);
   50|      0|}
   51|       |
   52|       |int CurveBezier::addControlPoint (float x, float y, float z)
   53|      0|{
   54|      0|	if (m_nControlPoints == m_nMaxControlPoints)
   55|      0|	{
   56|      0|		m_nMaxControlPoints *= 2;
   57|      0|		m_controlPoints = (vec3*)realloc((void*)m_controlPoints, m_nMaxControlPoints*sizeof(vec3));
   58|      0|		if (m_controlPoints == NULL) return 0;
   59|      0|	}
   60|      0|	m_controlPoints[m_nControlPoints][0] = x;
   61|      0|	m_controlPoints[m_nControlPoints][1] = y;
   62|      0|	m_controlPoints[m_nControlPoints][2] = z;
   63|      0|	m_nControlPoints++;
   64|      0|	return 1;
   65|      0|}
   66|       |
   67|       |int CurveBezier::eval (float t, vec3 pt)
   68|      0|{
   69|      0|	vec3_init (pt, 0., 0., 0.);
   70|      0|	for (int i=0; i<m_nControlPoints; i++)
   71|      0|	{
   72|      0|		pt[0] += (float)bersteinPolynomial(m_nControlPoints-1,i,t) * m_controlPoints[i][0];
   73|      0|		pt[1] += (float)bersteinPolynomial(m_nControlPoints-1,i,t) * m_controlPoints[i][1];
   74|      0|		pt[2] += (float)bersteinPolynomial(m_nControlPoints-1,i,t) * m_controlPoints[i][2];
   75|      0|	}
   76|      0|	return 0;
   77|      0|}
   78|       |
   79|       |int CurveBezier::eval_on_x (float x, vec3 pt)
   80|      0|{
   81|      0|	float t, t1 = 0., t2 = 1.;
   82|      0|	vec3 pt1, pt2;
   83|      0|	eval (t1, pt1);
   84|      0|	eval (t2, pt2);
   85|      0|	if (pt1[0] > x && pt2[0] < x)
   86|      0|		return -1;
   87|       |	
   88|      0|	do {
   89|      0|		t = (t1+t2)/2.;
   90|      0|		eval (t, pt);
   91|      0|		if (pt[0] < x)
   92|      0|		{
   93|      0|			t1 = t;
   94|      0|			vec3_copy (pt1, pt);
   95|      0|		}
   96|      0|		else
   97|      0|		{
   98|      0|			t2 = t;
   99|      0|			vec3_copy (pt2, pt);
  100|      0|		}
  101|      0|	} while (fabs(t1-t2) > 0.000001);
  102|       |
  103|      0|	return 0;
  104|      0|}
  105|       |
  106|       |/**
  107|       |* compute nPoints along the Bzier curve
  108|       |*
  109|       |* /return 1 if the new control point is correctly added, 0 otherwise
  110|       |*/
  111|       |int
  112|       |CurveBezier::computeInterpolation (int par_nPoints, vec3 **par_points)
  113|      0|{
  114|      0|	if (par_nPoints < 0)
  115|      0|	{
  116|      0|		par_points = NULL;
  117|      0|		return 0;
  118|      0|	}
  119|      0|	vec3 *points = (vec3*)malloc(par_nPoints*sizeof(vec3));
  120|      0|	if (!points)
  121|      0|	{
  122|      0|		par_points = NULL;
  123|      0|		return 0;
  124|      0|	}
  125|      0|	float t = 0.0;
  126|      0|	for (int iPoint=0; iPoint<par_nPoints; iPoint++, t += 1.0f/(par_nPoints-1.0f))
  127|      0|	{
  128|      0|		points[iPoint][0] = points[iPoint][1] = points[iPoint][2] = 0.0;
  129|      0|		for (int i=0; i<m_nControlPoints; i++)
  130|      0|		{
  131|      0|			points[iPoint][0] += (float)bersteinPolynomial(m_nControlPoints-1,i,t) * m_controlPoints[i][0];
  132|      0|			points[iPoint][1] += (float)bersteinPolynomial(m_nControlPoints-1,i,t) * m_controlPoints[i][1];
  133|      0|			points[iPoint][2] += (float)bersteinPolynomial(m_nControlPoints-1,i,t) * m_controlPoints[i][2];
  134|      0|		}
  135|      0|	}
  136|      0|	*par_points = points;
  137|      0|	return 1;
  138|      0|}
  139|       |
  140|       |/**
  141|       |* compute nPoints along the Bzier curve (quadratic curve, ie 3 control points, ie degree = 2)
  142|       |*
  143|       |* /return 1 if the new control point is correctly added, 0 otherwise
  144|       |*/
  145|       |int
  146|       |CurveBezier::computeInterpolation3 (int par_nPoints, vec3 **par_points)
  147|      0|{
  148|      0|	if (getDegree () != 2)
  149|      0|	{
  150|      0|		par_points = NULL;
  151|      0|		return 0;
  152|      0|	}
  153|      0|	vec3 *points = (vec3*)malloc(par_nPoints*sizeof(vec3));
  154|      0|	if (!points)
  155|      0|	{
  156|      0|		par_points = NULL;
  157|      0|		return 0;
  158|      0|	}
  159|      0|	float t = 0.0;
  160|      0|	for (int iPoint=0; iPoint<par_nPoints; iPoint++, t += 1.0f/(par_nPoints-1))
  161|      0|	{
  162|      0|		float t2 = t * t;
  163|      0|		float tm1 = 1.0f - t;
  164|      0|		float tm12 = tm1 * tm1;
  165|       |
  166|      0|		points[iPoint][0] = tm12 * m_controlPoints[0][0] + 2.0f * tm1 * t * m_controlPoints[1][0] + t2 * m_controlPoints[2][0];
  167|      0|		points[iPoint][1] = tm12 * m_controlPoints[0][1] + 2.0f * tm1 * t * m_controlPoints[1][1] + t2 * m_controlPoints[2][1];
  168|      0|		points[iPoint][2] = tm12 * m_controlPoints[0][2] + 2.0f * tm1 * t * m_controlPoints[1][2] + t2 * m_controlPoints[2][2];
  169|      0|	}
  170|      0|	*par_points = points;
  171|      0|	return 1;
  172|      0|}
  173|       |
  174|       |/**
  175|       |* compute nPoints along the Bzier curve (cubic curve, ie 4 control points, ie degree = 3)
  176|       |*
  177|       |* /return 1 if the new control point is correctly added, 0 otherwise
  178|       |*/
  179|       |int
  180|       |CurveBezier::computeInterpolation4 (int par_nPoints, vec3 **par_points)
  181|      0|{
  182|      0|	if (getDegree () != 3)
  183|      0|	{
  184|      0|		par_points = NULL;
  185|      0|		return 0;
  186|      0|	}
  187|      0|	vec3 *points = (vec3*)malloc(par_nPoints*sizeof(vec3));
  188|      0|	if (!points)
  189|      0|	{
  190|      0|		par_points = NULL;
  191|      0|		return 0;
  192|      0|	}
  193|      0|	float t = 0.0;
  194|      0|	for (int iPoint=0; iPoint<par_nPoints; iPoint++, t += 1.0f/(par_nPoints-1.0f))
  195|      0|	{
  196|      0|		float t3 = t * t * t;
  197|      0|		float tm1 = 1.0f - t;
  198|      0|		float tm13 = tm1 * tm1 * tm1;
  199|       |
  200|      0|		points[iPoint][0] = tm13 * m_controlPoints[0][0] + 3.0f * tm1 * tm1 * t * m_controlPoints[1][0] + 3.0f * tm1 * t * t * m_controlPoints[2][0] + t3 * m_controlPoints[3][0];
  201|      0|		points[iPoint][1] = tm13 * m_controlPoints[0][1] + 3.0f * tm1 * tm1 * t * m_controlPoints[1][1] + 3.0f * tm1 * t * t * m_controlPoints[2][1] + t3 * m_controlPoints[3][1];
  202|      0|		points[iPoint][2] = tm13 * m_controlPoints[0][2] + 3.0f * tm1 * tm1 * t * m_controlPoints[1][2] + 3.0f * tm1 * t * t * m_controlPoints[2][2] + t3 * m_controlPoints[3][2];
  203|      0|	}
  204|      0|	*par_points = points;
  205|      0|	return 1;
  206|      0|}
  207|       |
  208|       |
  209|       |/**
  210|       |* Interpolation by recursive approach
  211|       |*/
  212|       |int
  213|       |CurveBezier::computeInterpolationRecursive3aux (int par_level, vec3 **par_points, int par_pos)
  214|      0|{
  215|      0|	vec3 *points = *par_points;
  216|      0|    if (par_level <= 0)
  217|      0|	{
  218|      0|		points[par_pos][0]   = m_controlPoints[0][0];
  219|      0|		points[par_pos][1]   = m_controlPoints[0][1];
  220|      0|		points[par_pos][2]   = m_controlPoints[0][2];
  221|      0|		points[par_pos+1][0] = m_controlPoints[3][0];
  222|      0|		points[par_pos+1][1] = m_controlPoints[3][1];
  223|      0|		points[par_pos+1][2] = m_controlPoints[3][2];
  224|      0|    }
  225|      0|	else
  226|      0|	{
  227|       |        // subdivide into 2 Bezier segments
  228|      0|		CurveBezier *left = new CurveBezier ();
  229|      0|		vec3 l1, l2, l3, l4;
  230|      0|		l1[0] = m_controlPoints[0][0];
  231|      0|		l1[1] = m_controlPoints[0][1];
  232|      0|		l1[2] = m_controlPoints[0][2];
  233|      0|		l2[0] = (m_controlPoints[0][0] + m_controlPoints[1][0] ) / 2.0f;
  234|      0|		l2[1] = (m_controlPoints[0][1] + m_controlPoints[1][1] ) / 2.0f;
  235|      0|		l2[2] = (m_controlPoints[0][2] + m_controlPoints[1][2] ) / 2.0f;
  236|      0|		l3[0] = (m_controlPoints[0][0] + 2.0f*m_controlPoints[1][0] + m_controlPoints[2][0] ) / 4.0f;
  237|      0|		l3[1] = (m_controlPoints[0][1] + 2.0f*m_controlPoints[1][1] + m_controlPoints[2][1] ) / 4.0f;
  238|      0|		l3[2] = (m_controlPoints[0][2] + 2.0f*m_controlPoints[1][2] + m_controlPoints[2][2] ) / 4.0f;
  239|      0|		l4[0] = (m_controlPoints[0][0] + 3.0f*m_controlPoints[1][0] + 3.0f*m_controlPoints[2][0] + m_controlPoints[3][0] ) / 8.0f;
  240|      0|		l4[1] = (m_controlPoints[0][1] + 3.0f*m_controlPoints[1][1] + 3.0f*m_controlPoints[2][1] + m_controlPoints[3][1] ) / 8.0f;
  241|      0|		l4[2] = (m_controlPoints[0][2] + 3.0f*m_controlPoints[1][2] + 3.0f*m_controlPoints[2][2] + m_controlPoints[3][2] ) / 8.0f;
  242|      0|		left->addControlPoint (l1);
  243|      0|		left->addControlPoint (l2);
  244|      0|		left->addControlPoint (l3);
  245|      0|		left->addControlPoint (l4);
  246|      0|		left->computeInterpolationRecursive3aux (par_level-1, par_points, par_pos);
  247|      0|		delete left;
  248|       |
  249|      0|		CurveBezier *right = new CurveBezier ();
  250|      0|		vec3 r1, r2, r3, r4;
  251|      0|		r1[0] = (m_controlPoints[0][0] + 3.0f*m_controlPoints[1][0] + 3.0f*m_controlPoints[2][0] + m_controlPoints[3][0] ) / 8.0f;
  252|      0|		r1[1] = (m_controlPoints[0][1] + 3.0f*m_controlPoints[1][1] + 3.0f*m_controlPoints[2][1] + m_controlPoints[3][1] ) / 8.0f;
  253|      0|		r1[2] = (m_controlPoints[0][2] + 3.0f*m_controlPoints[1][2] + 3.0f*m_controlPoints[2][2] + m_controlPoints[3][2] ) / 8.0f;
  254|      0|		r2[0] = (m_controlPoints[1][0] + 2.0f*m_controlPoints[2][0] + m_controlPoints[3][0] ) / 4.0f;
  255|      0|		r2[1] = (m_controlPoints[1][1] + 2.0f*m_controlPoints[2][1] + m_controlPoints[3][1] ) / 4.0f;
  256|      0|		r2[2] = (m_controlPoints[1][2] + 2.0f*m_controlPoints[2][2] + m_controlPoints[3][2] ) / 4.0f;
  257|      0|		r3[0] = (m_controlPoints[2][0] + m_controlPoints[3][0] ) / 2.0f;
  258|      0|		r3[1] = (m_controlPoints[2][1] + m_controlPoints[3][1] ) / 2.0f;
  259|      0|		r3[2] = (m_controlPoints[2][2] + m_controlPoints[3][2] ) / 2.0f;
  260|      0|		r4[0] = m_controlPoints[3][0];
  261|      0|		r4[1] = m_controlPoints[3][1];
  262|      0|		r4[2] = m_controlPoints[3][2];
  263|      0|		right->addControlPoint (r1);
  264|      0|		right->addControlPoint (r2);
  265|      0|		right->addControlPoint (r3);
  266|      0|		right->addControlPoint (r4);
  267|      0|		right->computeInterpolationRecursive3aux (par_level-1, par_points, par_pos+(int)pow (2.0, par_level-1));
  268|      0|		delete right;
  269|      0|    }
  270|       |
  271|      0|	return 0;
  272|      0|}
  273|       |
  274|       |int
  275|       |CurveBezier::computeInterpolationRecursive3 (int par_level, int &par_nPoints, vec3 **par_points)
  276|      0|{
  277|      0|	if (getDegree () != 3) return 0;
  278|      0|	par_nPoints = 1 + (int)pow (2.0,par_level);
  279|       |
  280|      0|	vec3 *points = (vec3*)malloc(par_nPoints*sizeof(vec3));
  281|      0|	if (!points)
  282|      0|	{
  283|      0|		par_points = NULL;
  284|      0|		return 0;
  285|      0|	}
  286|       |
  287|      0|	computeInterpolationRecursive3aux (par_level, &points, 0);
  288|      0|	*par_points = points;
  289|       |
  290|      0|	return 1;
  291|      0|}
  292|       |
  293|       |/**
  294|       |* Interpolation by recursive approach
  295|       |*/
  296|       |bool
  297|       |CurveBezier::isSufficentlyFlat (float tolerance)
  298|      0|{
  299|      0|	assert (getDegree () == 3);
  300|       |
  301|      0|	dump ();
  302|      0|	double ux = 3.0*m_controlPoints[1][0] - 2.0*m_controlPoints[0][0] - m_controlPoints[3][0]; ux *= ux;
  303|      0|	double uy = 3.0*m_controlPoints[1][1] - 2.0*m_controlPoints[0][1] - m_controlPoints[3][1]; uy *= uy;
  304|      0|	double vx = 3.0*m_controlPoints[2][0] - 2.0*m_controlPoints[3][0] - m_controlPoints[0][0]; vx *= vx;
  305|      0|	double vy = 3.0*m_controlPoints[2][1] - 2.0*m_controlPoints[3][1] - m_controlPoints[0][1]; vy *= vy;
  306|       |
  307|      0|	if (ux < vx) ux = vx;
  308|      0|	if (uy < vy) uy = vy;
  309|      0|	printf ("d = %f\n", ux+uy);
  310|      0|	return (ux+uy <= tolerance); /* tolerance is 16*tol^2 */
  311|      0|}
  312|       |
  313|       |int
  314|       |CurveBezier::computeInterpolationRecursiveFlatness3 (float tolerance, int &par_nPoints, vec3 **par_points)
  315|      0|{
  316|      0|	if (getDegree () != 3) return 0;
  317|       |
  318|      0|	if (isSufficentlyFlat (tolerance) == false)
  319|      0|	{
  320|      0|		printf ("false\n");
  321|       |
  322|       |        // subdivide into 2 Bezier segments
  323|      0|		vec3 l1, l2, l3, l4;
  324|      0|		l1[0] = m_controlPoints[0][0];
  325|      0|		l1[1] = m_controlPoints[0][1];
  326|      0|		l1[2] = m_controlPoints[0][2];
  327|      0|		l2[0] = (m_controlPoints[0][0] + m_controlPoints[1][0] ) / 2.0f;
  328|      0|		l2[1] = (m_controlPoints[0][1] + m_controlPoints[1][1] ) / 2.0f;
  329|      0|		l2[2] = (m_controlPoints[0][2] + m_controlPoints[1][2] ) / 2.0f;
  330|      0|		l3[0] = (m_controlPoints[0][0] + 2.0f*m_controlPoints[1][0] + m_controlPoints[2][0] ) / 4.0f;
  331|      0|		l3[1] = (m_controlPoints[0][1] + 2.0f*m_controlPoints[1][1] + m_controlPoints[2][1] ) / 4.0f;
  332|      0|		l3[2] = (m_controlPoints[0][2] + 2.0f*m_controlPoints[1][2] + m_controlPoints[2][2] ) / 4.0f;
  333|      0|		l4[0] = (m_controlPoints[0][0] + 3.0f*m_controlPoints[1][0] + 3.0f*m_controlPoints[2][0] + m_controlPoints[3][0] ) / 8.0f;
  334|      0|		l4[1] = (m_controlPoints[0][1] + 3.0f*m_controlPoints[1][1] + 3.0f*m_controlPoints[2][1] + m_controlPoints[3][1] ) / 8.0f;
  335|      0|		l4[2] = (m_controlPoints[0][2] + 3.0f*m_controlPoints[1][2] + 3.0f*m_controlPoints[2][2] + m_controlPoints[3][2] ) / 8.0f;
  336|      0|		CurveBezier *left = new CurveBezier ();
  337|      0|		left->addControlPoint (l1);
  338|      0|		left->addControlPoint (l2);
  339|      0|		left->addControlPoint (l3);
  340|      0|		left->addControlPoint (l4);
  341|      0|		int leftNPoints;
  342|      0|		vec3 *leftPoints;
  343|      0|		left->computeInterpolationRecursiveFlatness3 (tolerance, leftNPoints, &leftPoints);
  344|      0|		printf ("leftNPoints : %d\n", leftNPoints);
  345|      0|		delete left;
  346|       |
  347|      0|		vec3 r1, r2, r3, r4;
  348|      0|		r1[0] = (m_controlPoints[0][0] + 3.0f*m_controlPoints[1][0] + 3.0f*m_controlPoints[2][0] + m_controlPoints[3][0] ) / 8.0f;
  349|      0|		r1[1] = (m_controlPoints[0][1] + 3.0f*m_controlPoints[1][1] + 3.0f*m_controlPoints[2][1] + m_controlPoints[3][1] ) / 8.0f;
  350|      0|		r1[2] = (m_controlPoints[0][2] + 3.0f*m_controlPoints[1][2] + 3.0f*m_controlPoints[2][2] + m_controlPoints[3][2] ) / 8.0f;
  351|      0|		r2[0] = (m_controlPoints[1][0] + 2.0f*m_controlPoints[2][0] + m_controlPoints[3][0] ) / 4.0f;
  352|      0|		r2[1] = (m_controlPoints[1][1] + 2.0f*m_controlPoints[2][1] + m_controlPoints[3][1] ) / 4.0f;
  353|      0|		r2[2] = (m_controlPoints[1][2] + 2.0f*m_controlPoints[2][2] + m_controlPoints[3][2] ) / 4.0f;
  354|      0|		r3[0] = (m_controlPoints[2][0] + m_controlPoints[3][0] ) / 2.0f;
  355|      0|		r3[1] = (m_controlPoints[2][1] + m_controlPoints[3][1] ) / 2.0f;
  356|      0|		r3[2] = (m_controlPoints[2][2] + m_controlPoints[3][2] ) / 2.0f;
  357|      0|		r4[0] = m_controlPoints[3][0];
  358|      0|		r4[1] = m_controlPoints[3][1];
  359|      0|		r4[2] = m_controlPoints[3][2];
  360|      0|		CurveBezier *right = new CurveBezier ();
  361|      0|		right->addControlPoint (r1);
  362|      0|		right->addControlPoint (r2);
  363|      0|		right->addControlPoint (r3);
  364|      0|		right->addControlPoint (r4);
  365|      0|		int rightNPoints;
  366|      0|		vec3 *rightPoints;
  367|      0|		left->computeInterpolationRecursiveFlatness3 (tolerance, rightNPoints, &rightPoints);
  368|      0|		printf ("rightNPoints : %d\n", rightNPoints);
  369|      0|		delete right;
  370|       |
  371|       |		//printf ("%d %d\n", leftNPoints, rightNPoints);
  372|      0|		int nPoints = leftNPoints + rightNPoints - 1;
  373|      0|		printf ("nPoints : %d\n", nPoints);
  374|      0|		vec3 *points = (vec3*)malloc(nPoints*sizeof(vec3));
  375|      0|		if (!points)
  376|      0|		{
  377|      0|			par_nPoints = 0;
  378|      0|			par_points = NULL;
  379|      0|			return 0;
  380|      0|		}
  381|      0|		int i,j;
  382|      0|		for (i=0; i<leftNPoints; i++)
  383|      0|		{
  384|      0|			points[i][0] = leftPoints[i][0];
  385|      0|			points[i][1] = leftPoints[i][1];
  386|      0|			points[i][2] = leftPoints[i][2];
  387|      0|		}
  388|      0|		for (j=1; j<leftNPoints; j++, i++)
  389|      0|		{
  390|      0|			points[i][0] = rightPoints[j][0];
  391|      0|			points[i][1] = rightPoints[j][1];
  392|      0|			points[i][2] = rightPoints[j][2];
  393|      0|		}
  394|      0|		free (leftPoints);
  395|      0|		free (rightPoints);
  396|      0|		par_nPoints = nPoints;
  397|      0|		*par_points = points;
  398|      0|	}
  399|      0|	else
  400|      0|	{
  401|      0|		printf ("true\n");
  402|      0|		par_nPoints = 2;
  403|      0|		vec3 *points = (vec3*)malloc(par_nPoints*sizeof(vec3));
  404|      0|		if (!points)
  405|      0|		{
  406|      0|			par_nPoints = 0;
  407|      0|			par_points = NULL;
  408|      0|			return 0;
  409|      0|		}
  410|      0|		points[0][0] = m_controlPoints[0][0];
  411|      0|		points[0][1] = m_controlPoints[0][1];
  412|      0|		points[0][2] = m_controlPoints[0][2];
  413|      0|		points[1][0] = m_controlPoints[3][0];
  414|      0|		points[1][1] = m_controlPoints[3][1];
  415|      0|		points[1][2] = m_controlPoints[3][2];
  416|      0|		*par_points = points;
  417|      0|	}
  418|       |
  419|      0|	return 1;
  420|      0|}
  421|       |
  422|       |/**
  423|       |* compute the arc length of Cubic Bezier Curves (cubic curve, ie 4 control points, ie degree = 3)
  424|       |*
  425|       |* %return 1 if the new control point is correctly added, 0 otherwise
  426|       |*
  427|       |* ref : http://steve.hollasch.net/cgindex/curves/cbezarclen.html
  428|       |*/
  429|       |static double q1, q2, q3, q4, q5;
  430|       |double balf (double t)                   // Bezier Arc Length Function
  431|      0|{
  432|      0|    double result = q5 + t*(q4 + t*(q3 + t*(q2 + t*q1)));
  433|      0|    result = sqrt(result);
  434|      0|    return result;
  435|      0|}
  436|       |
  437|       |float
  438|       |CurveBezier::length4 (void)
  439|      0|{
  440|      0|    vec3 k1, k2, k3, k4;
  441|       |
  442|      0|	for (int i=0; i<3; i++)
  443|      0|	{
  444|      0|		k1[i] = -m_controlPoints[0][i] + 3*(m_controlPoints[1][i] - m_controlPoints[2][i]) + m_controlPoints[3][i];
  445|      0|	    k2[i] = 3*(m_controlPoints[0][i] + m_controlPoints[2][i]) - 6*m_controlPoints[1][i];
  446|      0|		k3[i] = 3*(m_controlPoints[1][i] - m_controlPoints[0][i]);
  447|      0|	    k4[i] = m_controlPoints[0][i];
  448|      0|	}
  449|       |
  450|      0|    q1 = 9.0*(k1[0]*k1[0] + k1[1]*k1[1]);
  451|      0|    q2 = 12.0*(k1[0]*k2[0] + k1[1]*k2[1]);
  452|      0|    q3 = 3.0*(k1[0]*k3[0] + k1[1]*k3[1]) + 4.0*(k2[0]*k2[0] + k2[1]*k2[1]);
  453|      0|    q4 = 4.0*(k2[0]*k3[0] + k2[1]*k3[1]);
  454|      0|    q5 = k3[0]*k3[0] + k3[1]*k3[1];
  455|       |
  456|      0|    float result=0.0;// = Simpson(balf, 0, 1, 1024, 0.001);
  457|      0|    return result;
  458|      0|}
  459|       |
  460|       |/**
  461|       |* dump
  462|       |*/
  463|       |void
  464|       |CurveBezier::dump (void)
  465|      0|{
  466|      0|	for (int i=0; i<m_nControlPoints; i++)
  467|      0|		printf ("%d : %f %f %f\n", i, m_controlPoints[i][0], m_controlPoints[i][1], m_controlPoints[i][2]);
  468|      0|}
  469|       |void
  470|       |CurveBezier::export_interpolated (char *filename, unsigned int n)
  471|      0|{
  472|      0|	vec3 *bezier_interpolated = (vec3*)malloc(n*sizeof(vec3));
  473|      0|	computeInterpolation (n, &bezier_interpolated);
  474|       |	
  475|      0|	FILE *ptr = fopen (filename, "w");
  476|      0|	for (unsigned int i=0; i<n; i++)
  477|      0|		fprintf (ptr, "%f %f\n", bezier_interpolated[i][0], bezier_interpolated[i][1]);
  478|      0|	fclose (ptr);
  479|       |
  480|      0|	free (bezier_interpolated);
  481|      0|}

/workspaces/cg/src/cgmath/curve_bezier.h:
    1|       |#ifndef __CURVE_BEZIER_H__
    2|       |#define __CURVE_BEZIER_H__
    3|       |
    4|       |#include "curve.h"
    5|       |#include "algebra_vector3.h"
    6|       |
    7|       |/**
    8|       |* TODO
    9|       |*
   10|       |* Implmenter intersection avec droites
   11|       |* Faire inventaire des diffrentes mthodes d'interpolation
   12|       |*/
   13|       |
   14|       |/**
   15|       |* Bezier curve
   16|       |*/
   17|       |class CurveBezier //: public Curve
   18|       |{
   19|       |public:
   20|       |	CurveBezier ();
   21|       |	CurveBezier (const CurveBezier &par_curveBezier);
   22|       |	//CurveBezier* clone () { return new CurveBezier (*this); };
   23|       |	void dump (void);
   24|       |	void export_interpolated (char *filename, unsigned int n);
   25|       |
   26|       |	// specific method
   27|       |	~CurveBezier ();
   28|       |
   29|      0|	int getDegree (void) { return m_nControlPoints-1; };
   30|       |	bool getControlPoint (int index, vec3 v)
   31|      0|	{
   32|      0|		if (index > m_nControlPoints)
   33|      0|			return false;
   34|      0|		
   35|      0|		v[0] = m_controlPoints[index][0];
   36|      0|		v[1] = m_controlPoints[index][1];
   37|      0|		v[2] = m_controlPoints[index][2];
   38|      0|
   39|      0|		return true;
   40|      0|	}
   41|       |
   42|       |	// Construction of the Bezier curve
   43|       |	int addControlPoint (vec3 v);
   44|       |	int addControlPoint (float x, float y, float z);
   45|       |	
   46|       |	// eval
   47|       |	int eval (float t, vec3 pt);
   48|       |	int eval_on_x (float x, vec3 pt);
   49|       |
   50|       |	// Interpolation methods
   51|       |	int computeInterpolation (int par_nPoints, vec3 **par_points);
   52|       |	int computeInterpolation3 (int par_nPoints, vec3 **par_points);
   53|       |	int computeInterpolation4 (int par_nPoints, vec3 **par_points);
   54|       |
   55|       |	int computeInterpolationRecursive3 (int level, int &par_nPoints, vec3 **par_points);
   56|       |	int computeInterpolationRecursive3aux (int par_level, vec3 **points, int pos);
   57|       |
   58|       |	bool isSufficentlyFlat (float tolerance);
   59|       |	int computeInterpolationRecursiveFlatness3 (float tolerance, int &par_nPoints, vec3 **par_points);
   60|       |
   61|       |	// Normals
   62|       |
   63|       |	// Length
   64|       |	float length4 (void);
   65|       |
   66|       |	// Intersection with a line
   67|       |
   68|       |
   69|       |private:
   70|       |	int m_nMaxControlPoints;
   71|       |	int m_nControlPoints;
   72|       |	vec3 *m_controlPoints;
   73|       |};
   74|       |
   75|       |#endif // __CURVE_BEZIER_H__

/workspaces/cg/src/cgmath/curve_kappatau.h:
    1|       |#ifndef __CURVE_KAPPATAU_H__
    2|       |#define __CURVE_KAPPATAU_H__
    3|       |
    4|       |//
    5|       |// http://www.cs.sjsu.edu/faculty/rucker/kaptaudoc/ktpaper.htm
    6|       |//
    7|       |// example
    8|       |//float kappa (float s) { return 8; }
    9|       |//float tau (float s) { return sin(s)+3*sin(2*s); }
   10|       |//
   11|       |class CurveKappaTau
   12|       |{
   13|       |public:
   14|      0|	CurveKappaTau () {};
   15|      0|	~CurveKappaTau () {};
   16|       |
   17|       |	void Export (char *filename);
   18|       |
   19|      0|	void set_kappa ( float (*f)(float) ) { m_kappa = f; };
   20|      0|	void set_tau ( float (*f)(float) ) { m_tau = f; };
   21|       |
   22|       |private:
   23|       |	float (*m_kappa)(float);
   24|       |	float (*m_tau)(float);
   25|       |};
   26|       |
   27|       |#endif // __CURVE_KAPPATAU_H__

/workspaces/cg/src/cgmath/curve_nurbs.h:
    1|       |#ifndef __CURVE_NURBS_H__
    2|       |#define __CURVE_NURBS_H__
    3|       |
    4|       |#include "algebra_vector3.h"
    5|       |
    6|       |/**
    7|       |* Curve NURBS
    8|       |*/
    9|       |class CurveNURBS
   10|       |{
   11|       |public:
   12|       |	CurveNURBS ();
   13|       |	CurveNURBS (const CurveNURBS &curveNURBS);
   14|       |	//CurveNURBS* clone () { return new CurveNURBS (*this); };
   15|       |	void dump (void);
   16|       |
   17|       |	// specific methods
   18|       |	~CurveNURBS ();
   19|       |
   20|       |	int addControlPoint (float x, float y, float z, float weight);
   21|       |	int setKnots (float *knots, int size);
   22|       |	int normalizeKnots (void);
   23|       |
   24|      0|	int nControlPoints (void) { return m_nControlPoints; };
   25|       |	bool getControlPoints (int index, vec3 &v)
   26|      0|	{
   27|      0|		if (index > m_nControlPoints)
   28|      0|			return false;
   29|      0|		
   30|      0|		v[0] = m_controlPoints[index][0];
   31|      0|		v[1] = m_controlPoints[index][1];
   32|      0|		v[2] = m_controlPoints[index][2];
   33|      0|
   34|      0|		return true;
   35|      0|	};
   36|       |	
   37|       |	float basisFunction (int i, int j, float u);
   38|       |	int computeInterpolation (int par_nPoints, vec3 **par_points);
   39|       |	
   40|       |	void dumpAllBasisFunctions (int nPoints);
   41|       |	void dumpBasisFunction (int index, int nPoints);
   42|       |
   43|       |private:
   44|       |	int m_nMaxControlPoints;
   45|       |
   46|       |	// control points
   47|       |	int m_nControlPoints;
   48|       |	vec3 *m_controlPoints;
   49|       |
   50|       |	// weights
   51|       |	float *m_weights;
   52|       |
   53|       |	// knots
   54|       |	int m_degree;
   55|       |	int m_nKnots;
   56|       |	float *m_knots;
   57|       |};
   58|       |
   59|       |#endif // __CURVE_NURBS_H__

/workspaces/cg/src/cgmath/geometry.cpp:
    1|       |#include <math.h>
    2|       |
    3|       |#include "geometry.h"
    4|       |#include "algebra_vector3.h"
    5|       |#include "polynomial.h"
    6|       |
    7|       |Geometry::Geometry()
    8|  75.8k|{
    9|  75.8k|	m_pAABox = NULL;
   10|  75.8k|}
   11|       |
   12|       |//
   13|       |//
   14|       |bool Geometry::GetIntersectionBboxWithRay (vec3 o, vec3 d)
   15|   884k|{
   16|   884k|	if (m_pAABox)
   17|   868k|	{
   18|   868k|		Ray r (Vector3 (o[0], o[1], o[2]), Vector3 (d[0], d[1], d[2]));
   19|   868k|		return m_pAABox->intersection (r, 0., 100.);
   20|   868k|	}
   21|  16.3k|	else
   22|  16.3k|		return true;
   23|   884k|};
   24|       |
   25|       |
   26|       |//
   27|       |// Sphere
   28|       |//
   29|       |
   30|       |// Refernce : http://wiki.cgsociety.org/index.php/Ray_Sphere_Intersection
   31|       |int Sphere::GetIntersectionWithRay (vec3 o, vec3 d, float *_t, vec3 i, vec3 n)
   32|  11.3k|{
   33|  11.3k|	vec3 vCO;
   34|  11.3k|	vCO[0] = o[0] - m_vCenter[0];
   35|  11.3k|	vCO[1] = o[1] - m_vCenter[1];
   36|  11.3k|	vCO[2] = o[2] - m_vCenter[2];
   37|       |
   38|       |	//Compute A, B and C coefficients
   39|  11.3k|	float a =      vec3_dot_product (d, d);
   40|  11.3k|	float b = 2. * vec3_dot_product (d, vCO);
   41|  11.3k|	float c =      vec3_dot_product (vCO, vCO) - (m_fRadius * m_fRadius);
   42|       |	
   43|       |	//Find discriminant
   44|  11.3k|	float disc = b*b - 4*a*c;
   45|       |    
   46|       |	// if discriminant is negative there are no real roots, so return 
   47|       |	// false as ray misses sphere
   48|  11.3k|	if (disc < 0)
   49|  3.59k|		return 0;
   50|       |
   51|       |	// compute q as described above
   52|  7.75k|	float distSqrt = sqrtf(disc);
   53|  7.75k|	float q;
   54|  7.75k|	if (b < 0)
   55|  7.75k|		q = (-b - distSqrt)/2.0;
   56|      0|	else
   57|      0|		q = (-b + distSqrt)/2.0;
   58|       |
   59|       |	// compute t0 and t1
   60|  7.75k|	float t0 = q / a;
   61|  7.75k|	float t1 = c / q;
   62|       |
   63|       |	// make sure t0 is smaller than t1
   64|  7.75k|	if (t0 > t1)
   65|      0|	{
   66|       |		// if t0 is bigger than t1 swap them around
   67|      0|		float temp = t0;
   68|      0|		t0 = t1;
   69|      0|		t1 = temp;
   70|      0|	}
   71|       |
   72|       |	// if t1 is less than zero, the object is in the ray's negative direction
   73|       |	// and consequently the ray misses the sphere
   74|  7.75k|	float t;
   75|  7.75k|	if (t1 < 0)
   76|      0|		return 0;
   77|       |
   78|  7.75k|	if (t0 < 0) // if t0 is less than zero, the intersection point is at t1
   79|      0|		t = t1;
   80|  7.75k|	else // else the intersection point is at t0
   81|  7.75k|		t = t0;
   82|       |
   83|  7.75k|	*_t = t;
   84|       |
   85|  7.75k|	i[0] = o[0] + t*d[0];
   86|  7.75k|	i[1] = o[1] + t*d[1];
   87|  7.75k|	i[2] = o[2] + t*d[2];
   88|       |	
   89|  7.75k|	n[0] = i[0]-m_vCenter[0];
   90|  7.75k|	n[1] = i[1]-m_vCenter[1];
   91|  7.75k|	n[2] = i[2]-m_vCenter[2];
   92|       |	
   93|  7.75k|	return 1;
   94|  7.75k|}
   95|       |
   96|       |int Sphere::GetIntersectionWithSegment (vec3 vStart, vec3 vEnd, float *_t, vec3 i, vec3 n)
   97|      0|{
   98|      0|	vec3 vDirection;
   99|      0|	vDirection[0] = vEnd[0] - vStart[0];
  100|      0|	vDirection[1] = vEnd[1] - vStart[1];
  101|      0|	vDirection[2] = vEnd[2] - vStart[2];
  102|      0|	float l = sqrt (vec3_dot_product (vDirection, vDirection));
  103|      0|	vec3_normalize (vDirection);
  104|      0|	unsigned int res = GetIntersectionWithRay (vStart, vDirection, _t, i, n);
  105|      0|	return (res && *_t < l);
  106|      0|}
  107|       |
  108|       |
  109|       |
  110|       |//
  111|       |// Torus
  112|       |//
  113|       |int Torus::GetIntersectionWithRay (vec3 vOrig, vec3 vDirection, float *_t, vec3 i, vec3 n)
  114|  16.3k|{
  115|  16.3k|	float r2 = r*r;
  116|  16.3k|	float R2 = R*R;
  117|  16.3k|	float oz = vOrig[2];
  118|  16.3k|	float oz2 = oz*oz;
  119|  16.3k|	float dz = vDirection[2];
  120|  16.3k|	float dz2 = dz*dz;
  121|       |
  122|  16.3k|	float alpha = vec3_dot_product (vDirection, vDirection);
  123|  16.3k|	float alpha2 = alpha * alpha;
  124|  16.3k|	float beta = 2. * vec3_dot_product (vOrig, vDirection);
  125|  16.3k|	float beta2 = beta * beta;
  126|  16.3k|	float gamma = vec3_dot_product (vOrig, vOrig) - r2 - R2;
  127|  16.3k|	float gamma2 = gamma * gamma;
  128|       |
  129|  16.3k|	double c[5], s[4], err[4];
  130|  16.3k|	c[4] = alpha2;
  131|  16.3k|	c[3] = 2*alpha*beta;
  132|  16.3k|	c[2] = beta2 + 2*alpha*gamma + 4*R2*dz2;
  133|  16.3k|	c[1] = 2*beta*gamma + 8*R2*oz*dz;
  134|  16.3k|	c[0] = gamma2 + 4*R2*oz2 - 4*R2*r2;
  135|       |
  136|       |	//printf ("%f %f %f %f %f\n", c[0], c[1], c[2], c[3], c[4]);
  137|       |
  138|  16.3k|	int num, num1, num2;
  139|  16.3k|	num1 = SolveQuartic (c, s);
  140|  16.3k|	num2 = quartic (c[3]/c[4], c[2]/c[4], c[1]/c[4], c[0]/c[4], s, err);
  141|       |
  142|  16.3k|	if (0 && num1 != num2)
  143|      0|	{
  144|      0|		num1 = SolveQuartic (c, s);
  145|      0|		if (1 || num1 > 0)
  146|      0|			printf ("  -%d-> %f %f %f %f\n", num1, s[0], s[1], s[2], s[3]);
  147|      0|		num2 = quartic (c[3]/c[4], c[2]/c[4], c[1]/c[4], c[0]/c[4], s, err);
  148|      0|		if (1 || num2 > 0)
  149|      0|		{
  150|      0|			printf ("  -%d-> %f %f %f %f\n", num2, s[0], s[1], s[2], s[3]);
  151|      0|			printf ("\n");
  152|      0|		}
  153|      0|	}
  154|       |
  155|  16.3k|	num = num1;
  156|  16.3k|	if (1 || num > 0)// && s[1]<=0. && s[2]<=0. && s[3]<=0.)
  157|  16.3k|	{
  158|  16.3k|		float t = -1.;
  159|  26.0k|		for (int j=0; j<num; j++)
  160|  9.69k|		{
  161|       |			//printf ("%f ", s[j]);
  162|  9.69k|			if ((t < 0. && s[j] >= 0.) ||
  163|  9.69k|			    (s[j] >= 0. && s[j] < t))
  164|  6.20k|				t = s[j];
  165|  9.69k|		}
  166|       |		//printf ("\n");
  167|  16.3k|		if (t < 0.)
  168|  13.2k|			return 0;
  169|       |
  170|  3.10k|		*_t = t;
  171|  3.10k|		i[0] = vOrig[0] + t*vDirection[0];
  172|  3.10k|		i[1] = vOrig[1] + t*vDirection[1];
  173|  3.10k|		i[2] = vOrig[2] + t*vDirection[2];
  174|       |
  175|  3.10k|		float v[3];
  176|  3.10k|		v[0] = i[0];
  177|  3.10k|		v[1] = i[1];
  178|  3.10k|		v[2] = 0.;
  179|  3.10k|		vec3_normalize (v);
  180|  3.10k|		v[0] *= R;
  181|  3.10k|		v[1] *= R;
  182|       |
  183|  3.10k|		n[0] = (i[0] - v[0]);
  184|  3.10k|		n[1] = (i[1] - v[1]);
  185|  3.10k|		n[2] = i[2];
  186|  3.10k|		vec3_normalize (n);
  187|  3.10k|		return 1;
  188|  16.3k|	}
  189|      0|	else
  190|      0|		return 0;
  191|  16.3k|}
  192|       |
  193|       |int Torus::GetIntersectionWithSegment (vec3 vStart, vec3 vEnd, float *_t, vec3 i, vec3 n)
  194|      0|{
  195|      0|	vec3 vDirection;
  196|      0|	vec3_subtraction (vDirection, vEnd, vStart);
  197|      0|	unsigned int res = GetIntersectionWithRay (vStart, vDirection, _t, i, n);
  198|      0|	return (res && *_t < 1.);
  199|      0|}
  200|       |
  201|       |//
  202|       |// Triangle
  203|       |//
  204|       |
  205|       |// Reference : http://geomalgorithms.com/a06-_intersect-2.html
  206|       |int Triangle::GetIntersectionWithRay (vec3 vO, vec3 vD, float *_t, vec3 i, vec3 n)
  207|  3.02M|{
  208|  3.02M|    vec3  u, v;        // triangle vectors
  209|  3.02M|    vec3  w0, w;       // ray vectors
  210|  3.02M|    float r, a, b;     // params to calc ray-plane intersect
  211|       |
  212|       |    // get triangle edge vectors and plane normal
  213|  3.02M|	vec3_subtraction (u, m_v[1], m_v[0]);
  214|  3.02M|	vec3_subtraction (v, m_v[2], m_v[0]);
  215|  3.02M|	vec3_cross_product (n, u, v);
  216|  3.02M|    if (vec3_length (n) == 0.)      // triangle is degenerate
  217|      0|        return -1;                  // do not deal with this case
  218|  3.02M|	vec3_normalize (n);
  219|       |
  220|  3.02M|	vec3_subtraction (w0, vO,  m_v[0]);
  221|  3.02M|	a = -vec3_dot_product (n, w0);
  222|  3.02M|	b =  vec3_dot_product (n, vD);
  223|  3.02M|    if (fabs(b) < 0.000001)
  224|  4.12k|	{								// ray is  parallel to triangle plane
  225|  4.12k|        if (a == 0)                 // ray lies in triangle plane
  226|      0|            return 2;
  227|  4.12k|        else return 0;              // ray disjoint from plane
  228|  4.12k|    }
  229|  3.01M|	if (b >= 0.) // culling : triangle doesn't face the ray
  230|  1.53M|		return 0;
  231|       |
  232|       |    // get intersect point of ray with triangle plane
  233|  1.47M|    r = a / b;
  234|  1.47M|    if (r < 0.0)                    // ray goes away from triangle
  235|  20.2k|        return 0;                   // => no intersect
  236|       |    // for a segment, also test if (r > 1.0) => no intersect
  237|       |
  238|       |	// intersect point of ray and plane
  239|  1.45M|	vec3_init (i,
  240|  1.45M|		vO[0] + r * vD[0],
  241|  1.45M|		vO[1] + r * vD[1],
  242|  1.45M|		vO[2] + r * vD[2]);
  243|       |
  244|       |    // is I inside T?
  245|  1.45M|    float uu, uv, vv, wu, wv, D;
  246|  1.45M|    uu = vec3_dot_product (u,u);
  247|  1.45M|    uv = vec3_dot_product (u,v);
  248|  1.45M|    vv = vec3_dot_product (v,v);
  249|  1.45M|	vec3_subtraction (w, i, m_v[0]);
  250|  1.45M|    wu = vec3_dot_product (w,u);
  251|  1.45M|    wv = vec3_dot_product (w,v);
  252|  1.45M|    D = uv * uv - uu * vv;
  253|       |
  254|       |    // get and test parametric coords
  255|  1.45M|    float s, t;
  256|  1.45M|    s = (uv * wv - vv * wu) / D;
  257|  1.45M|    if (s < 0.0 || s > 1.0)         // I is outside T
  258|  1.28M|        return 0;
  259|   166k|    t = (uv * wu - uu * wv) / D;
  260|   166k|    if (t < 0.0 || (s + t) > 1.0)  // I is outside T
  261|   149k|        return 0;
  262|       |
  263|  17.3k|	*_t = r;
  264|       |
  265|  17.3k|    return 1;                       // I is in T
  266|   166k|}
  267|       |
  268|       |int Triangle::GetIntersectionWithSegment (vec3 vStart, vec3 vEnd, float *_t, vec3 i, vec3 n)
  269|      0|{
  270|      0|	vec3 vDirection;
  271|      0|	vec3_subtraction (vDirection, vEnd, vStart);
  272|      0|	unsigned int res = GetIntersectionWithRay (vStart, vDirection, _t, i, n);
  273|      0|	return (res == 1 && *_t < 1.);
  274|      0|}

/workspaces/cg/src/cgmath/geometry.h:
    1|       |#pragma once
    2|       |
    3|       |#include "algebra_vector3.h"
    4|       |#include "ray.h"
    5|       |#include "aabox.h"
    6|       |
    7|       |//
    8|       |// Geometry
    9|       |//
   10|       |class Geometry
   11|       |{
   12|       |public:
   13|       |	Geometry();
   14|       |
   15|       |	virtual bool GetIntersectionBboxWithRay (vec3 o, vec3 d);
   16|       |
   17|       |	virtual int GetIntersectionWithRay (vec3 o, vec3 d, float *_t, vec3 i, vec3 n) = 0;
   18|       |	virtual int GetIntersectionWithSegment (vec3 vStart, vec3 vEnd, float *_t, vec3 i, vec3 n) = 0;
   19|       |
   20|       |	virtual void* GetMaterial (void) = 0;
   21|       |
   22|       |	AABox *m_pAABox;
   23|       |};
   24|       |
   25|       |//
   26|       |// Plane
   27|       |//
   28|       |class Plane : public Geometry
   29|       |{
   30|       |public:
   31|       |	Plane ();
   32|       |	Plane (Vector3f normale, float distance);
   33|       |	Plane (Vector3f v1, Vector3f v2, Vector3f v3);
   34|       |	Plane (Vector3f pt, Vector3f normale);
   35|      0|	~Plane () {};
   36|       |	
   37|       |	float distance_point (Vector3f v);                 // distance between the plane and a point
   38|       |	float distance_point (float x, float y, float z);  // distance between the plane and a point
   39|       |	int  position (Vector3f v);                        // position of a point
   40|       |	void projected (Vector3f v_projected, Vector3f v); // projected of a point on the plane
   41|       |	void move (Vector3f res, Vector3f v, float d);     // move a point in the direction of the normale to let it at a distance d from the plane
   42|       |	
   43|       |	// getters - setters
   44|       |	float get_distance (void);
   45|       |	void get_normale (Vector3f &normale);
   46|       |	
   47|       |	// least square plane fitting
   48|       |	//
   49|       |	// Reference : Eberly "Game Engine Design",
   50|       |	//             Morgan Kaufmann, ISBN 1558605932
   51|       |	//             september, 2000
   52|       |	//             pp 473, 474 + code
   53|       |	//
   54|       |	void fitting (Vector3f *array, int n);
   55|       |
   56|       |	// intersections
   57|       |	virtual int GetIntersectionWithRay (vec3 o, vec3 d, float *_t, vec3 i, vec3 n);
   58|       |	virtual int GetIntersectionWithSegment (vec3 vStart, vec3 vEnd, float *_t, vec3 i, vec3 n);
   59|       |
   60|      0|	virtual void* GetMaterial (void) { return NULL; };
   61|       |
   62|       |private:
   63|       |	// equation of a plane : ax + by + cz + d = 0
   64|       |	Vector3f normale; // (a , b , c)
   65|       |	float distance; // c
   66|       |};
   67|       |
   68|       |//
   69|       |// Sphere
   70|       |//
   71|       |class Sphere : public Geometry
   72|       |{
   73|       |public:
   74|     53|	Sphere () {
   75|     53|		m_vCenter[0] = 0.;
   76|     53|		m_vCenter[1] = 0.;
   77|     53|		m_vCenter[2] = 0.;
   78|     53|		m_fRadius = 1.;
   79|     53|		m_pAABox = new AABox (Vector3 (-1., -1., -1.), Vector3 (1., 1., 1.));
   80|     53|		m_pAABox = NULL;
   81|     53|	};
   82|      0|	~Sphere () { if (m_pAABox) delete m_pAABox; };
   83|       |
   84|       |	void SetCenter (float vCenter[3])
   85|      0|	{
   86|      0|		m_vCenter[0] = vCenter[0];
   87|      0|		m_vCenter[1] = vCenter[1];
   88|      0|		m_vCenter[2] = vCenter[2];
   89|      0|		delete m_pAABox;
   90|      0|		m_pAABox = new AABox (Vector3 (m_vCenter[0]-m_fRadius, m_vCenter[1]-m_fRadius, m_vCenter[2]-m_fRadius),
   91|      0|				      Vector3 (m_vCenter[0]+m_fRadius, m_vCenter[1]+m_fRadius, m_vCenter[2]+m_fRadius));
   92|      0|	};
   93|       |	void SetCenter (float x, float y, float z)
   94|     53|	{
   95|     53|		m_vCenter[0] = x;
   96|     53|		m_vCenter[1] = y;
   97|     53|		m_vCenter[2] = z;
   98|     53|		delete m_pAABox;
   99|     53|		m_pAABox = new AABox (Vector3 (m_vCenter[0]-m_fRadius, m_vCenter[1]-m_fRadius, m_vCenter[2]-m_fRadius),
  100|     53|				      Vector3 (m_vCenter[0]+m_fRadius, m_vCenter[1]+m_fRadius, m_vCenter[2]+m_fRadius));
  101|     53|	};
  102|       |	void SetRadius (float fRadius)
  103|     53|	{
  104|     53|		m_fRadius = fRadius; 
  105|     53| 		delete m_pAABox;
  106|     53|		m_pAABox = new AABox (Vector3 (m_vCenter[0]-m_fRadius, m_vCenter[1]-m_fRadius, m_vCenter[2]-m_fRadius),
  107|     53|				      Vector3 (m_vCenter[0]+m_fRadius, m_vCenter[1]+m_fRadius, m_vCenter[2]+m_fRadius));
  108|     53|	};
  109|       |
  110|       |	// intersections
  111|       |	virtual int GetIntersectionWithRay (vec3 o, vec3 d, float *_t, vec3 i, vec3 n);
  112|       |	virtual int GetIntersectionWithSegment (vec3 vStart, vec3 vEnd, float *_t, vec3 i, vec3 n);
  113|       |
  114|  6.92k|	virtual void* GetMaterial (void) { return NULL; };
  115|       |
  116|       |private:
  117|       |	float m_vCenter[3];
  118|       |	float m_fRadius;
  119|       |};
  120|       |
  121|       |//
  122|       |// Torus
  123|       |//
  124|       |class Torus : public Geometry
  125|       |{
  126|       |public:
  127|      1|	Torus () {
  128|      1|		R = 1.; r = 0.2;
  129|      1|		m_pAABox = NULL;
  130|      1|	};
  131|      0|	Torus (float _R, float _r) {
  132|      0|		R = _R;
  133|      0|		r = _r;
  134|      0|		m_pAABox = NULL;
  135|      0|	};
  136|      0|	~Torus () { if (m_pAABox) delete m_pAABox; };
  137|       |
  138|       |	// intersections
  139|       |	virtual int GetIntersectionWithRay (vec3 o, vec3 d, float *_t, vec3 i, vec3 n);
  140|       |	virtual int GetIntersectionWithSegment (vec3 vStart, vec3 vEnd, float *_t, vec3 i, vec3 n);
  141|       |
  142|  3.10k|	virtual void* GetMaterial (void) { return NULL; };
  143|       |
  144|       |public:
  145|       |	float R, r;
  146|       |};
  147|       |
  148|       |//
  149|       |// triangle
  150|       |//
  151|       |class Triangle : public Geometry
  152|       |{
  153|       |public:
  154|  75.7k|	Triangle () {
  155|   303k|		for (int i=0; i<3; i++)
  156|   227k|			vec3_init (m_v[i], 0., 0., 0.);
  157|  75.7k|		m_pAABox = NULL;
  158|  75.7k|	};
  159|  75.7k|	~Triangle () { if (m_pAABox) delete m_pAABox; };
  160|       |
  161|       |	inline void SetVertex (int i, float x, float y, float z)
  162|      6|	{
  163|      6|		vec3_init (m_v[i], x, y, z);
  164|      6|		if (m_pAABox)
  165|      4|			m_pAABox->AddVertex (x, y, z);
  166|      2|		else
  167|      2|			m_pAABox = new AABox (x, y, z);
  168|      6|	}
  169|       |	void Init (float x1, float y1, float z1,
  170|       |			   float x2, float y2, float z2,
  171|       |			   float x3, float y3, float z3)
  172|  3.02M|	{
  173|  3.02M|		vec3_init (m_v[0], x1, y1, z1);
  174|  3.02M|		vec3_init (m_v[1], x2, y2, z2);
  175|  3.02M|		vec3_init (m_v[2], x3, y3, z3);
  176|  3.02M|		if (m_pAABox)
  177|  2.94M|			delete m_pAABox;
  178|  3.02M|		m_pAABox = new AABox (x1, y1, z1);
  179|  3.02M|		m_pAABox->AddVertex (x2, y2, z2);
  180|  3.02M|		m_pAABox->AddVertex (x3, y3, z3);
  181|  3.02M|	}
  182|       |
  183|       |	// intersections
  184|       |	virtual int GetIntersectionWithRay (vec3 o, vec3 d, float *_t, vec3 i, vec3 n);
  185|       |	virtual int GetIntersectionWithSegment (vec3 vStart, vec3 vEnd, float *_t, vec3 i, vec3 n);
  186|       |
  187|      0|	virtual void* GetMaterial (void) { return NULL; };
  188|       |
  189|       |public:
  190|       |	vec3 m_v[3];
  191|       |};

/workspaces/cg/src/cgmath/line.h:
    1|       |#ifndef __LINE_H__
    2|       |#define __LINE_H__
    3|       |
    4|       |#include <stdio.h>
    5|       |#include <string.h>
    6|       |#include <math.h>
    7|       |#include <assert.h>
    8|       |
    9|       |#include "TVector3.h"
   10|       |
   11|       |#include "lineintersect_utils.h"
   12|       |
   13|       |enum line_type {LINE_POINT_DIRECTION, LINE_PLUECKER};
   14|       |
   15|       |class Line;
   16|       |
   17|       |/**
   18|       |* class LineImpl
   19|       |*/
   20|       |class LineImpl
   21|       |{
   22|       |public:
   23|       |
   24|       |	// fit
   25|       |	virtual void fit (Vector3f *array, int n) = 0;
   26|       |	virtual void fit (Line **array, int n) = 0;
   27|       |
   28|       |	// getters setters
   29|       |	virtual void get_direction (Vector3f &dir) = 0;
   30|       |	virtual void get_direction (double &x, double &y, double &z) = 0;
   31|       |	virtual void get_point (Vector3f &pt) = 0;
   32|       |	virtual void get_point (double &x, double &y, double &z) = 0;
   33|       |
   34|       |	// Projections on planes
   35|       |	virtual void projection_on_oxy (void) = 0;
   36|       |
   37|       |	// position
   38|       |	virtual int get_position_with (Line* line) = 0;
   39|       |
   40|       |	// distances
   41|       |	virtual double distance_with (Line &line) = 0;
   42|       |	virtual double distance_with (Vector3f &v) = 0;
   43|       |	virtual	void   closest_point (Vector3f &pt, Vector3f &pt_on_line) = 0;
   44|       |	virtual void   init_shortest_distance (Line* line1, Line* line2) = 0;
   45|       |
   46|       |	// dump
   47|       |	virtual void dump (void) = 0;
   48|       |
   49|       |protected:
   50|      0|	LineImpl (){};
   51|       |};
   52|       |
   53|       |class LineImplPointDirection;
   54|       |class LineImplPluecker;
   55|       |
   56|       |/**
   57|       |* Implement the line with a point and a direction
   58|       |*/
   59|       |class LineImplPointDirection : public LineImpl
   60|       |{
   61|       |	friend class LineImplPluecker;
   62|       |
   63|       |public:
   64|       |
   65|       |	// constructors & destructor
   66|       |	LineImplPointDirection ();
   67|       |	LineImplPointDirection (double par_pt_x, double par_pt_y, double par_pt_z,
   68|       |							double par_dir_x, double par_dir_y, double par_dir_z);
   69|       |	LineImplPointDirection (Vector3f par_pt, Vector3f par_dir);
   70|       |	LineImplPointDirection (const LineImplPluecker &par_linePluecker);
   71|       |	~LineImplPointDirection ();
   72|       |
   73|       |	// fit
   74|       |	virtual void fit (Vector3f *array, int n);
   75|       |	virtual void fit (Line **lines, int n);
   76|       |
   77|       |	// getters setters
   78|       |	virtual void get_direction (Vector3f &dir);
   79|       |	virtual void get_direction (double &x, double &y, double &z);
   80|       |	virtual void get_point (Vector3f &pt);
   81|       |	virtual void get_point (double &x, double &y, double &z);
   82|       |
   83|       |	// Projections on planes
   84|       |	virtual void projection_on_oxy (void);
   85|       |
   86|       |	// position
   87|       |	virtual int get_position_with (Line* line);
   88|       |
   89|       |	// distances
   90|       |	virtual double distance_with (Line &line);
   91|       |	virtual double distance_with (Vector3f &pt);
   92|       |	virtual	void   closest_point (Vector3f &pt, Vector3f &pt_on_line);
   93|       |	virtual void   init_shortest_distance (Line* line1, Line* line2);
   94|       |
   95|       |	// dump
   96|       |	virtual void dump (void);
   97|       |
   98|       |private:
   99|       |	Vector3f m_pt, m_dir;
  100|       |};
  101|       |
  102|       |/**
  103|       |* Implement the rotation with Pluecker coordinates
  104|       |*
  105|       |*/
  106|       |class LineImplPluecker : public LineImpl
  107|       |{
  108|       |	friend class LineImplPointDirection;
  109|       |
  110|       |public:
  111|       |
  112|       |	// constructors & destructor
  113|       |	LineImplPluecker ();
  114|       |	LineImplPluecker (double par_l1, double par_l2, double par_l3,
  115|       |					  double par_l4, double par_l5, double par_l6);
  116|       |	LineImplPluecker (const LineImplPointDirection &par_linePointDirection);
  117|       |	~LineImplPluecker ();
  118|       |
  119|       |	// fit
  120|       |	virtual void fit (Vector3f *array, int n);
  121|       |	virtual void fit (Line **lines, int n);
  122|       |
  123|       |	// getters setters
  124|       |	virtual void get_direction (Vector3f &dir);
  125|       |	virtual void get_direction (double &x, double &y, double &z);
  126|       |	virtual void get_point (Vector3f &pt);
  127|       |	virtual void get_point (double &x, double &y, double &z);
  128|       |
  129|       |	// Projections on planes
  130|       |	virtual void projection_on_oxy (void);
  131|       |
  132|       |	// position
  133|       |	virtual int get_position_with (Line* line);
  134|       |
  135|       |	// distances
  136|       |	virtual double distance_with (Line &line);
  137|       |	virtual double distance_with (Vector3f &pt);
  138|       |	virtual	void   closest_point (Vector3f &pt, Vector3f &pt_on_line);
  139|       |	virtual void   init_shortest_distance (Line* line1, Line* line2);
  140|       |
  141|       |	// dump
  142|       |	virtual void dump (void);
  143|       |
  144|       |private:
  145|       |	double m_l1, m_l2, m_l3, m_l4, m_l5, m_l6;
  146|       |};
  147|       |
  148|       |
  149|       |/**
  150|       |* class Cline
  151|       |*/
  152|       |class Line
  153|       |{
  154|       |	friend class LineImplPointDirection;
  155|       |	friend class LineImplPluecker;
  156|       |
  157|       |public:
  158|       |	/**
  159|       |	*	@name Constructor
  160|       |	*/
  161|       |	//@{
  162|       |	Line (line_type par_type = LINE_POINT_DIRECTION);//!< constructor
  163|       |	//@}
  164|       |
  165|       |	/**
  166|       |	*	@name Initialization
  167|       |	*/
  168|       |	//@{
  169|       |	void init_point_direction (double pt_x, double pt_y, double pt_z,
  170|       |				   double dir_x, double dir_y, double dir_z);	//!< initialize a LINE_POINT_DIRECTION
  171|       |	void init_point_direction (Vector3f par_pt, Vector3f par_dir);		//!< initialize a LINE_POINT_DIRECTION
  172|       |	void init_point_point (double pt1_x, double pt1_y, double pt1_z,
  173|       |						   double pt2_x, double pt2_y, double pt2_z);		//!< initialize a LINE_POINT_DIRECTION
  174|       |	void init_point_point (Vector3f point1, Vector3f point2);				//!< initialize a LINE_POINT_DIRECTION
  175|       |	void init_pluecker (double l1, double l2, double l3,
  176|       |						double l4, double l5, double l6);					//!< initialize a LINE_PLUECKER
  177|       |	void init_shortest_distance (Line* line1, Line* line2);				//!< initialize the line with the shortest length between the two lines
  178|       |	//@}
  179|       |
  180|       |	/**
  181|       |	*	@name Getters / setters
  182|       |	*/
  183|       |	//@{
  184|       |	void get_point (Vector3f &pt);							//!< get a point belonging to the line
  185|       |	void get_point (double &x, double &y, double &z);		//!< get a point belonging to the line
  186|       |	void get_direction (Vector3f &dir);					//!< get the direction of the line
  187|       |	void get_direction (double &x, double &y, double &z);	//!< get the direction of the line
  188|       |	//@}
  189|       |
  190|       |	/**
  191|       |	*	@name Distances
  192|       |	*/
  193|       |	//@{
  194|       |	double	distance_with (Line &line);	//!< distance between the line and another line
  195|       |	double	distance_with (Vector3f &pt);	//!< distance between the line and a point
  196|       |	void	closest_point (Vector3f &pt, Vector3f &pt_on_line); //!< compute the closest point from the line
  197|       |	//@}
  198|       |
  199|       |	/**
  200|       |	*	@name Projections
  201|       |	*/
  202|       |	//@{
  203|       |	void projection_on_oxy (void);
  204|       |	//@}
  205|       |
  206|       |	/**
  207|       |	*	@name Fitting
  208|       |	*/
  209|       |	//@{
  210|       |	void fit (Vector3d *array, int n);
  211|       |	void fit (Vector3f *array, int n);
  212|       |	void fit (Line **lines, int n);
  213|       |	//@}
  214|       |
  215|       |	/**
  216|       |	*	@name Misc
  217|       |	*/
  218|       |	//@{
  219|       |	int  convert (line_type par_type); //!< conversion between the different representations of a line
  220|       |	bool is_colinear_with (Line* line, float epsilon); //!< colinearity
  221|       |	int  get_position_with (Line* line); //!< position
  222|       |	void dump (void); //!<dump
  223|       |	//@}
  224|       |
  225|       |protected:
  226|       |	LineImpl* m_lineImpl;
  227|       |	line_type m_line_type;
  228|       |};
  229|       |
  230|       |#endif // __LINE_H__
  231|       |

/workspaces/cg/src/cgmath/plane.cpp:
    1|       |#include <assert.h>
    2|       |#include <stdio.h>
    3|       |#include <math.h>
    4|       |
    5|       |#include "geometry.h"
    6|       |#include "TMatrix3.h"
    7|       |
    8|       |//
    9|       |// Constructors
   10|       |//
   11|       |Plane::Plane ()
   12|      2|{
   13|      2|	normale.Set(0., 0., 1.);
   14|      2|	distance = 0.;
   15|      2|	m_pAABox = NULL;
   16|      2|}
   17|       |
   18|       |Plane::Plane (Vector3f _normale, float _distance)
   19|      0|{
   20|      0|  normale.Set (_normale.x, _normale.y, _normale.z);
   21|      0|  distance = _distance;
   22|      0|  m_pAABox = NULL;
   23|      0|}
   24|       |
   25|       |Plane::Plane (Vector3f v1, Vector3f v2, Vector3f v3)
   26|      0|{
   27|      0|  normale.Set (v1.y*(v2.z-v3.z)+v2.y*(v3.z-v1.z)+v3.y*(v1.z-v2.z),
   28|      0|		v1.z*(v2.x-v3.x)+v2.z*(v3.x-v1.x)+v3.z*(v1.x-v2.x),
   29|      0|		v1.x*(v2.y-v3.y)+v2.x*(v3.y-v1.y)+v3.x*(v1.z-v2.y));
   30|      0|  normale.Normalize ();
   31|       |  
   32|      0|  distance = -normale.x*v1.x - normale.y*v1.y - normale.z*v1.z;
   33|      0|  m_pAABox = NULL;
   34|      0|}
   35|       |
   36|       |Plane::Plane (Vector3f _pt, Vector3f _normale)
   37|      0|{
   38|      0|  normale = _normale;
   39|      0|  normale.Normalize ();
   40|      0|  distance = - (normale * _pt);
   41|      0|  m_pAABox = NULL;
   42|      0|}
   43|       |
   44|       |// distance between the plane and a point
   45|       |float Plane::distance_point (float x, float y, float z)
   46|      0|{
   47|      0|  return normale.x*x + normale.y*y + normale.z*z + distance;
   48|      0|}
   49|       |
   50|       |// distance between the plane and a point
   51|       |float Plane::distance_point (Vector3f v)
   52|      0|{
   53|      0|	return distance_point (v.x, v.y, v.z);
   54|      0|}
   55|       |
   56|       |// position of a point
   57|       |int Plane::position (Vector3f v)
   58|      0|{
   59|      0|	float d = distance_point (v);
   60|      0|	if (d == 0.0)
   61|      0|		return 0;
   62|      0|	if (d > 0)
   63|      0|		return 1;
   64|      0|	else
   65|      0|		return -1;
   66|      0|}
   67|       |
   68|       |// projection of a point on the plane
   69|       |void Plane::projected (Vector3f res, Vector3f v)
   70|      0|{
   71|      0|  float d = distance_point (v);
   72|      0|  res.Set (v.x - d * normale.x, v.y - d * normale.y, v.z - d * normale.z);
   73|      0|}
   74|       |
   75|       |// move a point in the direction of the normale to let it at a distance d from the plane
   76|       |void
   77|       |Plane::move (Vector3f res, Vector3f v, float d)
   78|      0|{
   79|      0|	float dist = distance_point (v);
   80|      0|	res.Set (v.x + (d - dist) * normale.x,
   81|      0|		v.y + (d - dist) * normale.y,
   82|      0|		v.z + (d - dist) * normale.z);
   83|      0|}
   84|       |
   85|       |//
   86|       |// getters
   87|       |//
   88|       |float Plane::get_distance (void)
   89|      0|{
   90|      0|  return distance;
   91|      0|}
   92|       |
   93|       |void Plane::get_normale (Vector3f &_normale)
   94|      0|{
   95|      0|  _normale.Set (normale.x, normale.y, normale.z);
   96|      0|}
   97|       |
   98|       |/* least square plane fitting */
   99|       |/*
  100|       | * Reference : Eberly "Game Engine Design",
  101|       | *             Morgan Kaufmann, ISBN 1558605932
  102|       | *             september, 2000
  103|       | *             pp 473, 474 + code
  104|       | */
  105|       |void Plane::fitting (Vector3f *array, int n)
  106|      0|{
  107|      0|  Vector3f p;
  108|      0|  Vector3f vector_walk;
  109|      0|  int i;
  110|       |  
  111|      0|  float XX = 0.;
  112|      0|  float XY = 0.;
  113|      0|  float XZ = 0.;
  114|      0|  float YY = 0.;
  115|      0|  float YZ = 0.;
  116|      0|  float ZZ = 0.;
  117|       |
  118|       |  // average of points
  119|      0|  p.Set (0.0, 0.0, 0.0);
  120|      0|  for (i=0; i<n; i++) p += array[i];
  121|      0|  p.x /= n;
  122|      0|  p.y /= n;
  123|      0|  p.z /= n;
  124|      0|  distance = sqrt (p*p);
  125|       |
  126|       |  // sums of products
  127|      0|  vector_walk.Set (0.0, 0.0, 0.0);
  128|      0|  for (i=0; i<n; i++)
  129|      0|    {
  130|      0|      vector_walk = array[i] - p;
  131|      0|      XX += vector_walk.x * vector_walk.x;
  132|      0|      XY += vector_walk.x * vector_walk.y;
  133|      0|      XZ += vector_walk.x * vector_walk.z;
  134|      0|      YY += vector_walk.y * vector_walk.y;
  135|      0|      YZ += vector_walk.y * vector_walk.z;
  136|      0|      ZZ += vector_walk.z * vector_walk.z;
  137|      0|    }
  138|       |  
  139|       |  // setup the eigensolver
  140|      0|  Matrix3f m (XX, XY, XZ,
  141|      0|	      XY, YY, YZ,
  142|      0|	      XZ, YZ, ZZ);
  143|      0|  Vector3f e1, e2, e3, v;
  144|      0|  m.SolveEigensystem (e1, e2, e3, v);
  145|      0|  normale = e3;
  146|      0|  normale.Normalize ();
  147|       |
  148|       |  /* the minimum energy */
  149|       |  // return eigen value (2);
  150|      0|}
  151|       |
  152|       |
  153|       |
  154|       |
  155|       |
  156|       |
  157|       |
  158|       |
  159|       |
  160|       |
  161|       |
  162|       |
  163|       |//
  164|       |//
  165|       |//
  166|       |int Plane::GetIntersectionWithRay (vec3 vO, vec3 vD, float *_t, vec3 i, vec3 n)
  167|      0|{
  168|      0|	float a = normale[0];
  169|      0|	float b = normale[1];
  170|      0|	float c = normale[2];
  171|      0|	float d = distance;
  172|       |
  173|      0|	float t = - (d+a*vO[0]+b*vO[1]+c*vO[2]) / (a*vD[0]+b*vD[1]+c*vD[2]);
  174|      0|	if (t < 0.)
  175|      0|		return 0;
  176|      0|	*_t = t;
  177|       |
  178|      0|	i[0] = vO[0] + t*vD[0];
  179|      0|	i[1] = vO[1] + t*vD[1];
  180|      0|	i[2] = vO[2] + t*vD[2];
  181|       |
  182|      0|	n[0] = a;
  183|      0|	n[1] = b;
  184|      0|	n[2] = c;
  185|       |
  186|      0|	return 1;
  187|      0|}
  188|       |
  189|       |int Plane::GetIntersectionWithSegment (vec3 vStart, vec3 vEnd, float *_t, vec3 i, vec3 n)
  190|      0|{
  191|      0|	vec3 vDirection;
  192|      0|	vDirection[0] = vEnd[0] - vStart[0];
  193|      0|	vDirection[1] = vEnd[1] - vStart[1];
  194|      0|	vDirection[2] = vEnd[2] - vStart[2];
  195|      0|	float l = sqrt (vec3_dot_product (vDirection, vDirection));
  196|      0|	vec3_normalize (vDirection);
  197|      0|	unsigned int res = GetIntersectionWithRay (vStart, vDirection, _t, i, n);
  198|      0|	return (res && *_t < l);
  199|      0|}

/workspaces/cg/src/cgmath/polynomial_herbison-evans.cpp:
    1|       |/*
    2|       |* http://tog.acm.org/resources/GraphicsGems/category.html
    3|       |* Herbison-Evans, Don, Solving Quartics and Cubics for Graphics, Graphics Gems V, p. 3-15, code: ch1-1/
    4|       |* http://tog.acm.org/resources/GraphicsGems/gemsv/ch1-1/quarcube.c
    5|       |*/
    6|       |
    7|       |
    8|       |
    9|       |/*
   10|       |   doquartic.c
   11|       |
   12|       |   a test of a quartic solving routine
   13|       |
   14|       |   Don Herbison-Evans   24 June 1994
   15|       |*/
   16|       |
   17|       |#include <stdio.h>
   18|       |#include <math.h>
   19|       |
   20|       |static double nought;
   21|       |static double doub1,doub2;
   22|       |static double doub3,doub4;
   23|       |static double doub6,doub12;
   24|       |static double doub24;
   25|       |static double doubmax;       /* approx square root of max double number */
   26|       |static double doubmin;       /* smallest double number */
   27|       |static double doubtol;       /* tolerance of double numbers */
   28|       |static double rt3;
   29|       |static double inv2,inv3,inv4;
   30|       |
   31|       |void setcns();
   32|       |int descartes(double a,double b,double c,double d,double rts[4]);
   33|       |//double exp(),log(),sqrt(),cos(),acos();
   34|       |double cubic(double p,double q,double r);
   35|       |double acos3(double x);
   36|       |double curoot(double x);
   37|       |int qudrtc(double b,double c,double rts[4],double dis);
   38|       |int quartic(double a,double b,double c,double d,double rts[4],double rterr[4]);
   39|       |int ferrari(double a,double b,double c,double d,double rts[4]);
   40|       |int neumark(double a,double b,double c,double d,double rts[4]);
   41|       |void errors(double a,double b,double c,double d,double rts[4],double rterr[4],int nrts);
   42|       |
   43|       |/*
   44|       |main()
   45|       |{
   46|       |   double a,b,c,d;
   47|       |   double rts[4];
   48|       |   double rterr[4];
   49|       |   int nr;
   50|       |
   51|       |   setcns();
   52|       |   a = -(double)10;
   53|       |   b = (double)35;
   54|       |   c = -(double)50;
   55|       |   d = (double)24;
   56|       |   nr = descartes(a,b,c,d,rts);
   57|       |   errors(a,b,c,d,rts,rterr,nr);
   58|       |   nr = ferrari(a,b,c,d,rts);
   59|       |   errors(a,b,c,d,rts,rterr,nr);
   60|       |   nr = neumark(a,b,c,d,rts);
   61|       |   errors(a,b,c,d,rts,rterr,nr);
   62|       |   exit(0);
   63|       |}
   64|       |*/
   65|       |/****************************************************/
   66|       |
   67|       |void setcns()
   68|       |/* 
   69|       |     set up constants 
   70|       |*/
   71|  16.3k|{
   72|  16.3k|      int j;
   73|       |
   74|  16.3k|      nought = (double)0;
   75|  16.3k|      doub1 = (double)1;
   76|  16.3k|      doub2 = (double)2;
   77|  16.3k|      doub3 = (double)3;
   78|  16.3k|      doub4 = (double)4;
   79|  16.3k|      doub6 = (double)6;
   80|  16.3k|      doub12 = (double)12;
   81|  16.3k|      doub24 = (double)24;
   82|  16.3k|      inv2 = doub1/(double)2;
   83|  16.3k|      inv3 = doub1/(double)3;
   84|  16.3k|      inv4 = doub1/(double)4;
   85|  16.3k|      rt3 = sqrt(doub3) ;
   86|       |
   87|  16.3k|      doubtol = doub1;
   88|   884k|      for (  j = 1 ; doub1+doubtol > doub1 ; ++ j )
   89|   868k|      {
   90|   868k|          doubtol *= inv2;
   91|   868k|      }
   92|  16.3k|      doubtol = sqrt(doubtol);
   93|       |
   94|  16.3k|      doubmin = inv2 ;
   95|   163k|      for (  j = 1 ; j <= 100 ; ++ j )
   96|   163k|      {
   97|   163k|          doubmin=doubmin*doubmin ;
   98|   163k|          if ((doubmin*doubmin) <= (doubmin*doubmin*inv2))
   99|  16.3k|              break;
  100|   163k|      }
  101|  16.3k|      doubmax=0.7/sqrt(doubmin) ;
  102|       |
  103|  16.3k|} /* setcns */
  104|       |/***********************************/
  105|       |
  106|       |int quartic(double a,double b,double c,double d,double rts[4],double rterr[4])
  107|       |/*
  108|       |   Solve quartic equation using either
  109|       |   quadratic, Ferrari's or Neumark's algorithm.
  110|       |
  111|       |   called by 
  112|       |   calls  qudrtc, ferrari, neumark.
  113|       |
  114|       |     21 Jan 1989  Don Herbison-Evans
  115|       |*/
  116|  16.3k|{
  117|  16.3k|setcns ();
  118|       |
  119|       |   //int qudrtc(),ferrari(),neumark();
  120|  16.3k|   int j,k,nq,nr;
  121|  16.3k|   double odd, even;
  122|  16.3k|   double roots[4];
  123|       |
  124|  16.3k|   if (a < nought) odd = -a; else odd = a;
  125|  16.3k|   if (c < nought) odd -= c; else odd += c;
  126|  16.3k|   if (b < nought) even = -b; else even = b;
  127|  16.3k|   if (d < nought) even -= d; else even += d;
  128|  16.3k|   if (odd < even*doubtol)
  129|      0|   {
  130|      0|      nq = qudrtc(b,d,roots,b*b-doub4*d);
  131|      0|      j = 0;
  132|      0|      for (k = 0; k < nq; ++k)
  133|      0|      {
  134|      0|         if (roots[k] > nought)
  135|      0|         {
  136|      0|            rts[j] = sqrt(roots[k]);
  137|      0|            rts[j+1] = -rts[j];
  138|      0|            ++j; ++j;
  139|      0|         }
  140|      0|      }
  141|      0|      nr = j;
  142|      0|   }
  143|  16.3k|   else
  144|  16.3k|   {
  145|  16.3k|      if (a < nought) k = 1; else k = 0;
  146|  16.3k|      if (b < nought) k += k+1; else k +=k; 
  147|  16.3k|      if (c < nought) k += k+1; else k +=k; 
  148|  16.3k|      if (d < nought) k += k+1; else k +=k; 
  149|  16.3k|      switch (k)
  150|  16.3k|      {
  151|      0|              case 0 : nr = ferrari(a,b,c,d,rts) ; break;
  152|      0|              case 1 : nr = neumark(a,b,c,d,rts) ; break;
  153|      0|              case 2 : nr = neumark(a,b,c,d,rts) ; break;
  154|      0|              case 3 : nr = ferrari(a,b,c,d,rts) ; break;
  155|      0|              case 4 : nr = ferrari(a,b,c,d,rts) ; break;
  156|      0|              case 5 : nr = neumark(a,b,c,d,rts) ; break;
  157|      0|              case 6 : nr = ferrari(a,b,c,d,rts) ; break;
  158|      0|              case 7 : nr = ferrari(a,b,c,d,rts) ; break;
  159|      0|              case 8 : nr = neumark(a,b,c,d,rts) ; break;
  160|      0|              case 9 : nr = ferrari(a,b,c,d,rts) ; break;
  161|  16.3k|              case 10 : nr = ferrari(a,b,c,d,rts) ; break;
  162|      0|              case 11 : nr = neumark(a,b,c,d,rts) ; break;
  163|      0|              case 12 : nr = ferrari(a,b,c,d,rts) ; break;
  164|      0|              case 13 : nr = ferrari(a,b,c,d,rts) ; break;
  165|      0|              case 14 : nr = ferrari(a,b,c,d,rts) ; break;
  166|      0|              case 15 : nr = ferrari(a,b,c,d,rts) ; break;
  167|  16.3k|      }
  168|  16.3k|   }
  169|  16.3k|   errors(a,b,c,d,rts,rterr,nr);
  170|  16.3k|   return(nr);
  171|  16.3k|} /* quartic */
  172|       |/*****************************************/
  173|       |
  174|       |int ferrari(double a,double b,double c,double d,double rts[4])
  175|       |/* 
  176|       |     solve the quartic equation - 
  177|       |
  178|       |   x**4 + a*x**3 + b*x**2 + c*x + d = 0 
  179|       |
  180|       |   called by quartic
  181|       |   calls     cubic, qudrtc.
  182|       |
  183|       |     input - 
  184|       |   a,b,c,e - coeffs of equation. 
  185|       |
  186|       |     output - 
  187|       |   nquar - number of real roots. 
  188|       |   rts - array of root values. 
  189|       |
  190|       |     method :  Ferrari - Lagrange
  191|       |     Theory of Equations, H.W. Turnbull p. 140 (1947)
  192|       |
  193|       |     calls  cubic, qudrtc 
  194|       |*/
  195|  16.3k|{
  196|       |	//double cubic();
  197|       |	//int qudrtc();
  198|       |
  199|  16.3k|   int nquar,n1,n2 ;
  200|  16.3k|   double asq,ainv2;
  201|  16.3k|   double v1[4],v2[4] ;
  202|  16.3k|   double p,q,r ;
  203|  16.3k|   double y;
  204|  16.3k|   double e,f,esq,fsq,ef ;
  205|  16.3k|   double g,gg,h,hh;
  206|       |
  207|       |   //fprintf(stderr,"\nFerrari %g %g %g %g\n",a,b,c,d);
  208|  16.3k|   asq = a*a;
  209|       |
  210|  16.3k|   p = b ;
  211|  16.3k|   q = a*c-doub4*d ;
  212|  16.3k|   r = (asq - doub4*b)*d + c*c ;
  213|  16.3k|   y = cubic(p,q,r) ;
  214|       |
  215|  16.3k|   esq = inv4*asq - b - y;
  216|  16.3k|   if (esq < nought) return(0);
  217|  16.3k|   else
  218|  16.3k|   {
  219|  16.3k|      fsq = inv4*y*y - d;
  220|  16.3k|      if (fsq < nought) return(0);
  221|  16.3k|      else
  222|  16.3k|      {
  223|  16.3k|         ef = -(inv4*a*y + inv2*c);
  224|  16.3k|         if ( ((a > nought)&&(y > nought)&&(c > nought))
  225|  16.3k|           || ((a > nought)&&(y < nought)&&(c < nought))
  226|  16.3k|           || ((a < nought)&&(y > nought)&&(c < nought))
  227|  16.3k|           || ((a < nought)&&(y < nought)&&(c > nought))
  228|  16.3k|           ||  (a == nought)||(y == nought)||(c == nought)
  229|  16.3k|         )
  230|       |/* use ef - */
  231|      0|         {
  232|      0|            if ((b < nought)&&(y < nought)&&(esq > nought))
  233|      0|            {
  234|      0|               e = sqrt(esq);
  235|      0|               f = ef/e;
  236|      0|            }
  237|      0|            else if ((d < nought) && (fsq > nought))
  238|      0|            {
  239|      0|               f = sqrt(fsq);
  240|      0|               e = ef/f;
  241|      0|            }
  242|      0|            else
  243|      0|            {
  244|      0|               e = sqrt(esq);
  245|      0|               f = sqrt(fsq);
  246|      0|               if (ef < nought) f = -f;
  247|      0|            }
  248|      0|         }
  249|  16.3k|         else
  250|  16.3k|         {
  251|  16.3k|            e = sqrt(esq);
  252|  16.3k|            f = sqrt(fsq);
  253|  16.3k|            if (ef < nought) f = -f;
  254|  16.3k|         }
  255|       |/* note that e >= nought */
  256|  16.3k|         ainv2 = a*inv2;
  257|  16.3k|         g = ainv2 - e;
  258|  16.3k|         gg = ainv2 + e;
  259|  16.3k|         if ( ((b > nought)&&(y > nought))
  260|  16.3k|           || ((b < nought)&&(y < nought)) )
  261|      0|         {
  262|      0|            if (( a > nought) && (e != nought)) g = (b + y)/gg;
  263|      0|               else if (e != nought) gg = (b + y)/g;
  264|      0|         }
  265|  16.3k|         if ((y == nought)&&(f == nought))
  266|      0|         {
  267|      0|            h = nought;
  268|      0|            hh = nought;
  269|      0|         }
  270|  16.3k|         else if ( ((f > nought)&&(y < nought))
  271|  16.3k|                || ((f < nought)&&(y > nought)) )
  272|     13|         {
  273|     13|            hh = -inv2*y + f;
  274|     13|            h = d/hh;
  275|     13|         }
  276|  16.3k|         else
  277|  16.3k|         {
  278|  16.3k|            h = -inv2*y - f;
  279|  16.3k|            hh = d/h;
  280|  16.3k|         }
  281|  16.3k|         n1 = qudrtc(gg,hh,v1, gg*gg - doub4*hh) ;
  282|  16.3k|         n2 = qudrtc(g,h,v2, g*g - doub4*h) ;
  283|  16.3k|         nquar = n1+n2 ;
  284|  16.3k|         rts[0] = v1[0] ;
  285|  16.3k|         rts[1] = v1[1] ;
  286|  16.3k|         rts[n1+0] = v2[0] ;
  287|  16.3k|         rts[n1+1] = v2[1] ;
  288|  16.3k|         return(nquar);
  289|  16.3k|      }
  290|  16.3k|   }
  291|  16.3k|} /* ferrari */
  292|       |/*****************************************/
  293|       |
  294|       |int neumark(double a,double b,double c,double d,double rts[4])
  295|       |/* 
  296|       |     solve the quartic equation - 
  297|       |
  298|       |   x**4 + a*x**3 + b*x**2 + c*x + d = 0 
  299|       |
  300|       |   called by quartic
  301|       |   calls     cubic, qudrtc.
  302|       |
  303|       |     input parameters - 
  304|       |   a,b,c,e - coeffs of equation. 
  305|       |
  306|       |     output parameters - 
  307|       |   nquar - number of real roots. 
  308|       |   rts - array of root values. 
  309|       |
  310|       |     method -  S. Neumark 
  311|       |
  312|       |     Solution of Cubic and Quartic Equations - Pergamon 1965 
  313|       |        translated to C with help of Shawn Neely
  314|       |
  315|       |*/
  316|      0|{
  317|      0|   int nquar,n1,n2 ;
  318|      0|   double y,g,gg,h,hh,gdis,gdisrt,hdis,hdisrt,g1,g2,h1,h2 ;
  319|      0|   double bmy,gerr,herr,y4,d4,bmysq ;
  320|      0|   double v1[4],v2[4] ;
  321|      0|   double asq ;
  322|      0|   double p,q,r ;
  323|      0|   double hmax,gmax ;
  324|       |   //double cubic();
  325|       |   //int qudrtc();
  326|       |
  327|       |   //fprintf(stderr,"\nNeumark %g %g %g %g\n",a,b,c,d);
  328|      0|   asq = a*a ;
  329|       |
  330|      0|   p =  -b*doub2 ;
  331|      0|   q = b*b + a*c - doub4*d ;
  332|      0|   r = (c - a*b)*c + asq*d ;
  333|      0|   y = cubic(p,q,r) ;
  334|       |
  335|      0|   bmy = b - y ;
  336|      0|   y4 = y*doub4 ;
  337|      0|   d4 = d*doub4 ;
  338|      0|   bmysq = bmy*bmy ;
  339|      0|   gdis = asq - y4 ;
  340|      0|   hdis = bmysq - d4 ;
  341|      0|   if ((gdis < nought) || (hdis < nought)) return(0);
  342|      0|   else
  343|      0|   {
  344|      0|      g1 = a*inv2 ;
  345|      0|      h1 = bmy*inv2 ;
  346|      0|      gerr = asq + y4 ;
  347|      0|      herr = hdis ;
  348|      0|      if (d > nought) herr = bmysq + d4 ;
  349|      0|      if ((y < nought) || (herr*gdis > gerr*hdis))
  350|      0|      {
  351|      0|         gdisrt = sqrt(gdis) ;
  352|      0|         g2 = gdisrt*inv2 ;
  353|      0|         if (gdisrt != nought) h2 = (a*h1 - c)/gdisrt ;
  354|      0|            else h2 = nought;
  355|      0|      }
  356|      0|      else
  357|      0|      {
  358|      0|         hdisrt = sqrt(hdis) ;
  359|      0|         h2 = hdisrt*inv2 ;
  360|      0|         if (hdisrt != nought) g2 = (a*h1 - c)/hdisrt ;
  361|      0|            else g2 = nought;
  362|      0|      }
  363|       |/* 
  364|       |     note that in the following, the tests ensure non-zero 
  365|       |     denominators -  
  366|       |*/
  367|      0|      h = h1 - h2 ;
  368|      0|      hh = h1 + h2 ;
  369|      0|      hmax = hh ;
  370|      0|      if (hmax < nought) hmax =  -hmax ;
  371|      0|      if (hmax < h) hmax = h ;
  372|      0|      if (hmax <  -h) hmax =  -h ;
  373|      0|      if ((h1 > nought)&&(h2 > nought)) h = d/hh ;
  374|      0|      if ((h1 < nought)&&(h2 < nought)) h = d/hh ;
  375|      0|      if ((h1 > nought)&&(h2 < nought)) hh = d/h ;
  376|      0|      if ((h1 < nought)&&(h2 > nought)) hh = d/h ;
  377|      0|      if (h > hmax) h = hmax ;
  378|      0|      if (h <  -hmax) h =  -hmax ;
  379|      0|      if (hh > hmax) hh = hmax ;
  380|      0|      if (hh <  -hmax) hh =  -hmax ;
  381|       |
  382|      0|      g = g1 - g2 ;
  383|      0|      gg = g1 + g2 ;
  384|      0|      gmax = gg ;
  385|      0|      if (gmax < nought) gmax =  -gmax ;
  386|      0|      if (gmax < g) gmax = g ;
  387|      0|      if (gmax <  -g) gmax =  -g ;
  388|      0|      if ((g1 > nought)&&(g2 > nought)) g = y/gg ;
  389|      0|      if ((g1 < nought)&&(g2 < nought)) g = y/gg ;
  390|      0|      if ((g1 > nought)&&(g2 < nought)) gg = y/g ;
  391|      0|      if ((g1 < nought)&&(g2 > nought)) gg = y/g ;
  392|      0|      if (g > gmax) g = gmax ;
  393|      0|      if (g <  -gmax) g =  -gmax ;
  394|      0|      if (gg > gmax) gg = gmax ;
  395|      0|      if (gg <  -gmax) gg =  -gmax ;
  396|       | 
  397|      0|      n1 = qudrtc(gg,hh,v1, gg*gg - doub4*hh) ;
  398|      0|      n2 = qudrtc(g,h,v2, g*g - doub4*h) ;
  399|      0|      nquar = n1+n2 ;
  400|      0|      rts[0] = v1[0] ;
  401|      0|      rts[1] = v1[1] ;
  402|      0|      rts[n1+0] = v2[0] ;
  403|      0|      rts[n1+1] = v2[1] ;
  404|       | 
  405|      0|      return(nquar);
  406|      0|   }
  407|      0|} /* neumark */
  408|       |/****************************************************/
  409|       |
  410|       |void errors(double a,double b,double c,double d,double rts[4],double rterr[4],int nrts)
  411|       |/*
  412|       |   find the errors
  413|       |
  414|       |   called by quartic.
  415|       |*/
  416|  16.3k|{
  417|  16.3k|   int k;
  418|  16.3k|   double deriv,test;
  419|       |   //double fabs(),sqrt(),curoot();
  420|       |
  421|  16.3k|   if (nrts > 0)
  422|  3.10k|   {
  423|  12.7k|      for (  k = 0 ; k < nrts ; ++ k )
  424|  9.69k|      {
  425|  9.69k|         test = (((rts[k]+a)*rts[k]+b)*rts[k]+c)*rts[k]+d ;
  426|  9.69k|         if (test == nought) rterr[k] = nought;
  427|  9.55k|         else
  428|  9.55k|         {
  429|  9.55k|            deriv =
  430|  9.55k|               ((doub4*rts[k]+doub3*a)*rts[k]+doub2*b)*rts[k]+c ;
  431|  9.55k|            if (deriv != nought)
  432|  9.55k|               rterr[k] = fabs(test/deriv);
  433|      0|            else
  434|      0|            {
  435|      0|               deriv = (doub12*rts[k]+doub6*a)*rts[k]+doub2*b ;
  436|      0|               if (deriv != nought)
  437|      0|                   rterr[k] = sqrt(fabs(test/deriv)) ;
  438|      0|               else
  439|      0|               {
  440|      0|                  deriv = doub24*rts[k]+doub6*a ;
  441|      0|                  if (deriv != nought)
  442|      0|                     rterr[k] = curoot(fabs(test/deriv));
  443|      0|                  else
  444|      0|                     rterr[k] = sqrt(sqrt(fabs(test)/doub24));
  445|      0|               }
  446|      0|            }
  447|  9.55k|         }
  448|       |         //fprintf(stderr,"errorsa  %d %9g %9g\n",k,rts[k],rterr[k]);
  449|  9.69k|      }
  450|  3.10k|   }
  451|  13.2k|   else; //fprintf(stderr,"errors ans: none\n");
  452|  16.3k|} /* errors */
  453|       |/**********************************************/
  454|       |
  455|       |int qudrtc(double b,double c,double rts[4],double dis)
  456|       |/* 
  457|       |     solve the quadratic equation - 
  458|       |
  459|       |         x**2+b*x+c = 0 
  460|       |
  461|       |     called by  quartic, ferrari, neumark, ellcut 
  462|       |*/
  463|  32.7k|{
  464|  32.7k|   int nquad;
  465|  32.7k|   double rtdis ;
  466|       |
  467|  32.7k|   if (dis >= nought)
  468|  4.84k|   {
  469|  4.84k|      nquad = 2 ;
  470|  4.84k|      rtdis = sqrt(dis) ;
  471|  4.84k|      if (b > nought) rts[0] = ( -b - rtdis)*inv2 ;
  472|  4.84k|         else rts[0] = ( -b + rtdis)*inv2 ;
  473|  4.84k|      if (rts[0] == nought) rts[1] =  -b ;
  474|  4.84k|      else rts[1] = c/rts[0] ;
  475|  4.84k|   }
  476|  27.9k|   else
  477|  27.9k|   {
  478|  27.9k|      nquad = 0;
  479|  27.9k|      rts[0] = nought ;
  480|  27.9k|      rts[1] = nought ;
  481|  27.9k|   }
  482|  32.7k|   return(nquad);
  483|  32.7k|} /* qudrtc */
  484|       |/**************************************************/
  485|       |
  486|       |double cubic(double p,double q,double r)
  487|       |/* 
  488|       |     find the lowest real root of the cubic - 
  489|       |       x**3 + p*x**2 + q*x + r = 0 
  490|       |
  491|       |   input parameters - 
  492|       |     p,q,r - coeffs of cubic equation. 
  493|       |
  494|       |   output- 
  495|       |     cubic - a real root. 
  496|       |
  497|       |   global constants -
  498|       |     rt3 - sqrt(3) 
  499|       |     inv3 - 1/3 
  500|       |     doubmax - square root of largest number held by machine 
  501|       |
  502|       |     method - 
  503|       |     see D.E. Littlewood, "A University Algebra" pp.173 - 6 
  504|       |
  505|       |     Charles Prineas   April 1981 
  506|       |
  507|       |     called by  neumark.
  508|       |     calls  acos3 
  509|       |*/
  510|  16.3k|{
  511|  16.3k|   int nrts;
  512|  16.3k|   double po3,po3sq,qo3;
  513|  16.3k|   double uo3,u2o3,uo3sq4,uo3cu4 ;
  514|  16.3k|   double v,vsq,wsq ;
  515|  16.3k|   double m,mcube,n;
  516|  16.3k|   double muo3,s,scube,t,cosk,sinsqk ;
  517|  16.3k|   double root;
  518|       |   //double curoot();
  519|       |   //double acos3();
  520|       |   //double sqrt(),fabs();
  521|       |
  522|  16.3k|   m = nought;
  523|  16.3k|   nrts =0;
  524|  16.3k|   if ((p > doubmax) || (p <  -doubmax)) root = -p;
  525|  16.3k|   else
  526|  16.3k|   if ((q > doubmax) || (q <  -doubmax))
  527|      0|   {
  528|      0|      if (q > nought) root = -r/q;
  529|      0|      else root = -sqrt(-q);
  530|      0|   }
  531|  16.3k|   else
  532|  16.3k|   if ((r > doubmax)|| (r <  -doubmax)) root =  -curoot(r) ;
  533|  16.3k|   else
  534|  16.3k|   {
  535|  16.3k|      po3 = p*inv3 ;
  536|  16.3k|      po3sq = po3*po3 ;
  537|  16.3k|      if (po3sq > doubmax) root =  -p ;
  538|  16.3k|      else
  539|  16.3k|      {
  540|  16.3k|         v = r + po3*(po3sq + po3sq - q) ;
  541|  16.3k|         if ((v > doubmax) || (v < -doubmax)) root = -p ;
  542|  16.3k|         else
  543|  16.3k|         {
  544|  16.3k|            vsq = v*v ;
  545|  16.3k|            qo3 = q*inv3 ;
  546|  16.3k|            uo3 = qo3 - po3sq ;
  547|  16.3k|            u2o3 = uo3 + uo3 ;
  548|  16.3k|            if ((u2o3 > doubmax) || (u2o3 < -doubmax))
  549|      0|            {
  550|      0|               if (p == nought)
  551|      0|               {
  552|      0|                  if (q > nought) root =  -r/q ;
  553|      0|                  else root =  -sqrt(-q) ;
  554|      0|               }
  555|      0|               else root =  -q/p ;
  556|      0|            }
  557|  16.3k|            uo3sq4 = u2o3*u2o3 ;
  558|  16.3k|            if (uo3sq4 > doubmax)
  559|      0|            {
  560|      0|               if (p == nought)
  561|      0|               {
  562|      0|                  if (q > nought) root = -r/q ;
  563|      0|                  else root = -sqrt(fabs(q)) ;
  564|      0|               }
  565|      0|               else root = -q/p ;
  566|      0|            }
  567|  16.3k|            uo3cu4 = uo3sq4*uo3 ;
  568|  16.3k|            wsq = uo3cu4 + vsq ;
  569|  16.3k|            if (wsq >= nought)
  570|  1.36k|            {
  571|       |/* 
  572|       |     cubic has one real root 
  573|       |*/
  574|  1.36k|               nrts = 1;
  575|  1.36k|               if (v <= nought) mcube = ( -v + sqrt(wsq))*inv2 ;
  576|  1.36k|               if (v  > nought) mcube = ( -v - sqrt(wsq))*inv2 ;
  577|  1.36k|               m = curoot(mcube) ;
  578|  1.36k|               if (m != nought) n = -uo3/m ;
  579|      0|                  else n = nought;
  580|  1.36k|               root = m + n - po3 ;
  581|  1.36k|            }
  582|  15.0k|            else
  583|  15.0k|            {
  584|  15.0k|               nrts = 3;
  585|       |/* 
  586|       |     cubic has three real roots 
  587|       |*/
  588|  15.0k|               if (uo3 < nought)
  589|  15.0k|               {
  590|  15.0k|                  muo3 = -uo3;
  591|  15.0k|                  s = sqrt(muo3) ;
  592|  15.0k|                  scube = s*muo3;
  593|  15.0k|                  t =  -v/(scube+scube) ;
  594|  15.0k|                  cosk = acos3(t) ;
  595|  15.0k|                  if (po3 < nought)
  596|      0|                     root = (s+s)*cosk - po3;
  597|  15.0k|                  else
  598|  15.0k|                  {
  599|  15.0k|                     sinsqk = doub1 - cosk*cosk ;
  600|  15.0k|                     if (sinsqk < nought) sinsqk = nought ;
  601|  15.0k|                     root = s*( -cosk - rt3*sqrt(sinsqk)) - po3 ;
  602|  15.0k|                  }
  603|  15.0k|               }
  604|      0|               else
  605|       |/* 
  606|       |     cubic has multiple root -  
  607|       |*/
  608|      0|               root = curoot(v) - po3 ;
  609|  15.0k|            }
  610|  16.3k|         }
  611|  16.3k|      }
  612|  16.3k|   }
  613|       |   //fprintf(stderr,"cubic %g %g %g %d %g\n",p,q,r,nrts,root);
  614|  16.3k|   return(root);
  615|  16.3k|} /* cubic */
  616|       |/***************************************/
  617|       |
  618|       |double acos3(double x)
  619|       |/* 
  620|       |     find cos(acos(x)/3) 
  621|       |    
  622|       |     Don Herbison-Evans   16/7/81 
  623|       |
  624|       |     called by cubic . 
  625|       |*/
  626|  15.0k|{
  627|  15.0k|   double value;
  628|       |   //double acos(),cos();
  629|       |
  630|  15.0k|   value = cos(acos(x)*inv3);
  631|  15.0k|   return(value);
  632|  15.0k|} /* acos3 */
  633|       |/***************************************/
  634|       |
  635|       |double curoot(double x)
  636|       |/* 
  637|       |     find cube root of x.
  638|       | 
  639|       |     Don Herbison-Evans   30/1/89 
  640|       |
  641|       |     called by cubic . 
  642|       |*/
  643|  1.36k|{
  644|       |	//double exp(),log();
  645|  1.36k|   double value;
  646|  1.36k|   double absx;
  647|  1.36k|   int neg;
  648|       |
  649|  1.36k|   neg = 0;
  650|  1.36k|   absx = x;
  651|  1.36k|   if (x < nought)
  652|    959|   {
  653|    959|      absx = -x;
  654|    959|      neg = 1;
  655|    959|   }
  656|  1.36k|   value = exp( log(absx)*inv3 );
  657|  1.36k|   if (neg == 1) value = -value;
  658|  1.36k|   return(value);
  659|  1.36k|} /* curoot */
  660|       |/****************************************************/
  661|       |
  662|       |int simple(double a,double b,double c,double d,double rts[4])
  663|       |/* 
  664|       |     solve the quartic equation - 
  665|       |
  666|       |   x**4 + a*x**3 + b*x**2 + c*x + d = 0 
  667|       |
  668|       |   called by quartic
  669|       |   calls     cubic, qudrtc.
  670|       |
  671|       |     input - 
  672|       |   a,b,c,e - coeffs of equation. 
  673|       |
  674|       |     output - 
  675|       |   nquar - number of real roots. 
  676|       |   rts - array of root values. 
  677|       |
  678|       |     method :  unstabilized Ferrari-Lagrange
  679|       |     Abramowitz,M. & Stegun I.A.
  680|       |     Handbook of Mathematical Functions
  681|       |     Dover 1972 (ninth printing), pp. 17-18
  682|       |
  683|       |     calls  cubic, qudrtc 
  684|       |*/
  685|      0|{
  686|       |	//double cubic();
  687|       |   //int qudrtc();
  688|       |
  689|      0|   int nquar,n1,n2 ;
  690|      0|   double asq,y;
  691|      0|   double v1[4],v2[4] ;
  692|      0|   double p,q,r ;
  693|      0|   double e,f,esq,fsq ;
  694|      0|   double g,gg,h,hh;
  695|       |
  696|       |   //fprintf(stderr,"\nsimple %g %g %g %g\n",a,b,c,d);
  697|      0|   asq = a*a;
  698|       |
  699|      0|   p = -b ;
  700|      0|   q = a*c-doub4*d ;
  701|      0|   r = -asq*d - c*c + doub4*b*d ;
  702|      0|   y = cubic(p,q,r) ;
  703|       |
  704|      0|   esq = inv4*asq - b + y;
  705|      0|   fsq = inv4*y*y - d;
  706|      0|   if (esq < nought) return(0);
  707|      0|   else
  708|      0|   if (fsq < nought) return(0);
  709|      0|   else
  710|      0|   {
  711|      0|      e = sqrt(esq);
  712|      0|      f = sqrt(fsq);
  713|      0|      g = inv2*a - e;
  714|      0|      h = inv2*y - f;
  715|      0|      gg = inv2*a + e;
  716|      0|      hh = inv2*y + f;
  717|      0|      n1 = qudrtc(gg,hh,v1, gg*gg - doub4*hh) ;
  718|      0|      n2 = qudrtc(g,h,v2, g*g - doub4*h) ;
  719|      0|      nquar = n1+n2 ;
  720|      0|      rts[0] = v1[0] ;
  721|      0|      rts[1] = v1[1] ;
  722|      0|      rts[n1+0] = v2[0] ;
  723|      0|      rts[n1+1] = v2[1] ;
  724|      0|      return(nquar);
  725|      0|   }
  726|      0|} /* simple */
  727|       |/*****************************************/
  728|       | 
  729|       |int descartes(double a,double b,double c,double d,double rts[4])
  730|       |/*
  731|       |   Solve quartic equation using
  732|       |   Descartes-Euler-Cardano algorithm
  733|       |
  734|       |   Strong, T. "Elemementary and Higher Algebra"
  735|       |      Pratt and Oakley, p. 469 (1859)
  736|       |
  737|       |     29 Jun 1994  Don Herbison-Evans
  738|       |*/
  739|      0|{
  740|       |	//int qudrtc();
  741|       |	//double cubic();
  742|       |
  743|      0|   int nrts;
  744|      0|   int r1,r2;
  745|      0|   double v1[4],v2[4];
  746|      0|   double y;
  747|      0|   double p,q,r;
  748|      0|   double A,B,C;
  749|      0|   double m,n1,n2;
  750|      0|   double d3o8,d3o256;
  751|      0|   double inv8,inv16;
  752|      0|   double asq;
  753|      0|   double Binvm;
  754|       |
  755|      0|   d3o8 = (double)3/(double)8;
  756|      0|   inv8 = doub1/(double)8;
  757|      0|   inv16 = doub1/(double)16;
  758|      0|   d3o256 = (double)3/(double)256;
  759|       |
  760|       |   //fprintf(stderr,"\nDescartes %f %f %f %f\n",a,b,c,d);
  761|      0|   asq = a*a;
  762|       |
  763|      0|   A = b - asq*d3o8;
  764|      0|   B = c + a*(asq*inv8 - b*inv2);
  765|      0|   C = d + asq*(b*inv16 - asq*d3o256) - a*c*inv4;
  766|       |
  767|      0|   p = doub2*A;
  768|      0|   q = A*A - doub4*C;
  769|      0|   r = -B*B;
  770|       |
  771|       |/***
  772|       |   inv64 = doub1/(double)64;
  773|       |   p = doub2*b - doub3*a*a*inv4 ;
  774|       |   q = b*b - a*a*b - doub4*d + doub3*a*a*a*a*inv16 + a*c;
  775|       |   r = -c*c - a*a*a*a*a*a*inv64 - a*a*b*b*inv4
  776|       |       -a*a*a*c*inv4 + a*b*c + a*a*a*a*b*inv8;
  777|       |***/
  778|       |
  779|      0|   y = cubic(p,q,r) ;
  780|      0|   if (y <= nought) 
  781|      0|      nrts = 0;
  782|      0|   else
  783|      0|   {
  784|      0|      m = sqrt(y);
  785|      0|      Binvm = B/m;
  786|      0|      n1 = (y + A + Binvm)*inv2;
  787|      0|      n2 = (y + A - Binvm)*inv2;
  788|      0|      r1 = qudrtc(-m, n1, v1, y-doub4*n1);
  789|      0|      r2 = qudrtc( m, n2, v2, y-doub4*n2);
  790|      0|      rts[0] = v1[0]-a*inv4;
  791|      0|      rts[1] = v1[1]-a*inv4;
  792|      0|      rts[r1] = v2[0]-a*inv4;
  793|      0|      rts[r1+1] = v2[1]-a*inv4;
  794|      0|      nrts = r1+r2;
  795|      0|   } 
  796|      0|   return(nrts);
  797|      0|} /* descartes */
  798|       |/****************************************************/

/workspaces/cg/src/cgmath/polynomial_schwarze.cpp:
    1|       |// http://tog.acm.org/resources/GraphicsGems/category.html
    2|       |// Schwarze, Jochen, Cubic and Quartic Roots, Graphics Gems, p. 404-407, code: p. 738-786, Roots3And4.c.
    3|       |// http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c
    4|       |
    5|       |/*
    6|       | *  Roots3And4.c
    7|       | *
    8|       | *  Utility functions to find cubic and quartic roots,
    9|       | *  coefficients are passed like this:
   10|       | *
   11|       | *      c[0] + c[1]*x + c[2]*x^2 + c[3]*x^3 + c[4]*x^4 = 0
   12|       | *
   13|       | *  The functions return the number of non-complex roots and
   14|       | *  put the values into the s array.
   15|       | *
   16|       | *  Author:         Jochen Schwarze (schwarze@isa.de)
   17|       | *
   18|       | *  Jan 26, 1990    Version for Graphics Gems
   19|       | *  Oct 11, 1990    Fixed sign problem for negative q's in SolveQuartic
   20|       | *  	    	    (reported by Mark Podlipec),
   21|       | *  	    	    Old-style function definitions,
   22|       | *  	    	    IsZero() as a macro
   23|       | *  Nov 23, 1990    Some systems do not declare acos() and cbrt() in
   24|       | *                  <math.h>, though the functions exist in the library.
   25|       | *                  If large coefficients are used, EQN_EPS should be
   26|       | *                  reduced considerably (e.g. to 1E-30), results will be
   27|       | *                  correct but multiple roots might be reported more
   28|       | *                  than once.
   29|       | */
   30|       |
   31|       |#include    <math.h>
   32|       |#ifndef M_PI
   33|       |#define M_PI          3.14159265358979323846
   34|       |#endif
   35|       |extern double   sqrt(), cbrt(), cos(), acos();
   36|       |
   37|       |/* epsilon surrounding for near zero values */
   38|       |
   39|   251k|#define     EQN_EPS     1e-9
   40|  98.3k|#define	    IsZero(x)	((x) > -EQN_EPS && (x) < EQN_EPS)
   41|       |
   42|       |//#ifdef NOCBRT
   43|  2.72k|#define     cbrt(x)     ((x) > 0.0 ? pow((double)(x), 1.0/3.0) : \
   44|  2.72k|                          ((x) < 0.0 ? -pow((double)-(x), 1.0/3.0) : 0.0))
   45|       |//#endif
   46|       |
   47|       |int SolveQuadric(double c[ 3 ], double s[ 2 ])
   48|  32.7k|{
   49|  32.7k|    double p, q, D;
   50|       |
   51|       |    /* normal form: x^2 + px + q = 0 */
   52|       |
   53|  32.7k|    p = c[ 1 ] / (2 * c[ 2 ]);
   54|  32.7k|    q = c[ 0 ] / c[ 2 ];
   55|       |
   56|  32.7k|    D = p * p - q;
   57|       |
   58|  32.7k|    if (IsZero(D))
   59|      0|    {
   60|      0|	s[ 0 ] = - p;
   61|      0|	return 1;
   62|      0|    }
   63|  32.7k|    else if (D < 0)
   64|  27.9k|    {
   65|  27.9k|	return 0;
   66|  27.9k|    }
   67|  4.84k|    else // if (D > 0)
   68|  4.84k|    {
   69|  4.84k|	double sqrt_D = sqrt(D);
   70|       |
   71|  4.84k|	s[ 0 ] =   sqrt_D - p;
   72|  4.84k|	s[ 1 ] = - sqrt_D - p;
   73|  4.84k|	return 2;
   74|  4.84k|    }
   75|  32.7k|}
   76|       |
   77|       |
   78|       |int SolveCubic(double c[ 4 ], double s[ 3 ])
   79|  16.3k|{
   80|  16.3k|    int     i, num;
   81|  16.3k|    double  sub;
   82|  16.3k|    double  A, B, C;
   83|  16.3k|    double  sq_A, p, q;
   84|  16.3k|    double  cb_p, D;
   85|       |
   86|       |    /* normal form: x^3 + Ax^2 + Bx + C = 0 */
   87|       |
   88|  16.3k|    A = c[ 2 ] / c[ 3 ];
   89|  16.3k|    B = c[ 1 ] / c[ 3 ];
   90|  16.3k|    C = c[ 0 ] / c[ 3 ];
   91|       |
   92|       |    /*  substitute x = y - A/3 to eliminate quadric term:
   93|       |	x^3 +px + q = 0 */
   94|       |
   95|  16.3k|    sq_A = A * A;
   96|  16.3k|    p = 1.0/3 * (- 1.0/3 * sq_A + B);
   97|  16.3k|    q = 1.0/2 * (2.0/27 * A * sq_A - 1.0/3 * A * B + C);
   98|       |
   99|       |    /* use Cardano's formula */
  100|       |
  101|  16.3k|    cb_p = p * p * p;
  102|  16.3k|    D = q * q + cb_p;
  103|       |
  104|  16.3k|    if (IsZero(D))
  105|      0|    {
  106|      0|	if (IsZero(q)) /* one triple solution */
  107|      0|	{
  108|      0|	    s[ 0 ] = 0;
  109|      0|	    num = 1;
  110|      0|	}
  111|      0|	else /* one single and one double solution */
  112|      0|	{
  113|      0|	    double u = cbrt(-q);
  114|      0|	    s[ 0 ] = 2 * u;
  115|      0|	    s[ 1 ] = - u;
  116|      0|	    num = 2;
  117|      0|	}
  118|      0|    }
  119|  16.3k|    else if (D < 0) /* Casus irreducibilis: three real solutions */
  120|  15.0k|    {
  121|  15.0k|	double phi = 1.0/3 * acos(-q / sqrt(-cb_p));
  122|  15.0k|	double t = 2 * sqrt(-p);
  123|       |
  124|  15.0k|	s[ 0 ] =   t * cos(phi);
  125|  15.0k|	s[ 1 ] = - t * cos(phi + M_PI / 3);
  126|  15.0k|	s[ 2 ] = - t * cos(phi - M_PI / 3);
  127|  15.0k|	num = 3;
  128|  15.0k|    }
  129|  1.36k|    else /* one real solution */
  130|  1.36k|    {
  131|  1.36k|	double sqrt_D = sqrt(D);
  132|  1.36k|	double u = cbrt(sqrt_D - q);
  133|  1.36k|	double v = - cbrt(sqrt_D + q);
  134|       |
  135|  1.36k|	s[ 0 ] = u + v;
  136|  1.36k|	num = 1;
  137|  1.36k|    }
  138|       |
  139|       |    /* resubstitute */
  140|       |
  141|  16.3k|    sub = 1.0/3 * A;
  142|       |
  143|  62.8k|    for (i = 0; i < num; ++i)
  144|  46.4k|	s[ i ] -= sub;
  145|       |
  146|  16.3k|    return num;
  147|  16.3k|}
  148|       |
  149|       |
  150|       |int SolveQuartic(double c[ 5 ], double s[ 4 ])
  151|  16.3k|{
  152|  16.3k|    double  coeffs[ 4 ];
  153|  16.3k|    double  z, u, v, sub;
  154|  16.3k|    double  A, B, C, D;
  155|  16.3k|    double  sq_A, p, q, r;
  156|  16.3k|    int     i, num;
  157|       |
  158|       |    /* normal form: x^4 + Ax^3 + Bx^2 + Cx + D = 0 */
  159|       |
  160|  16.3k|    A = c[ 3 ] / c[ 4 ];
  161|  16.3k|    B = c[ 2 ] / c[ 4 ];
  162|  16.3k|    C = c[ 1 ] / c[ 4 ];
  163|  16.3k|    D = c[ 0 ] / c[ 4 ];
  164|       |
  165|       |    /*  substitute x = y - A/4 to eliminate cubic term:
  166|       |	x^4 + px^2 + qx + r = 0 */
  167|       |
  168|  16.3k|    sq_A = A * A;
  169|  16.3k|    p = - 3.0/8 * sq_A + B;
  170|  16.3k|    q = 1.0/8 * sq_A * A - 1.0/2 * A * B + C;
  171|  16.3k|    r = - 3.0/256*sq_A*sq_A + 1.0/16*sq_A*B - 1.0/4*A*C + D;
  172|       |
  173|  16.3k|    if (IsZero(r))
  174|      0|    {
  175|       |	/* no absolute term: y(y^3 + py + q) = 0 */
  176|       |
  177|      0|	coeffs[ 0 ] = q;
  178|      0|	coeffs[ 1 ] = p;
  179|      0|	coeffs[ 2 ] = 0;
  180|      0|	coeffs[ 3 ] = 1;
  181|       |
  182|      0|	num = SolveCubic(coeffs, s);
  183|       |
  184|      0|	s[ num++ ] = 0;
  185|      0|    }
  186|  16.3k|    else
  187|  16.3k|    {
  188|       |	/* solve the resolvent cubic ... */
  189|       |
  190|  16.3k|	coeffs[ 0 ] = 1.0/2 * r * p - 1.0/8 * q * q;
  191|  16.3k|	coeffs[ 1 ] = - r;
  192|  16.3k|	coeffs[ 2 ] = - 1.0/2 * p;
  193|  16.3k|	coeffs[ 3 ] = 1;
  194|       |
  195|  16.3k|	(void) SolveCubic(coeffs, s);
  196|       |
  197|       |	/* ... and take the one real solution ... */
  198|       |
  199|  16.3k|	z = s[ 0 ];
  200|       |
  201|       |	/* ... to build two quadric equations */
  202|       |
  203|  16.3k|	u = z * z - r;
  204|  16.3k|	v = 2 * z - p;
  205|       |
  206|  16.3k|	if (IsZero(u))
  207|      6|	    u = 0;
  208|  16.3k|	else if (u > 0)
  209|  16.3k|	    u = sqrt(u);
  210|      0|	else
  211|      0|	    return 0;
  212|       |
  213|  16.3k|	if (IsZero(v))
  214|      2|	    v = 0;
  215|  16.3k|	else if (v > 0)
  216|  16.3k|	    v = sqrt(v);
  217|      0|	else
  218|      0|	    return 0;
  219|       |
  220|  16.3k|	coeffs[ 0 ] = z - u;
  221|  16.3k|	coeffs[ 1 ] = q < 0 ? -v : v;
  222|  16.3k|	coeffs[ 2 ] = 1;
  223|       |
  224|  16.3k|	num = SolveQuadric(coeffs, s);
  225|       |
  226|  16.3k|	coeffs[ 0 ]= z + u;
  227|  16.3k|	coeffs[ 1 ] = q < 0 ? v : -v;
  228|  16.3k|	coeffs[ 2 ] = 1;
  229|       |
  230|  16.3k|	num += SolveQuadric(coeffs, s + num);
  231|  16.3k|    }
  232|       |
  233|       |    /* resubstitute */
  234|       |
  235|  16.3k|    sub = 1.0/4 * A;
  236|       |
  237|  26.0k|    for (i = 0; i < num; ++i)
  238|  9.69k|	s[ i ] -= sub;
  239|       |
  240|  16.3k|    return num;
  241|  16.3k|}

/workspaces/cg/src/cgmath/random_generator.cpp:
    1|       |#include <stdlib.h>
    2|       |#include <stdio.h>
    3|       |#include <math.h>
    4|       |
    5|       |#include "random_generator.h"
    6|       |#include "common.h"
    7|       |
    8|       |/* Static methods */
    9|       |
   10|       |/* gammln: returns the value ln[Tau (xx)] for xx > 0 */
   11|       |/*
   12|       | * Internal arithmetic will be done in double precision, a nicety that you can omit
   13|       | * if five-figure accuracy is good enough.
   14|       | */
   15|       |static float
   16|       |gammln (float xx)
   17|      0|{
   18|      0|  double x,y,tmp,ser;
   19|      0|  static double cof[6]={76.18009172947146,
   20|      0|			-86.50532032941677,
   21|      0|			24.01409824083091,
   22|      0|			-1.231739572450155,
   23|      0|			0.1208650973866179e-2,
   24|      0|			-0.5395239384953e-5};
   25|      0|  int j;
   26|       |
   27|      0|  y=x=xx;
   28|      0|  tmp=x+5.5;
   29|      0|  tmp -= (x+0.5)*log(tmp);
   30|      0|  ser=1.000000000190015;
   31|      0|  for (j=0;j<=5;j++) ser += cof[j]/++y;
   32|      0|  return -tmp+log(2.5066282746310005*ser/x);
   33|      0|}
   34|       |
   35|       |
   36|       |
   37|       |
   38|       |
   39|       |/* minimal standard generator */
   40|       |/*
   41|       | * "Minimal" random number generator of Park and Miller.
   42|       | * Returns a uniform random deviate between 0.0 and 1.0.
   43|       | * Set or reset idum to any  integer value (except the
   44|       | * unlikely value MASK) to initialize the sequence; idum
   45|       | * must not be altered between calls for successive deviates
   46|       | * in a sequence
   47|       | */
   48|      0|#define IA 16807
   49|      0|#define IM 2147483647
   50|      0|#define AM (1.0/IM)
   51|      0|#define IQ 127773
   52|      0|#define IR 2836
   53|      0|#define MASK 123459876
   54|       |
   55|       |float
   56|       |ran0 (long *idum)
   57|      0|{
   58|      0|  long k;
   59|      0|  float ans;
   60|       |
   61|      0|  *idum ^= MASK;   // XORing with MASK allows use of zero and other
   62|      0|  k = (*idum)/IQ;  // simple bit patterns for idum
   63|      0|  *idum = IA*(*idum-k*IQ)-IR*k;  // compute idum=(IA*idum)%IM without
   64|      0|  if (*idum < 0) *idum += IM;    // overflows by Scharge's method
   65|      0|  ans = AM*(*idum);    // convert idum ti a floating result
   66|      0|  *idum ^= MASK;    // unmask before return
   67|      0|  return ans;
   68|      0|}
   69|       |
   70|       |
   71|       |/* 
   72|       | * minimal standard generator
   73|       | * with Bays-Durham shuffle and added safeguards
   74|       | */
   75|       |/*
   76|       | * "Minimal" random number generator of Park and Miller with
   77|       | * Bays-Durham shuffle and added safeguards.
   78|       | * returns a uniform random deviate betwen 0.0 and 1.0 (exclusive
   79|       | * of the endpoint values). Call with idum a negative integer to
   80|       | * initialize; thereafter, do not alter idum between successive
   81|       | * deviates in a sequence. RNMX should approximate the largest
   82|       | * floating value that is less than 1.
   83|       | */
   84|      0|#define IA 16807
   85|      0|#define IM 2147483647
   86|      0|#define AM (1.0/IM)
   87|      0|#define IQ 127773
   88|      0|#define IR 2836
   89|      0|#define NTAB 32
   90|      0|#define NDIV (1+(IM-1)/NTAB)
   91|      0|#define EPS 1.2e-7
   92|      0|#define RNMX (1.0-EPS)
   93|       |
   94|       |float
   95|       |ran1 (long *idum)
   96|      0|{
   97|      0|  int j;
   98|      0|  long k;
   99|      0|  static long iy=0;
  100|      0|  static long iv[NTAB];
  101|      0|  float temp;
  102|       |
  103|      0|  if (*idum <= 0 || !iy)  // initialize
  104|      0|  {
  105|      0|    if (-(*idum) < 1) *idum=1;   // be sure to prevent idum = 0
  106|      0|    else *idum = -(*idum);
  107|      0|    for (j=NTAB+7; j>=0; j--) // load the shuffle table (after 8 wam-ups)
  108|      0|    {
  109|      0|      k=(*idum)/IQ;
  110|      0|      *idum=IA*(*idum-k*IQ)-IR*k;
  111|      0|      if (*idum < 0) *idum += IM;
  112|      0|      if (j < NTAB) iv[j] = *idum;
  113|      0|    }
  114|      0|    iy = iv[0];
  115|      0|  }
  116|      0|  k=(*idum)/IQ;  // start here when not initializing
  117|      0|  *idum=IA*(*idum-k*IQ)-IR*k;  // compute idum=(IA*idum)%IM without
  118|      0|  if (*idum < 0) *idum += IM;  // overflows by Schrage's method
  119|      0|  j = iy/NDIV;    // will be in the range 0..NTAB-1
  120|      0|  iy = iv[j];     // output previously stored value and refill
  121|      0|  iv[j] = *idum;  // the shuffle table
  122|      0|  if ((temp=AM*iy) > RNMX) return RNMX; // because users don't expect endpoint values
  123|      0|  else return temp;
  124|      0|}
  125|       |
  126|       |
  127|       |
  128|       |/*
  129|       | * Long period (> 2x10^18) random number generator of L'Ecuyer with
  130|       | * Bays-Durham shuffle and added safeguards.
  131|       | * Returns a uniform random deviate between 0.0 and 1.0 (exclusive of
  132|       | * the ednpoint values). Call with idum a negative integer to initialize;
  133|       | * thereafter, do not alter idum between succesive deviates in a
  134|       | * sequence. RNMX should approximate the largest floating value that
  135|       | * is less than 1.
  136|       | */
  137|      0|#define IM1 2147483563
  138|      0|#define IM2 2147483399
  139|      0|#define AM1 (1.0/IM1)
  140|      0|#define IMM1 (IM1-1)
  141|      0|#define IA1 40014
  142|      0|#define IA2 40692
  143|      0|#define IQ1 53668
  144|      0|#define IQ2 52774
  145|      0|#define IR1 12211
  146|      0|#define IR2 3791
  147|      0|#define NTAB 32
  148|      0|#define NDIV1 (1+IMM1/NTAB)
  149|      0|#define EPS 1.2e-7
  150|      0|#define RNMX (1.0-EPS)
  151|       |
  152|       |float
  153|       |ran2 (long *idum)
  154|      0|{
  155|      0|  int j;
  156|      0|  long k;
  157|      0|  static long idum2 = 123456789;
  158|      0|  static long iy = 0;
  159|      0|  static long iv[NTAB];
  160|      0|  float temp;
  161|       |
  162|      0|  if (*idum <= 0)  // initialize
  163|      0|  {
  164|      0|    if (-(*idum) < 1) *idum=1;  // be sure to prevent idum = 0
  165|      0|    else *idum = -(*idum);
  166|      0|    idum2=(*idum);
  167|      0|    for (j=NTAB+7; j>=0; j--)// load the shuffle table (after 8 warm-ups)
  168|      0|    {
  169|      0|      k=(*idum)/IQ1;
  170|      0|      *idum=IA1*(*idum-k*IQ1)-k*IR1;
  171|      0|      if (*idum < 0) *idum += IM1;
  172|      0|      if (j < NTAB) iv[j] = *idum;
  173|      0|    }
  174|      0|    iy=iv[0];
  175|      0|  }
  176|      0|  k=(*idum)/IQ1;   // start here when not initializing
  177|      0|  *idum=IA1*(*idum-k*IQ1)-k*IR1; // compute idum=(IA1*idum)%IM1 without
  178|      0|  if (*idum < 0) *idum += IM1;   // overflows by Schrage's method
  179|      0|  k=idum2/IQ2;
  180|      0|  idum2=IA2*(idum2-k*IQ2)-k*IR2; // compute idum2=(IA2*idum)%IM2 likewise
  181|      0|  if (idum2 < 0) idum2 += IM2;
  182|      0|  j=iy/NDIV1;   // will be  in the range 0..NTAB-1
  183|      0|  iy=iv[j]-idum2; // here idum is shuffled, idum and idum2 are
  184|      0|  iv[j] = *idum;  // combined to generate output
  185|      0|  if (iy < 1) iy += IMM1;
  186|      0|  if ((temp=AM1*iy) > RNMX) return RNMX; // because users don't expoect endpoint values
  187|      0|  else return temp;
  188|      0|}
  189|       |
  190|       |
  191|       |/*
  192|       | * Returns a uniform random deviate between 0.0 and 1.0.
  193|       | * Set idum to any negative value to initialize or reinitialize
  194|       | * the sequence
  195|       | */
  196|      0|#define MBIG 1000000000
  197|      0|#define MSEED 161803398
  198|      0|#define MZ 0
  199|      0|#define FAC (1.0/MBIG)
  200|       |/* According to Knuth, any large MBIG, and any smaller (but still large)
  201|       |   MSEED can be substituted for the above values*/
  202|       |
  203|       |float
  204|       |ran3 (long *idum)
  205|      0|{
  206|      0|  static int inext,inextp;
  207|      0|  static long ma[56];  // the value 56 (rang ma[1..55]) is special
  208|      0|  static int iff=0;    // and should not be modified; see Knuth
  209|      0|  long mj,mk;
  210|      0|  int i,ii,k;
  211|       |
  212|      0|  if (*idum < 0 || iff == 0)  // initialization
  213|      0|  {
  214|      0|    iff=1;
  215|      0|    mj=labs(MSEED-labs(*idum));  // initialize ma[55] using the seed idum
  216|      0|    mj %= MBIG;                  // and the large number MSEED
  217|      0|    ma[55]=mj;
  218|      0|    mk=1;
  219|      0|    for (i=1;i<=54;i++) // now initialize the rest of the table
  220|      0|    {                   // in a slightly random order,
  221|      0|      ii=(21*i) % 55;   // with numbers that are note especially random
  222|      0|      ma[ii]=mk;
  223|      0|      mk=mj-mk;
  224|      0|      if (mk < MZ) mk += MBIG;
  225|      0|      mj=ma[ii];
  226|      0|    }
  227|      0|    for (k=1;k<=54;k++)   // we randomize them by "warming up the
  228|      0|      for (i=1;i<=55;i++) // generator"
  229|      0|      {
  230|      0|	ma[i] -= ma[1+(i+30) % 55];
  231|      0|	if (ma[i] < MZ) ma[i] += MBIG;
  232|      0|      }
  233|      0|    inext=0;    // prepare indices for our first generated number
  234|      0|    inextp=31;  // the constant 31 is special; see Knuth
  235|      0|    *idum=1;
  236|      0|  }
  237|       |  // Here is where we start, except on initialization
  238|      0|  if (++inext == 56) inext=1;   // increment inext and inextp, wrapping
  239|      0|  if (++inextp == 56) inextp=1; // around 56 to 1
  240|      0|  mj=ma[inext]-ma[inextp];  // generate a new random number subtractively
  241|      0|  if (mj < MZ) mj += MBIG;  // be sure that it is in range
  242|      0|  ma[inext]=mj;   // store it
  243|      0|  return mj*FAC;  // and output the derived uniform deviate
  244|      0|}
  245|       |
  246|       |
  247|       |
  248|       |
  249|       |/***************************/
  250|       |/*** Exponental deviates ***/
  251|       |/***************************/
  252|       |/*
  253|       | * Returns an exponentially distributed, positive, random deviate of
  254|       | * unit mean, using ran1(idum) as the source of uniform deviates
  255|       | */
  256|       |float
  257|       |expdev (long *idum)
  258|      0|{
  259|      0|  float ran1(long *idum);
  260|      0|  float dum;
  261|       |
  262|      0|  do
  263|      0|    dum=ran1(idum);
  264|      0|  while (dum == 0.0);
  265|      0|  return  -log(dum);
  266|      0|}
  267|       |
  268|       |
  269|       |/**********************************/
  270|       |/*** Normal (gaussian) deviates ***/
  271|       |/**********************************/
  272|       |/*
  273|       | * Returns a normally distributed deviate with zero mean and unit
  274|       | * variance, using ran1(idum) as the source of uniform deviates
  275|       | */
  276|       |float
  277|       |gasdev (long *idum)
  278|      0|{
  279|      0|  float ran1(long *idum);
  280|      0|  static int iset=0;
  281|      0|  static float gset;
  282|      0|  float fac,rsq,v1,v2;
  283|       |
  284|       |  //if (*idum < 0) iset=0;  // reinitialize
  285|      0|  if(iset == 0){     // we don't have an extra deviate handy, so
  286|      0|    do{
  287|      0|      v1=2.0*ran1(idum)-1.0; // pick two uniform numbers in the square
  288|      0|      v2=2.0*ran1(idum)-1.0; // extending from -1 to +1 in each direction
  289|      0|      rsq=v1*v1+v2*v2;    // see if they are in the unit circle
  290|      0|    } while(rsq >= 1.0 || rsq == 0.0);  // and if they are not, try again
  291|      0|    fac=sqrt(-2.0*log(rsq)/rsq);
  292|       |    // now make the Box-Muller transformation to get two normal deviates
  293|       |    // return one and save the other for next time
  294|      0|    gset=v1*fac;
  295|      0|    iset=1;   // set flag
  296|      0|    return v2*fac;
  297|      0|  } else {       // we have an extra deviate handy,
  298|      0|    iset=0;      // so unset the flag,
  299|      0|    return gset; // and return it
  300|      0|  }
  301|      0|}
  302|       |
  303|       |/**************************/
  304|       |/*** Gamma distribution ***/
  305|       |/**************************/
  306|       |/*
  307|       | * Returns a deviate distributed as a gamma distribution of integer
  308|       | * order ia, i.e., a waiting time to the iath event in a Poisson
  309|       | * process of unit mean, using ran1(idum) as the source of uniform
  310|       | * deviates
  311|       | */
  312|       |float
  313|       |gamdev (int ia, long *idum)
  314|      0|{
  315|      0|  float ran1(long *idum);
  316|      0|  int j;
  317|      0|  float am,e,s,v1,v2,x,y;
  318|       |
  319|      0|  if (ia < 1) printf ("Error in routine gandev\n");
  320|      0|  if (ia < 6)  // use direct method, adding waiting time
  321|      0|  {
  322|      0|    x=1.0;
  323|      0|    for (j=1;j<=ia;j++) x *= ran1(idum);
  324|      0|    x = -log(x);
  325|      0|  }
  326|      0|  else {   // use rejection methode
  327|      0|    do {
  328|      0|      do {
  329|      0|	do {     // these four lines generate the tangent of
  330|      0|	  v1=ran1(idum);  // a random angle, i.e., they are
  331|      0|	  v2=2.0*ran1(idum)-1.0;  // equivalent to
  332|      0|	} while (v1*v1+v2*v2 > 1.0);  // y = tan(PI * ran1(idum))
  333|      0|	y=v2/v1;
  334|      0|	am=ia-1;
  335|      0|	s=sqrt(2.0*am+1.0);
  336|      0|	x=s*y+am;           // we decide whether to reject x:
  337|      0|      } while (x <= 0.0);   // reject in region of zero probability
  338|      0|      e=(1.0+y*y)*exp(am*log(x/am)-s*y); // ratio of prob. fn. to comparison fn.
  339|      0|    } while (ran1(idum) > e);  // reject on basis of a second uniform deviate
  340|      0|  }
  341|      0|  return x;
  342|      0|}
  343|       |
  344|       |/************************/
  345|       |/*** Poisson deviates ***/
  346|       |/************************/
  347|      0|#define PI 3.141592654
  348|       |
  349|       |/*
  350|       | * Returns as a floating-point number an integer value that is a random
  351|       | * deviate drawn from a Poisson distribution of mean xm, using
  352|       | * ran1(idum) as a source of uniform random deviates.
  353|       | */
  354|       |float
  355|       |poidev (float xm, long*idum)
  356|      0|{
  357|      0|  float gammln(float xx);
  358|      0|  float ran1(long *idum);
  359|      0|  static float sq,alxm,g,oldm=(-1.0);  // oldm is a flag for whether xm has changed
  360|      0|  float em,t,y;                        // since last call
  361|       |
  362|      0|  if (xm < 12.0) {        // use direct method
  363|      0|    if (xm != oldm) {
  364|      0|      oldm=xm;
  365|      0|      g=exp(-xm);
  366|      0|    }
  367|      0|    em = -1.0;
  368|      0|    t = 1.0;
  369|      0|    do {                // instead of adding exponential deviates it is equivalent
  370|      0|      ++em;             // to multiply uniform deviates. We never actually have to
  371|      0|      t *= ran1(idum);  // take the log, merely compare to the pre-computed
  372|      0|    } while (t > g);    // exponential
  373|      0|  } else {            // use rejection method
  374|      0|    if (xm != oldm) {   // if xm has changed since the last call, then pre-compute
  375|      0|      oldm=xm;          // some functions that occur below
  376|      0|      sq=sqrt(2.0*xm);
  377|      0|      alxm=log(xm);
  378|      0|      g=xm*alxm-gammln(xm+1.0);
  379|       |      // the function gammln is the natural log of the gamma function
  380|      0|    }
  381|      0|    do {
  382|      0|      do {             // y is a deviate from a Lorentzian comparison function
  383|      0|	y=tan(PI*ran1(idum));
  384|      0|	em=sq*y+xm;    // em is y, shifted and scaled
  385|      0|      } while (em < 0.0);   // reject if in regime of zero probability
  386|      0|      em=floor(em);         // the trick for integer-valued distributions
  387|      0|      t=0.9*(1.0+y*y)*exp(em*alxm-gammln(em+1.0)-g);
  388|       |      // the ratio of the desired distribution to the comparison function; we accept
  389|       |      // or reject by comparing it to another uniform deviate. The factor 0.9 is
  390|       |      // chosen so that t never exceeds 1.
  391|      0|    } while (ran1(idum) > t);
  392|      0|  }
  393|      0|  return em;
  394|      0|}
  395|       |
  396|       |
  397|       |/*************************/
  398|       |/*** Binomial deviates ***/
  399|       |/*************************/
  400|      0|#define PI 3.141592654
  401|       |
  402|       |/*
  403|       | * Returns as a floating-point number an integer value that is a random
  404|       | * deviate drawn from a binomial distribution of n trials each of probability
  405|       | * pp, using ran1(idum) as a source of uniform random deviates.
  406|       | */
  407|       |float
  408|       |bnldev (float pp, int n, long *idum)
  409|      0|{
  410|      0|  float gammln(float xx);
  411|      0|  float ran1(long *idum);
  412|      0|  int j;
  413|      0|  static int nold=(-1);
  414|      0|  float am,em,g,angle,p,bnl,sq,t,y;
  415|      0|  static float pold=(-1.0),pc,plog,pclog,en,oldg;
  416|       |
  417|      0|  p=(pp <= 0.5 ? pp : 1.0-pp);
  418|       |  // The binomial distribution is invariant under changing pp to 1-pp,
  419|       |  // if we also change the answer to n minus itself; we'll remember to do this below
  420|      0|  am=n*p;         // this is the mean of the deviate to be produced
  421|      0|  if (n < 25) {   // use the direct method while n is not too large
  422|      0|    bnl=0.0;      // this can require up to 25 calls to ran1
  423|      0|    for (j=1;j<=n;j++)
  424|      0|      if (ran1(idum) <p) ++bnl;
  425|      0|  } else if (am < 1.0) {  // if fewer than one event is expected out of 25
  426|      0|    g=exp(-am);           // or more trials, then the distribution is quite
  427|      0|    t=1.0;                // accurately Poisson. Use direct Poisson direct
  428|      0|    for (j=0;j<=n;j++) {
  429|      0|      t *= ran1(idum);
  430|      0|      if (t < g) break;
  431|      0|    }
  432|      0|    bnl=(j <= n ? j : n);
  433|      0|  } else {                // Use the rejection method
  434|      0|    if (n != nold) {    // if n has changed, then compute useful quantities
  435|      0|      en=n;
  436|      0|      oldg=gammln(en+1.0);
  437|      0|      nold=n;
  438|      0|    } if (p != pold) {  // if p has changed, then compute useful quandtities
  439|      0|      pc=1.0-p;
  440|      0|      plog=log(p);
  441|      0|      pclog=log(pc);
  442|      0|      pold=p;
  443|      0|    }
  444|      0|    sq=sqrt(2.0*am*pc);  // the following code should by now seem familiar
  445|      0|    do {                 // rejection method with a Lorentzian comparison function
  446|      0|      do {
  447|      0|	angle=PI*ran1(idum);
  448|      0|	y=tan(angle);
  449|      0|	em=sq*y+am;
  450|      0|      } while (em < 0.0 || em >= (en+1.0));  // reject
  451|      0|      em=floor(em);         // trick for integer-valued distribution
  452|      0|      t=1.2*sq*(1.0+y*y)*exp(oldg-gammln(em+1.0)
  453|      0|			     -gammln(en-em+1.0)+em*plog+(en-em)*pclog);
  454|      0|    } while (ran1(idum) > t);   // reject. This happens about 1.5 times per deviate,
  455|      0|    bnl=em;                     // on average
  456|      0|  }
  457|      0|  if (p != pp) bnl=n-bnl;   // remember to undo the symmetry transformation
  458|      0|  return bnl;
  459|      0|}
  460|       |

/workspaces/cg/src/cgmath/ray.h:
    1|       |#ifndef __RAY_H__
    2|       |#define __RAY_H__
    3|       |
    4|       |#include "TVector3.h"
    5|       |
    6|       |class Ray {
    7|       |public:
    8|      0|	Ray() {}
    9|       |	Ray(Vector3 o, Vector3 d)
   10|   884k|		{
   11|   884k|			origin = o;
   12|   884k|			direction = d;
   13|   884k|			inv_direction = Vector3(1/d.x, 1/d.y, 1/d.z);
   14|   884k|			sign[0] = (inv_direction.x < 0);
   15|   884k|			sign[1] = (inv_direction.y < 0);
   16|   884k|			sign[2] = (inv_direction.z < 0);
   17|   884k|		}
   18|       |	Ray(float ox, float oy, float oz, float dx, float dy, float dz)
   19|  45.8k|		{
   20|  45.8k|			origin.Set (ox, oy, oz);
   21|  45.8k|			direction.Set (dx, dy, dz);
   22|  45.8k|			inv_direction = Vector3(1/dx, 1/dy, 1/dz);
   23|  45.8k|			sign[0] = (inv_direction.x < 0);
   24|  45.8k|			sign[1] = (inv_direction.y < 0);
   25|  45.8k|			sign[2] = (inv_direction.z < 0);
   26|  45.8k|		}
   27|       |	Ray(const Ray &r)
   28|      0|		{
   29|      0|			origin = r.origin;
   30|      0|			direction = r.direction;
   31|      0|			inv_direction = r.inv_direction;
   32|      0|			sign[0] = r.sign[0]; sign[1] = r.sign[1]; sign[2] = r.sign[2];
   33|      0|		}
   34|       |	
   35|       |	void Dump (void);
   36|       |
   37|       |
   38|       |	Vector3 origin;
   39|       |	Vector3 direction;
   40|       |	Vector3 inv_direction;
   41|       |	int sign[3];
   42|       |};
   43|       |
   44|       |#endif // __RAY_H__

/workspaces/cg/src/cgmesh/DirectVisibilityOfPointSets.h:
    1|       |#ifndef __DIRECT_VISIBILITY_OF_POINT_SETS_H__
    2|       |#define __DIRECT_VISIBILITY_OF_POINT_SETS_H__
    3|       |
    4|       |//
    5|       |// Reference :
    6|       |// Direct Visibility of Point Sets, 
    7|       |// Sagi Katz, Ayellet Tal, and Ronen Basri. 
    8|       |// SIGGRAPH 2007, ACM Transactions on Graphics, Volume 26, Issue 3, August 2007, 24/1-24/11 
    9|       |// http://webee.technion.ac.il/~ayellet/papers.html
   10|       |//
   11|       |
   12|       |
   13|       |class DirectVisibilityOfPointSets
   14|       |{
   15|       |public:
   16|       |	DirectVisibilityOfPointSets ();
   17|       |
   18|       |	void SetCamera (float x, float y, float z)
   19|      0|	{
   20|      0|		m_camera[0] = x;
   21|      0|		m_camera[1] = y;
   22|      0|		m_camera[2] = z;
   23|      0|	};
   24|       |	void SetPoints (int nPoints, float *points);
   25|       |
   26|       |	float* ComputeVisiblePoints (void);
   27|       |
   28|       |public:
   29|       |
   30|       |	int   m_nPoints;
   31|       |	float *m_pointsFlipped;
   32|       |	float *m_points;
   33|       |	float m_camera[3];
   34|       |
   35|       |	int   m_nPointsVisible;
   36|       |	float *m_pointsVisible;
   37|       |};
   38|       |
   39|       |#endif // __DIRECT_VISIBILITY_OF_POINT_SETS_H__

/workspaces/cg/src/cgmesh/ambient_occlusion.h:
    1|       |#ifndef __AMBIENT_OCCLUSION_H__
    2|       |#define __AMBIENT_OCCLUSION_H__
    3|       |
    4|       |#include "mesh_half_edge.h"
    5|       |
    6|       |//
    7|       |// References :
    8|       |// http://loulou.developpez.com/tutoriels/3d/ambient-occlusion/
    9|       |// http://www.csee.umbc.edu/~olano/635f05/wc1.pdf
   10|       |//
   11|       |class MeshAlgoAmbientOcclusion
   12|       |{
   13|       |	friend class CallbackTraverse;
   14|       |public:
   15|       |	MeshAlgoAmbientOcclusion ();
   16|       |	~MeshAlgoAmbientOcclusion ();
   17|       |
   18|       |	bool Init (Mesh *mesh);
   19|       |	float* Evaluate (int nPasses = 1);
   20|       |
   21|       |private:
   22|       |	Mesh *m_pMesh;
   23|       |
   24|       |	class Patch
   25|       |	{
   26|       |	public:
   27|       |		Patch ()
   28|      0|		{
   29|      0|			vec3_init (m_vPosition, 0., 0., 0.);
   30|      0|			vec3_init (m_vNormale, 0., 0., 0.);
   31|      0|			m_fArea = 0.;
   32|      0|			m_fOcclusion = 0.;
   33|      0|			m_fPrevOcclusion = 0.;
   34|      0|		}
   35|      0|		~Patch() {};
   36|       |
   37|       |		vec3 m_vPosition;
   38|       |		vec3 m_vNormale;
   39|       |		float m_fArea;
   40|       |		float m_fOcclusion;
   41|       |		float m_fPrevOcclusion;
   42|       |	};
   43|       |	Patch *m_pPatches;
   44|       |
   45|       |	float compute_occlusion (int index_receiver, int index_emitter);
   46|       |	static float clampOcclusion (float);
   47|       |};
   48|       |
   49|       |#endif // __AMBIENT_OCCLUSION_H__

/workspaces/cg/src/cgmesh/audio.cpp:
    1|       |#include <stdio.h>
    2|       |#include <stdlib.h>
    3|       |
    4|       |#include "audio.h"
    5|       |#include "audio_rfft.h"
    6|       |
    7|       |Audio::Audio ()
    8|      3|{
    9|      3|     data = NULL;
   10|      3|}
   11|       |
   12|       |Audio::~Audio()
   13|      0|{
   14|      0|     if (data)
   15|      0|	  free (data);
   16|      0|}
   17|       |
   18|       |int Audio::init (unsigned int _length, unsigned int _channels, unsigned int _rate)
   19|      3|{
   20|      3|     length = _length;
   21|      3|     channels = _channels;
   22|      3|     rate = _rate;
   23|      3|     if (length * channels)
   24|      3|	  data = (float *) calloc(length * channels, sizeof(float));
   25|      0|     else
   26|      0|	  data = NULL;
   27|       |     
   28|      3|     return 0;
   29|      3|}
   30|       |
   31|       |void Audio::get_spectrum (unsigned int start, unsigned int length, float *spectrum)
   32|  1.20k|{
   33|  1.20k|	unsigned int i, j;
   34|       |
   35|  1.20k|	if (start > length || start + length > length)
   36|  1.19k|		return;
   37|       |
   38|       |	// mix all channels
   39|    257|	for (i = 0; i < length; i++) {
   40|    256|		float s = 0.0;
   41|    768|		for (j = 0; j < channels; j++)
   42|    512|			s += data[(start + i) * channels + j];
   43|    256|		s /= channels;
   44|    256|		spectrum[i] = s;
   45|    256|	}
   46|       |
   47|       |	// compute spectrum via FFT
   48|      1|	rfft(spectrum, length);
   49|      1|}
   50|       |
   51|       |void Audio::dump (void)
   52|      1|{
   53|      1|	printf ("length : %d\n", length);
   54|      1|	printf ("rate : %d\n", rate);
   55|      1|	printf ("channels : %d\n", channels);
   56|      1|}
   57|       |

/workspaces/cg/src/cgmesh/audio.h:
    1|       |#ifndef __AUDIO_H__
    2|       |#define __AUDIO_H__
    3|       |
    4|       |class Audio
    5|       |{
    6|       |public:
    7|       |	Audio ();
    8|       |	~Audio ();
    9|       |
   10|       |	int init (unsigned int _length, unsigned int _channels, unsigned int _rate);
   11|       |	int load (char *filename);
   12|       |
   13|  1.20k|	unsigned int get_length (void) { return length; };
   14|      1|	unsigned int get_rate (void) { return rate; };
   15|       |	void get_spectrum (unsigned int start, unsigned int length, float *spectrum);
   16|       |
   17|       |	void dump (void);
   18|       |
   19|       |public:
   20|       |	int import_wav (char const *filename, int verbose);
   21|       |
   22|       |	unsigned int length;
   23|       |	unsigned int rate;
   24|       |	unsigned int channels;
   25|       |	float *data;
   26|       |};
   27|       |
   28|       |#endif // __AUDIO_H__
   29|       |

/workspaces/cg/src/cgmesh/audio_convert.cpp:
    1|       |#include "audio_convert.h"
    2|       |
    3|       |Img* audio_2_image (Audio *pAudio)
    4|      1|{
    5|      1|	if (!pAudio)
    6|      0|		return NULL;
    7|       |	
    8|      1|	unsigned int length = pAudio->get_length ();
    9|      1|	unsigned int w = 1024;
   10|      1|	unsigned int h = 320;
   11|      1|	unsigned int samples = (unsigned int)(length / w);
   12|       |	
   13|      1|	float *data = (float*)malloc(w*sizeof(float));
   14|      1|	memset (data, 0, w*sizeof(float));
   15|  1.02k|	for (int i=0; i<w; i++)
   16|   146k|		for (int s=0; s<samples; s++)
   17|   436k|			for (int c=0; c<pAudio->channels; c++)
   18|   290k|				data[i] += pAudio->data[pAudio->channels*(i+s)+c];
   19|       |	
   20|       |	
   21|      1|	float min = data[0];
   22|      1|	float max = data[0];
   23|  1.02k|	for (int i=1; i<w; i++)
   24|  1.02k|	{
   25|  1.02k|		if (min > data[i]) min = data[i];
   26|  1.02k|		if (max < data[i]) max = data[i];
   27|  1.02k|	}
   28|       |
   29|      1|	Img *img = new Img (w, h);
   30|       |	
   31|  1.02k|	for (int i=0; i<w; i++)
   32|  1.02k|	{
   33|  1.02k|		float d = data[i];
   34|  1.02k|		int hd = h*(d-min)/(max-min);
   35|   153k|		for (int j=0; j<hd; j++)
   36|   152k|			img->set_pixel (i, j, 0, 0, 255, 255);
   37|   175k|		for (int j=hd; j<h; j++)
   38|   174k|			img->set_pixel (i, j, 255, 0, 0, 255);
   39|  1.02k|	}
   40|       |	
   41|      1|	free (data);
   42|       |	
   43|      1|	return img;
   44|      1|}
   45|       |
   46|       |Img* audio_fft_2_image (Audio *pAudio)
   47|      0|{
   48|      0|	return NULL;
   49|      0|}
   50|       |
   51|       |

/workspaces/cg/src/cgmesh/audio_io.cpp:
    1|       |#include <stdio.h>
    2|       |#include <math.h>
    3|       |#include <string.h>
    4|       |
    5|       |#include "../cgmath/cgmath.h"
    6|       |
    7|       |#include "audio.h"
    8|       |
    9|       |int Audio::load (char *filename)
   10|      3|{
   11|      3|	if (!filename)
   12|      0|		return -1;
   13|       |
   14|      3|	if (strcmp (filename+(strlen(filename)-4), ".wav") == 0)
   15|      3|	     return import_wav (filename, 1);
   16|       |
   17|      0|	return -1;
   18|      3|}
   19|       |
   20|       |//
   21|       |// WAV
   22|       |//
   23|       |// https://ccrma.stanford.edu/courses/422/projects/WaveFormat/
   24|       |//
   25|       |typedef struct {
   26|       |     char chunkID[4]; // "RIFF"
   27|       |     unsigned int Chunksize;
   28|       |     char Format[4]; // "WAVE"
   29|       |
   30|       |     char Subchunk1ID[4]; // "fmt "
   31|       |     unsigned int Subchunk1Size;
   32|       |     unsigned short AudioFormat;
   33|       |     unsigned short NumChannels;
   34|       |     unsigned int samplerate;
   35|       |     unsigned int bytespersec;
   36|       |     unsigned short blocksize;
   37|       |     unsigned short bps;
   38|       |
   39|       |     char Subchunk2ID[4]; // "data"
   40|       |     unsigned int Subchunk2Size;
   41|       |} wav_hdr_t;
   42|       |
   43|       |static float get_sample(FILE *f, unsigned int bps)
   44|   141k|{
   45|   141k|	int c1 = fgetc(f);
   46|   141k|	if (c1 == EOF)
   47|      3|		return NAN;
   48|   141k|	if (bps == 8)
   49|   141k|		return c1 / 128.;
   50|       |	// little-endian signed
   51|      0|	int c2 = fgetc(f);
   52|      0|	if (c2 == EOF)
   53|      0|		return NAN;
   54|      0|	return (((int)((signed char)c2) << 8) | c1) / 32768.;
   55|      0|}
   56|       |
   57|       |int Audio::import_wav (char const *filename, int verbose)
   58|      3|{
   59|      3|	wav_hdr_t hdr;
   60|       |
   61|      3|	FILE *f = fopen(filename, "rb");
   62|       |
   63|      3|	if (fread(&hdr, sizeof(hdr), 1, f) != 1)
   64|      0|	{
   65|      0|		printf ("could not read %s\n", filename);
   66|      0|		fclose(f);
   67|      0|		return 0;
   68|      0|	}
   69|       |
   70|      3|	if (verbose)
   71|      3|	{
   72|      3|	     printf("rate %d\n", hdr.samplerate);
   73|      3|	     printf("bps %d\n", hdr.bps);
   74|      3|	     printf("NumChannels %d\n", hdr.NumChannels);
   75|      3|	     printf("Chunksize %d\n", hdr.Chunksize);
   76|      3|	     printf("Subchunk1Size %d\n", hdr.Subchunk1Size);
   77|      3|	}
   78|       |/*	
   79|       |	while (hdr.Subchunk2ID[0] != 'd' ||
   80|       |	       hdr.Subchunk2ID[1] != 'a' ||
   81|       |	       hdr.Subchunk2ID[2] != 't' ||
   82|       |	       hdr.Subchunk2ID[3] != 'a')
   83|       |	{
   84|       |		printf("data: %c%c%c%c\n", hdr.Subchunk2ID[0], hdr.Subchunk2ID[1], hdr.Subchunk2ID[2], hdr.Subchunk2ID[3]);
   85|       |		printf("Subchunk2Size %d\n", hdr.Subchunk2Size);
   86|       |
   87|       |		if (fseek(f, hdr.Subchunk2Size, SEEK_CUR) == -1) {
   88|       |			printf("could not read %s\n", filename);
   89|       |			fclose(f);
   90|       |			return NULL;
   91|       |		}
   92|       |
   93|       |		if (fread(&hdr.Subchunk2ID, sizeof(hdr.Subchunk2ID) + sizeof(hdr.Subchunk2Size), 1, f) != 1) {
   94|       |			printf("could not read %s\n", filename);
   95|       |			fclose(f);
   96|       |			return NULL;
   97|       |		}
   98|       |	}
   99|       |*/
  100|       |
  101|      3|	if (verbose)
  102|      3|	{
  103|      3|	     printf("Subchunk2ID: \"%c%c%c%c\"\n", hdr.Subchunk2ID[0], hdr.Subchunk2ID[1], hdr.Subchunk2ID[2], hdr.Subchunk2ID[3]);
  104|      3|	     printf("datasize %d\n", hdr.Subchunk2Size);
  105|      3|	}
  106|       |
  107|      3|	if (hdr.bps != 16 && hdr.bps != 8) {
  108|      0|		printf("invalid format (%d bps)\n", hdr.bps);
  109|      0|		fclose(f);
  110|      0|		return 0;
  111|      0|	}
  112|       |  
  113|       |	// convert audio data to NSArray
  114|      3|	unsigned int datasize = hdr.Subchunk2Size;
  115|      3|	unsigned int NumChannels = hdr.NumChannels;
  116|      3|	unsigned int length = datasize / (hdr.NumChannels * hdr.bps / 8);
  117|       |
  118|      3|	init (length, NumChannels, hdr.samplerate);
  119|      3|	unsigned int i, j;
  120|  70.7k|	for (i = 0; i < length; i++) {
  121|   212k|		for (j = 0; j < NumChannels; j++) {
  122|   141k|			float v = get_sample(f, hdr.bps);
  123|   141k|			if (isnan(v)) {
  124|      3|				printf("unexpected end of file %s\n", filename);
  125|      3|				fclose(f);
  126|      3|				return -1;
  127|      3|			}
  128|   141k|			data[i * NumChannels + j] = v;
  129|   141k|		}
  130|  70.7k|	}
  131|       |
  132|      0|	fclose(f);
  133|      0|	return 0;
  134|      3|}
  135|       |//
  136|       |///////////////////////

/workspaces/cg/src/cgmesh/audio_rfft.cpp:
    1|       |#include <math.h>
    2|       |#include "audio_rfft.h"
    3|       |
    4|       |extern "C" {
    5|       |
    6|       |/****************************************************************************
    7|       |* rfft(float X[],int N)                                                     *
    8|       |*     A real-valued, in-place, split-radix FFT program                      *
    9|       |*     Decimation-in-time, cos/sin in second loop                            *
   10|       |*     Input: float X[1]...X[N] (NB Fortran style: 1st pt X[1] not X[0]!)    *
   11|       |*     Length is N=2**M (i.e. N must be power of 2--no error checking)       *
   12|       |*     Output in X[1]...X[N], in order:                                      *
   13|       |*           [Re(0), Re(1),..., Re(N/2), Im(N/2-1),..., Im(1)]               *
   14|       |*                                                                           *
   15|       |* Original Fortran code by Sorensen; published in H.V. Sorensen, D.L. Jones,*
   16|       |* M.T. Heideman, C.S. Burrus (1987) Real-valued fast fourier transform      *
   17|       |* algorithms.  IEEE Trans on Acoustics, Speech, & Signal Processing, 35,    *
   18|       |* 849-863.  Adapted to C by Bill Simpson, 1995  wsimpson@uwinnipeg.ca       *
   19|       |****************************************************************************/
   20|       |
   21|       |static void __rfft(float X[],int N)
   22|      1|{
   23|      1|int I,I0,I1,I2,I3,I4,I5,I6,I7,I8, IS,ID;
   24|      1|int J,K,M,N2,N4,N8;
   25|      1|float A,A3,CC1,SS1,CC3,SS3,E,R1,XT;
   26|      1|float T1,T2,T3,T4,T5,T6;  
   27|       |
   28|      1|M=(int)(log((float)N)/log((float)2.0));               /* N=2^M */
   29|       |
   30|       |/* ----Digit reverse counter--------------------------------------------- */
   31|      1|J = 1;
   32|    256|for(I=1;I<N;I++)
   33|    255|        {
   34|    255|        if (I<J)
   35|    120|                {
   36|    120|                XT    = X[J];
   37|    120|                X[J]  = X[I];
   38|    120|                X[I]  = XT;
   39|    120|                }
   40|    255|        K = N/2;
   41|    502|        while(K<J)
   42|    247|                {
   43|    247|                J -= K;
   44|    247|                K /= 2;
   45|    247|                }
   46|    255|        J += K;
   47|    255|        }
   48|       |
   49|       |/* ----Length two butterflies--------------------------------------------- */
   50|      1|IS = 1;
   51|      1|ID = 4;
   52|      1|do
   53|      4|        {
   54|     89|        for(I0 = IS;I0<=N;I0+=ID)
   55|     85|                {
   56|     85|                I1    = I0 + 1;
   57|     85|                R1    = X[I0];
   58|     85|                X[I0] = R1 + X[I1];
   59|     85|                X[I1] = R1 - X[I1];
   60|     85|                }
   61|      4|        IS = 2 * ID - 1;
   62|      4|        ID = 4 * ID;
   63|      4|        }while(IS<N);
   64|       |/* ----L shaped butterflies----------------------------------------------- */
   65|      1|N2 = 2;
   66|      8|for(K=2;K<=M;K++)
   67|      7|        {
   68|      7|        N2    = N2 * 2;
   69|      7|        N4    = N2/4;
   70|      7|        N8    = N2/8;
   71|      7|        E     = (float) 6.2831853071719586f/N2;
   72|      7|        IS    = 0;
   73|      7|        ID    = N2 * 2;
   74|      7|        do
   75|     16|                {
   76|    101|                for(I=IS;I<N;I+=ID)
   77|     85|                        {
   78|     85|                        I1 = I + 1;
   79|     85|                        I2 = I1 + N4;
   80|     85|                        I3 = I2 + N4;
   81|     85|                        I4 = I3 + N4;
   82|     85|                        T1 = X[I4] +X[I3];
   83|     85|                        X[I4] = X[I4] - X[I3];
   84|     85|                        X[I3] = X[I1] - T1;
   85|     85|                        X[I1] = X[I1] + T1;
   86|     85|                        if(N4!=1)
   87|     42|                                {
   88|     42|                                I1 += N8;
   89|     42|                                I2 += N8;
   90|     42|                                I3 += N8;
   91|     42|                                I4 += N8;
   92|     42|                                T1 = (X[I3] + X[I4])*.7071067811865475244f;
   93|     42|                                T2 = (X[I3] - X[I4])*.7071067811865475244f;
   94|     42|                                X[I4] = X[I2] - T1;
   95|     42|                                X[I3] = -X[I2] - T1;
   96|     42|                                X[I2] = X[I1] - T2;
   97|     42|                                X[I1] = X[I1] + T2;
   98|     42|                                }
   99|     85|                        }
  100|     16|                        IS = 2 * ID - N2;
  101|     16|                        ID = 4 * ID;
  102|     16|                }while(IS<N);
  103|      7|        A = E;
  104|     64|        for(J= 2;J<=N8;J++)
  105|     57|                {
  106|     57|                A3 = 3.0 * A;
  107|     57|                CC1   = cos(A);
  108|     57|                SS1   = sin(A);  /*typo A3--really A?*/
  109|     57|                CC3   = cos(A3); /*typo 3--really A3?*/
  110|     57|                SS3   = sin(A3);
  111|     57|                A = (float)J * E;
  112|     57|                IS = 0;
  113|     57|                ID = 2 * N2;
  114|     57|                do        
  115|     69|                        {
  116|    162|                        for(I=IS;I<N;I+=ID)
  117|     93|                                {
  118|     93|                                I1 = I + J;
  119|     93|                                I2 = I1 + N4;
  120|     93|                                I3 = I2 + N4;
  121|     93|                                I4 = I3 + N4;
  122|     93|                                I5 = I + N4 - J + 2;
  123|     93|                                I6 = I5 + N4;
  124|     93|                                I7 = I6 + N4;
  125|     93|                                I8 = I7 + N4;
  126|     93|                                T1 = X[I3] * CC1 + X[I7] * SS1;
  127|     93|                                T2 = X[I7] * CC1 - X[I3] * SS1;
  128|     93|                                T3 = X[I4] * CC3 + X[I8] * SS3;
  129|     93|                                T4 = X[I8] * CC3 - X[I4] * SS3;
  130|     93|                                T5 = T1 + T3;
  131|     93|                                T6 = T2 + T4;
  132|     93|                                T3 = T1 - T3;
  133|     93|                                T4 = T2 - T4;
  134|     93|                                T2 = X[I6] + T6;
  135|     93|                                X[I3] = T6 - X[I6];
  136|     93|                                X[I8] = T2;
  137|     93|                                T2    = X[I2] - T3;
  138|     93|                                X[I7] = -X[I2] - T3;
  139|     93|                                X[I4] = T2;
  140|     93|                                T1    = X[I1] + T5;
  141|     93|                                X[I6] = X[I1] - T5;
  142|     93|                                X[I1] = T1;
  143|     93|                                T1    = X[I5] + T4;
  144|     93|                                X[I5] = X[I5] - T4;
  145|     93|                                X[I2] = T1;
  146|     93|                                }
  147|     69|                        IS = 2 * ID - N2;
  148|     69|                        ID = 4 * ID;
  149|     69|                        }while(IS<N);
  150|     57|                }
  151|      7|        }
  152|      1|return;
  153|      1|}
  154|       |
  155|       |
  156|       |void rfft(float *X, int N)
  157|      1|{
  158|      1|	__rfft(X - 1, N);
  159|      1|}
  160|       |
  161|       |}
  162|       |

/workspaces/cg/src/cgmesh/bounding_box.cpp:
    1|       |#include <math.h>
    2|       |#include <string.h>
    3|       |
    4|       |#include "bounding_box.h"
    5|       |
    6|       |bool BoundingBox::IsEmpty() const
    7|      0|{
    8|      0|	return m_bEmpty;
    9|      0|}
   10|       |
   11|       |void BoundingBox::AddPoint(float x, float y, float z)
   12|  1.98k|{
   13|  1.98k|	if (m_bEmpty)
   14|      1|	{
   15|      1|		m_bEmpty = false;
   16|       |
   17|      1|		m_min[0] = x;
   18|      1|		m_min[1] = y;
   19|      1|		m_min[2] = z;
   20|       |
   21|      1|		m_max[0] = x;
   22|      1|		m_max[1] = y;
   23|      1|		m_max[2] = z;
   24|      1|	}
   25|  1.98k|	else
   26|  1.98k|	{
   27|  1.98k|		if (m_min[0] > x) m_min[0] = x;
   28|  1.98k|		if (m_min[1] > y) m_min[1] = y;
   29|  1.98k|		if (m_min[2] > z) m_min[2] = z;
   30|       |
   31|  1.98k|		if (m_max[0] < x) m_max[0] = x;
   32|  1.98k|		if (m_max[1] < y) m_max[1] = y;
   33|  1.98k|		if (m_max[2] < z) m_max[2] = z;
   34|  1.98k|	}
   35|  1.98k|}
   36|       |
   37|       |void BoundingBox::AddBoundingBox(const BoundingBox& bbox)
   38|      0|{
   39|      0|	if (m_bEmpty)
   40|      0|	{
   41|      0|		if (!bbox.IsEmpty())
   42|      0|			*this = bbox;
   43|      0|	}
   44|      0|	else if (!bbox.IsEmpty())
   45|      0|	{
   46|      0|		for (int i = 0; i < 3; i++)
   47|      0|		{
   48|      0|			if (m_min[i] > bbox.m_min[i]) m_min[i] = bbox.m_min[i];
   49|      0|			if (m_max[i] < bbox.m_max[i]) m_max[i] = bbox.m_max[i];
   50|      0|		}
   51|      0|	}
   52|      0|}
   53|       |
   54|       |bool BoundingBox::GetMinMax(float min[3], float max[3]) const
   55|  16.3k|{
   56|  16.3k|	if (m_bEmpty)
   57|      0|		return false;
   58|       |
   59|  16.3k|	memcpy(min, m_min, 3 * sizeof(float));
   60|  16.3k|	memcpy(max, m_max, 3 * sizeof(float));
   61|       |
   62|  16.3k|	return true;
   63|  16.3k|}
   64|       |
   65|       |bool BoundingBox::GetCenter(float center[3]) const
   66|      0|{
   67|      0|	if (m_bEmpty)
   68|      0|		return false;
   69|       |
   70|      0|	for (int i = 0; i < 3; i++)
   71|      0|		center[i] = .5f * (m_min[i] + m_max[i]);
   72|      0|}
   73|       |
   74|       |float BoundingBox::GetDiagonalLength() const
   75|      0|{
   76|      0|	float length2 = 0.f;
   77|      0|	for (int i = 0; i < 3; i++)
   78|      0|		length2 += (m_max[i] - m_min[i]) * (m_max[i] - m_min[i]);
   79|      0|	return sqrt(length2);
   80|      0|}
   81|       |
   82|       |
   83|       |float BoundingBox::GetLargestLength() const
   84|      0|{
   85|      0|	float fLargestLength = m_max[0] - m_min[0];
   86|      0|	for (int i = 1; i < 3; i++)
   87|      0|		if (fLargestLength < m_max[i] - m_min[i])
   88|      0|			fLargestLength = m_max[i] - m_min[i];
   89|      0|	return fLargestLength;
   90|      0|}
   91|       |
   92|       |void BoundingBox::Translate(float x, float y, float z)
   93|      0|{
   94|      0|	if (!IsEmpty())
   95|      0|	{
   96|      0|		m_min[0] += x;
   97|      0|		m_max[0] += x;
   98|      0|		m_min[1] += y;
   99|      0|		m_max[1] += y;
  100|      0|		m_min[2] += z;
  101|      0|		m_max[2] += z;
  102|      0|	}
  103|      0|}
  104|       |
  105|       |void BoundingBox::Scale(float x, float y, float z)
  106|      0|{
  107|      0|	if (!IsEmpty())
  108|      0|	{
  109|      0|		m_min[0] *= x;
  110|      0|		m_max[0] *= x;
  111|      0|		m_min[1] *= y;
  112|      0|		m_max[1] *= y;
  113|      0|		m_min[2] *= z;
  114|      0|		m_max[2] *= z;
  115|      0|	}
  116|      0|}

/workspaces/cg/src/cgmesh/bounding_box.h:
    1|       |#pragma once
    2|       |
    3|       |class BoundingBox
    4|       |{
    5|       |public:
    6|      8|	BoundingBox() = default;
    7|       |
    8|       |	bool IsEmpty() const;
    9|       |	void AddPoint(float x, float y, float z);
   10|       |	void AddBoundingBox(const BoundingBox& bbox);
   11|       |
   12|       |	bool GetMinMax(float min[3], float max[3]) const;
   13|       |	bool GetCenter(float center[3]) const;
   14|       |	float GetDiagonalLength() const;
   15|       |	float GetLargestLength() const;
   16|       |
   17|       |	void Translate(float x, float y, float z);
   18|       |	void Scale(float x, float y, float z);
   19|       |
   20|       |private:
   21|       |	bool m_bEmpty = true;
   22|       |	float m_min[3];
   23|       |	float m_max[3];
   24|       |};

/workspaces/cg/src/cgmesh/bsp.h:
    1|       |#ifndef __BSP_H__
    2|       |#define __BSP_H__
    3|       |
    4|       |//
    5|       |// ftp://ftp.sgi.com/other/bspfaq/faq/bspfaq.html
    6|       |//
    7|       |
    8|       |#include <list>
    9|       |
   10|       |#include "../cgmath/cgmath.h"
   11|       |#include "polygon3.h"
   12|       |
   13|       |typedef enum {IN_BACK_OF = -1, COINCIDENT, IN_FRONT_OF, SPANNING} eClassification;
   14|       |
   15|       |class BSP
   16|       |{
   17|       |public:
   18|       |	BSP ();
   19|       |	~BSP ();
   20|       |
   21|       |	int Build (list<Polygon3*> polygons);
   22|      0|	const list<Polygon3*> GetPolygons (void) { return m_pPolygons; };
   23|      0|	BSP* GetBack  (void) { return m_pBack;  };
   24|      0|	BSP* GetFront (void) { return m_pFront; };
   25|       |
   26|       |private:
   27|       |	int Split_Polygon (Polygon3 *polygon, Polygon3 *front_piece, Polygon3 *back_piece);
   28|       |	eClassification Classify_Polygon (Polygon3 *polygon);
   29|       |	int Choose_Plane (list<Polygon3*> polygons);
   30|       |
   31|       |	Plane *m_pPlane;
   32|       |	list<Polygon3*> m_pPolygons;
   33|       |	BSP *m_pFront;
   34|       |	BSP *m_pBack;
   35|       |};
   36|       |
   37|       |#endif // __BSP_H__

/workspaces/cg/src/cgmesh/camera.cpp:
    1|       |#include "camera.h"
    2|       |
    3|       |Camera::Camera ()
    4|      4|{
    5|      4|}
    6|       |
    7|       |Camera::~Camera ()
    8|      4|{
    9|      4|}
   10|       |
   11|       |void Camera::SetPosition (float x, float y, float z)
   12|      4|{
   13|      4|	m_vPosition[0] = x;
   14|      4|	m_vPosition[1] = y;
   15|      4|	m_vPosition[2] = z;
   16|      4|}
   17|       |
   18|       |void Camera::SetDirection (float x, float y, float z)
   19|      4|{
   20|      4|	m_vDirection[0] = x;
   21|      4|	m_vDirection[1] = y;
   22|      4|	m_vDirection[2] = z;
   23|      4|}
   24|       |
   25|       |void Camera::SetUp (float x, float y, float z)
   26|      4|{
   27|      4|	m_vUp[0] = x;
   28|      4|	m_vUp[1] = y;
   29|      4|	m_vUp[2] = z;
   30|      4|}
   31|       |
   32|       |
   33|       |

/workspaces/cg/src/cgmesh/chull.h:
    1|       |/********************************************************************
    2|       | *
    3|       | *   +-------------+
    4|       | *  / Description /
    5|       | * +-------------+
    6|       | *
    7|       | * This code computes the 3D convex hull of a points set.
    8|       | *
    9|       | * It is based on the code from "Computational Geometry in C"
   10|       | * (Second Edition) by Joseph O'Rourke.
   11|       | * The original code can be found on the following website
   12|       | * http://cs.smith.edu/~orourke/books/ftp.html
   13|       | *
   14|       | * This adaptation provides a class Chull3D which computes the
   15|       | * 3D convex hull of a set of vertices.
   16|       | *
   17|       | *   +-------+
   18|       | *  / Input /
   19|       | * +-------+
   20|       | *
   21|       | * float *vertices;
   22|       | * int n_vertices
   23|       | * vertices are organized as follows:
   24|       | * i-th vertex   : vertices[3*i], vertices[3*i+1], vertices[3*i+2]
   25|       | * so, the size of vertices is 3*n_vertices
   26|       | *
   27|       | *   +--------+
   28|       | *  / Output /
   29|       | * +--------+
   30|       | *
   31|       | * after callingthe method "compute", the convex hull is organized
   32|       | * as follows:
   33|       | * vertices (from the class Chull3D) contains the vertices of the
   34|       | * hull. faces contains the faces defining the hull.
   35|       | * The result can be sent in a OBJ file (export_obj) or into arrays
   36|       | * for visualization.
   37|       | *
   38|       | ********************************************************************/
   39|       |#ifndef __CHULL3D_H__
   40|       |#define __CHULL3D_H__
   41|       |
   42|       |class Chull3D_vertex;
   43|       |class Chull3D_edge;
   44|       |class Chull3D_face;
   45|       |
   46|       |/***************/
   47|       |/*** Chull3D ***/
   48|       |/***************/
   49|       |class Chull3D
   50|       |{
   51|       |  friend class Chull3D_edge;
   52|       |  friend class Chull3D_face;
   53|       | public:
   54|       |  Chull3D (float *vertices, int n_vertices);
   55|      0|  ~Chull3D () {};
   56|       |
   57|       |  void compute        (void);
   58|       |
   59|       |  int  get_n_vertices (void);
   60|       |  int  get_n_faces    (void);
   61|       |
   62|       |  /* output */
   63|       |  int get_convex_hull (float **vertices, int *n_vertices, int **faces, int *n_faces);
   64|       |  int get_convex_hull_indices (int **vertices, int *n_vertices);
   65|       |  void export_obj (char *filename);
   66|       |
   67|       | private:
   68|       |  void add_vertex    (Chull3D_vertex *v);
   69|       |  void add_edge      (Chull3D_edge *e);
   70|       |  void add_face      (Chull3D_face *f);
   71|       |  void delete_vertex (Chull3D_vertex *v);
   72|       |  void delete_edge   (Chull3D_edge *e);
   73|       |  void delete_face   (Chull3D_face *f);
   74|       |
   75|       |  int are_collinear   (Chull3D_vertex *v1, Chull3D_vertex *v2, Chull3D_vertex *v3);
   76|       |  int volume_sign     (Chull3D_face *f, Chull3D_vertex *v);
   77|       |  int add_one         (Chull3D_vertex *v);
   78|       |  void clean_up       (Chull3D_vertex *vnext);
   79|       |  void clean_edges    (void);
   80|       |  void clean_faces    (void);
   81|       |  void clean_vertices (Chull3D_vertex *vnext);
   82|       |  int double_triangle (void);
   83|       |  int construct_hull  (void);
   84|       |
   85|       |  int get_vertex_index (Chull3D_vertex *v);
   86|       |
   87|       | private:
   88|       |  Chull3D_vertex *vertices;
   89|       |  Chull3D_edge *edges;
   90|       |  Chull3D_face *faces;
   91|       |};
   92|       |
   93|       |/**********************/
   94|       |/*** Chull3D_vertex ***/
   95|       |/**********************/
   96|       |class Chull3D_vertex
   97|       |{
   98|       |  friend class Chull3D;
   99|       |  friend class Chull3D_face;
  100|       | public:
  101|      0|  Chull3D_vertex () {};
  102|       |  Chull3D_vertex (float x, float y, float z);
  103|       |
  104|       |  int index; // additional data
  105|       |
  106|       | private:
  107|       |  float          pt[3];
  108|       |  Chull3D_edge   *duplicate;
  109|       |  short          on_hull;
  110|       |  short          processed;
  111|       |  Chull3D_vertex *prev, *next;
  112|       |};
  113|       |
  114|       |/********************/
  115|       |/*** Chull3D_edge ***/
  116|       |/********************/
  117|       |class Chull3D_edge
  118|       |{
  119|       |  friend class Chull3D;
  120|       |  friend class Chull3D_face;
  121|       | public:
  122|       |  Chull3D_edge (Chull3D *hull3D);
  123|       |
  124|       | private:
  125|       |  Chull3D_face   *adj_faces[2];
  126|       |  Chull3D_vertex *end_points[2];
  127|       |  Chull3D_face   *new_face;
  128|       |  int            to_delete;
  129|       |  Chull3D_edge   *prev, *next;
  130|       |};
  131|       |
  132|       |/********************/
  133|       |/*** Chull3D_face ***/
  134|       |/********************/
  135|       |class Chull3D_face
  136|       |{
  137|       |  friend class Chull3D;
  138|       | public:
  139|       |  Chull3D_face (Chull3D *hull3D);
  140|       |  Chull3D_face (Chull3D *hull3D, Chull3D_vertex *v1, Chull3D_vertex *v2, Chull3D_vertex *v3, Chull3D_face *f);
  141|       |  Chull3D_face (Chull3D *hull3D, Chull3D_edge *e, Chull3D_vertex *v);
  142|       |
  143|       | private:
  144|       |  void make_ccw (Chull3D_edge *e, Chull3D_vertex *v);
  145|       |
  146|       | private:
  147|       |  Chull3D_edge   *edges[3];
  148|       |  Chull3D_vertex *vertices[3];
  149|       |  int            visible;
  150|       |  Chull3D_face   *prev, *next;
  151|       |};
  152|       |
  153|       |#endif /* __CHULL3D_H__ */
  154|       |

/workspaces/cg/src/cgmesh/descriptor_distribution_around_axis.h:
    1|       |#ifndef __DISTRIBUTION_AROUND_AXIS_H__
    2|       |#define __DISTRIBUTION_AROUND_AXIS_H__
    3|       |
    4|       |#include "mesh_half_edge.h"
    5|       |
    6|       |class Cdistribution_around_axis
    7|       |{
    8|       | public:
    9|       |  Cdistribution_around_axis (Mesh_half_edge *model);
   10|      0|  ~Cdistribution_around_axis () {};
   11|       |
   12|       |  enum orientation_type {ORIENTATION_PCA, ORIENTATION_WEIGHTED_VERTICES, ORIENTATION_BARYCENTER, ORIENTATION_CPCA};
   13|       |
   14|       |  /* frist order */
   15|       |  void compute_first_order_distributions  (orientation_type type);
   16|       |
   17|      0|  float *get_lengths    (void) { return lengths;    };
   18|      0|  float *get_dmeans     (void) { return dmeans;     };
   19|      0|  float *get_variances  (void) { return variances;  };
   20|      0|  float *get_deviations (void) { return deviations; };
   21|       |
   22|       |  /* second order */
   23|       |  /*
   24|       |   * Reference
   25|       |   * "Nefertiti: a query by content system for three-dimensional model and image databases management"
   26|       |   * Eric Paquet, Marc Rioux
   27|       |   * Image and Vision Computing, 17, pp 157-166, 1999
   28|       |   */
   29|       |  void compute_first_order_distributions_paquet  (orientation_type type, int npoints, int nbins);
   30|       |  void compute_second_order_distributions_paquet (orientation_type type, int npoints, int nbins);
   31|       |  void normalize_distributions (void);
   32|       |
   33|       |  void export_histogram1k  (char *filename);
   34|       |  void export_histogram2k1 (char *filename);
   35|       |  void export_histogram2k2 (char *filename);
   36|       |  void export_histogram3k  (char *filename);
   37|       |
   38|      0|  float  *get_histogram1k  (void) { return histogram1k; };
   39|      0|  float  *get_histogram2k1 (void) { return histogram2k1; };
   40|      0|  float  *get_histogram2k2 (void) { return histogram2k2; };
   41|      0|  float **get_histogram3k  (void) { return histogram3k; };
   42|       |
   43|       | private:
   44|       |  float *cumulative_areas;
   45|       |  int n_cumulative_areas;
   46|       |  float total_area;
   47|       |  void compute_cumulative_areas (void);
   48|       |  int  find_area_position (float random_area, int istart, int iend);
   49|       |  int select_random_point (vec3 point); // return the id of the face containing the point
   50|       |
   51|       |  void compute_length_dmean_variance_deviation (vec3 axis, float *_length, float *_dmean, float *_variance, float *_deviation);
   52|       |
   53|       |  Mesh_half_edge *model;
   54|       |  int nv, nf;
   55|       |  float *v;
   56|       |  Face **f;
   57|       |
   58|       |  /* first order distributions */
   59|       |  float lengths[3], dmeans[3], variances[3], deviations[3];
   60|       |
   61|       |  /* second order distributions */
   62|       |  int npoints;
   63|       |  int nbins;
   64|       |  float *histogram1k;
   65|       |  float *histogram2k1, *histogram2k2;
   66|       |  float **histogram3k;
   67|       |};
   68|       |
   69|       |#endif /* __MODEL3D_FEATURES_DISTRIBUTION_AROUND_AXIS_H__ */

/workspaces/cg/src/cgmesh/descriptor_shape_distribution_osada.h:
    1|       |#ifndef __SHAPE_DISTRIBUTION_OSADA_H__
    2|       |#define __SHAPE_DISTRIBUTION_OSADA_H__
    3|       |
    4|       |#include "mesh_half_edge.h"
    5|       |
    6|       |//
    7|       |// Reference :
    8|       |// "Matching 3D Models with Shape Distributions"
    9|       |// Robert Osada, Thomas Funkhouser, Bernard Chazelle, David Dobkin
   10|       |// Proceedings of the International Conference on Shape Modeling & Applications, 2001
   11|       |//
   12|       |//
   13|       |// Choix des paramtres:
   14|       |// A3 :
   15|       |// n selected points -> 3*factorielle(n)/(6*factorielle(n-3)) samples
   16|       |// D1 :
   17|       |// n selected points -> n samples
   18|       |// D2 :
   19|       |// n selected points -> n*(n-1))/2 samples
   20|       |// D3 :
   21|       |// n selected points -> factorielle(n)/(6*factorielle(n-3)) samples
   22|       |// D4 :
   23|       |// n selected points -> factorielle(n)/(24*factorielle(n-4)) samples
   24|       |//
   25|       |
   26|       |class Cshape_distribution_osada
   27|       |{
   28|       | public:
   29|       |  Cshape_distribution_osada (int nv, float *v, int nf, unsigned int *f);
   30|       |  ~Cshape_distribution_osada ();
   31|       |
   32|       |  enum shape_function_type {A3, D1, D2, D3, D4};
   33|       |
   34|      0|  void init_random (int seed) { srand (seed); };
   35|       |
   36|       |  void compute_distribution (shape_function_type type, int n_points, int n_bins);
   37|       |  void evaluate_distribution (shape_function_type type, int n_data, int n_bins);
   38|      0|  float *get_histogram (void) { return histogram; };
   39|       |  void normalize_distribution (void);
   40|       |  void export_distribution (char *filename);
   41|       |
   42|       | private:
   43|       |  void compute_distribution_a3 (int _n_bins);
   44|       |  void compute_distribution_d1 (int _n_bins);
   45|       |  void compute_distribution_d2 (int _n_bins);
   46|       |  void compute_distribution_d3 (int _n_bins);
   47|       |  void compute_distribution_d4 (int _n_bins);
   48|       |
   49|       |  void evaluate_distribution_a3 (int n_data, int _n_bins);
   50|       |  void evaluate_distribution_d1 (int n_data, int _n_bins);
   51|       |  void evaluate_distribution_d2 (int n_data, int _n_bins);
   52|       |  void evaluate_distribution_d3 (int n_data, int _n_bins);
   53|       |  void evaluate_distribution_d4 (int n_data, int _n_bins);
   54|       |
   55|       |  int  find_area_position (float random_area, int istart, int iend);
   56|       |  void compute_cumulative_areas (void);
   57|       |  void select_points (int _n_points);
   58|       | public:
   59|       |  int select_random_point (vec3 &point); // return the id of the face containing the point
   60|       |
   61|       | private:
   62|       |  int nv, nf;
   63|       |  float *v;
   64|       |  unsigned int *f;
   65|       |  
   66|       |  float *cumulative_areas;
   67|       |  int n_cumulative_areas;
   68|       |  float total_area;
   69|       |
   70|       |  float *selected_points;
   71|       |  int n_selected_points;
   72|       |
   73|       |  float *histogram;
   74|       |  int n_bins;
   75|       |};
   76|       |
   77|       |#endif /* __SHAPE_DISTRIBUTION_OSADA_H__ */

/workspaces/cg/src/cgmesh/endianness.h:
    1|       |#ifndef ENDIANNESS_H
    2|       |#define ENDIANNESS_H
    3|       |
    4|       |#include <stdint.h>
    5|       |
    6|       |#define L_ENDIAN 0
    7|       |#define B_ENDIAN 1
    8|       |
    9|       |int get_endianness();
   10|       |
   11|       |uint64_t swpd(double d);
   12|       |double uswpd(uint64_t d);
   13|       |
   14|       |float swapf(float);
   15|       |double swapd(double);
   16|       |void swaps(uint16_t *x);
   17|       |void swapi(uint32_t *x);
   18|       |void swapl(uint64_t *x);
   19|       |
   20|       |// LITTLE AND BIG ENDIAN CONVERSION
   21|       |inline void swap_endian_2 (void *val)
   22|      0|{
   23|      0|	unsigned short *ival = (unsigned short*) val;
   24|      0|	*ival = ((*ival >> 8) & 0x000000ff) |
   25|      0|		((*ival << 8) & 0x0000ff00);
   26|      0|}
   27|       |
   28|       |inline void swap_endian_4 (void *val)
   29|      0|{
   30|      0|	unsigned long *ival = (unsigned long*) val;
   31|      0|	*ival = ((*ival >> 24) & 0x000000ff) |
   32|      0|		((*ival >>  8) & 0x0000ff00) |
   33|      0|		((*ival <<  8) & 0x00ff0000) |
   34|      0|		((*ival << 24) & 0xff000000);
   35|      0|}
   36|       |
   37|       |#endif

/workspaces/cg/src/cgmesh/extracted_line.h:
    1|       |#ifndef __EXTRACTED_LINE_H__
    2|       |#define __EXTRACTED_LINE_H__
    3|       |
    4|       |#include "../cgmath/cgmath.h"
    5|       |
    6|       |class Cextracted_line
    7|       |{
    8|       |	friend class Cset_lines;
    9|       | public:
   10|       |  enum weight_method
   11|       |  {
   12|       |    WEIGHT_METHOD_         = 0
   13|       |  };
   14|       |
   15|       |public:
   16|       |  Cextracted_line (Vector3f _pluecker1, Vector3f _pluecker2, Vector3f _begin, Vector3f _end, int _n_vertices, int *_ivertices, Vector3f *_vertices, float weight = 0.0);
   17|       |  ~Cextracted_line ();
   18|       |  
   19|       |  /* merging */
   20|       |  void merge (Cextracted_line *line);
   21|       |
   22|       |  /* adjust begin and end to fit on the concerned vertices */
   23|       |  void compute_extremities (void);
   24|       |
   25|       |  /* apply a least square fitting to adjust the line */
   26|       |  void apply_least_square_fitting (void);
   27|       |
   28|       |  /* setters */
   29|       |  void add_vertex (int _ivertex, Vector3f _vertex);
   30|       |
   31|       |  /* getters */
   32|       |  int  get_n_vertices (void);
   33|       |  int* get_ivertices  (void);
   34|       |  Vector3f* get_vertices   (void);
   35|       |  void get_begin (Vector3f _begin);
   36|       |  void get_end   (Vector3f _end);
   37|       |  void get_center (Vector3f _center);
   38|       |  void get_direction (Vector3f d);
   39|       |
   40|      0|  float get_length (void)         { return length; };
   41|      0|  float get_density (void)        { return density; };
   42|      0|  float get_mean_deviation (void) { return mean_deviation; };
   43|      0|  float get_mean_curvature (void) { return mean_curvature; }; // problem to compute it correctly
   44|       |
   45|       |  /* misc */
   46|       |  int is_index_in_line (int index);
   47|       |
   48|       |  /* weight */
   49|       |  float get_weight (void);
   50|       |  void   set_weight (float _weight);
   51|       |  void   compute_weight (weight_method id);
   52|       |  void   normalize_weight (void);
   53|       |
   54|       |  /* color */
   55|       |  void set_color (float r, float g, float b);
   56|       |  void get_color (float *r, float *g, float *b);
   57|       |
   58|       |  // dump
   59|       |  void dump (void);
   60|       |
   61|       | private:
   62|       |  void compute_density (void);
   63|       |  void compute_length (void);
   64|       |  void compute_mean_deviation (void);
   65|       |  void compute_mean_curvature (void);
   66|       |  void update_parameters (void);
   67|       |
   68|       |private:
   69|       |  Vector3f pluecker1, pluecker2;
   70|       |  Vector3f begin, end;
   71|       |  int n_vertices;
   72|       |  int *ivertices;
   73|       |  Vector3f *vertices;
   74|       |  float density, length, mean_deviation;
   75|       |  float mean_curvature;
   76|       |  float weight;
   77|       |
   78|       |  // visu
   79|       |  float r, g, b;
   80|       |};
   81|       |
   82|       |#endif // __EXTRACTED_LINE_H__

/workspaces/cg/src/cgmesh/geodesic_algorithm_base.h:
    1|       |//Copyright (C) 2008 Danil Kirsanov, MIT License
    2|       |
    3|       |#ifndef GEODESIC_ALGORITHM_BASE_122806
    4|       |#define GEODESIC_ALGORITHM_BASE_122806
    5|       |
    6|       |#include "geodesic_mesh.h"
    7|       |#include "geodesic_constants_and_simple_functions.h"
    8|       |#include <iostream>
    9|       |#include <ctime>
   10|       |
   11|       |namespace geodesic{
   12|       |
   13|       |class GeodesicAlgorithmBase
   14|       |{
   15|       |public:
   16|       |    enum AlgorithmType
   17|       |    {
   18|       |	    EXACT,
   19|       |	    DIJKSTRA,
   20|       |	    SUBDIVISION,
   21|       |	    UNDEFINED_ALGORITHM
   22|       |    };
   23|       |
   24|       |	GeodesicAlgorithmBase(geodesic::Mesh* mesh):
   25|       |		m_type(UNDEFINED_ALGORITHM),
   26|       |		m_max_propagation_distance(1e100),
   27|       |		m_mesh(mesh)
   28|      0|	{};	
   29|       |
   30|      0|	virtual ~GeodesicAlgorithmBase(){};
   31|       |
   32|       |	virtual void propagate(std::vector<SurfacePoint>& sources,
   33|       |   						   double max_propagation_distance = GEODESIC_INF,			//propagation algorithm stops after reaching the certain distance from the source
   34|       |						   std::vector<SurfacePoint>* stop_points = NULL) = 0; //or after ensuring that all the stop_points are covered
   35|       |
   36|       |	virtual void trace_back(SurfacePoint& destination,		//trace back piecewise-linear path
   37|       |							std::vector<SurfacePoint>& path) = 0;
   38|       |
   39|       |	void geodesic(SurfacePoint& source,
   40|       |						  SurfacePoint& destination,
   41|       |						  std::vector<SurfacePoint>& path); //lazy people can find geodesic path with one function call
   42|       |
   43|       |	void geodesic(std::vector<SurfacePoint>& sources,
   44|       |						  std::vector<SurfacePoint>& destinations,
   45|       |						  std::vector<std::vector<SurfacePoint> >& paths); //lazy people can find geodesic paths with one function call
   46|       |
   47|       |	virtual unsigned best_source(SurfacePoint& point,			//after propagation step is done, quickly find what source this point belongs to and what is the distance to this source
   48|       |								 double& best_source_distance) = 0; 
   49|       |
   50|       |	virtual void print_statistics()		//print info about timing and memory usage in the propagation step of the algorithm
   51|      0|	{
   52|      0|		std::cout << "propagation step took " << m_time_consumed << " seconds " << std::endl;
   53|      0|	};	
   54|       |
   55|      0|	AlgorithmType type(){return m_type;};
   56|       |
   57|       |	virtual std::string name();
   58|       |
   59|      0|	geodesic::Mesh* mesh(){return m_mesh;};
   60|       |protected:
   61|       |
   62|       |	void set_stop_conditions(std::vector<SurfacePoint>* stop_points, 
   63|       |						     double stop_distance);
   64|       |	double stop_distance()
   65|      0|	{
   66|      0|		return m_max_propagation_distance;
   67|      0|	}
   68|       |
   69|       |	AlgorithmType m_type;					   // type of the algorithm
   70|       |
   71|       |	typedef std::pair<vertex_pointer, double> stop_vertex_with_distace_type;
   72|       |	std::vector<stop_vertex_with_distace_type> m_stop_vertices; // algorithm stops propagation after covering certain vertices
   73|       |	double m_max_propagation_distance;			 // or reaching the certain distance
   74|       |
   75|       |	geodesic::Mesh* m_mesh;
   76|       |
   77|       |	double m_time_consumed;		//how much time does the propagation step takes
   78|       |	double m_propagation_distance_stopped;		//at what distance (if any) the propagation algorithm stopped 
   79|       |};
   80|       |
   81|       |inline double length(std::vector<SurfacePoint>& path)
   82|      0|{
   83|      0|	double length = 0;
   84|      0|	if(!path.empty())
   85|      0|	{
   86|      0|		for(unsigned i=0; i<path.size()-1; ++i)
   87|      0|		{
   88|      0|			length += path[i].distance(&path[i+1]);
   89|      0|		}
   90|      0|	}
   91|      0|	return length;
   92|      0|}
   93|       |
   94|       |inline void print_info_about_path(std::vector<SurfacePoint>& path)
   95|      0|{
   96|      0|	std::cout << "number of the points in the path = " << path.size()
   97|      0|			  << ", length of the path = " << length(path) 
   98|      0|			  << std::endl;
   99|      0|}
  100|       |
  101|       |inline std::string GeodesicAlgorithmBase::name()
  102|      0|{
  103|      0|	switch(m_type)
  104|      0|	{
  105|      0|	case EXACT:
  106|      0|		return "exact";
  107|      0|	case DIJKSTRA:
  108|      0|		return "dijkstra";
  109|      0|	case SUBDIVISION:
  110|      0|		return "subdivision";
  111|      0|	default:
  112|      0|	case UNDEFINED_ALGORITHM:
  113|      0|		return "undefined";
  114|      0|	}
  115|      0|}
  116|       |
  117|       |inline void GeodesicAlgorithmBase::geodesic(SurfacePoint& source,
  118|       |											SurfacePoint& destination,
  119|       |											std::vector<SurfacePoint>& path) //lazy people can find geodesic path with one function call
  120|      0|{
  121|      0|	std::vector<SurfacePoint> sources(1, source);
  122|      0|	std::vector<SurfacePoint> stop_points(1, destination);
  123|      0|	double const max_propagation_distance = GEODESIC_INF;
  124|      0|
  125|      0|	propagate(sources, 
  126|      0|			  max_propagation_distance,
  127|      0|			  &stop_points);
  128|      0|
  129|      0|	trace_back(destination, path);
  130|      0|}
  131|       |
  132|       |inline void GeodesicAlgorithmBase::geodesic(std::vector<SurfacePoint>& sources,
  133|       |											std::vector<SurfacePoint>& destinations,
  134|       |											std::vector<std::vector<SurfacePoint> >& paths) //lazy people can find geodesic paths with one function call
  135|      0|{
  136|      0|	double const max_propagation_distance = GEODESIC_INF;
  137|      0|
  138|      0|	propagate(sources, 
  139|      0|			  max_propagation_distance,
  140|      0|			  &destinations);		//we use desinations as stop points
  141|      0|
  142|      0|	paths.resize(destinations.size());
  143|      0|
  144|      0|	for(unsigned i=0; i<paths.size(); ++i)
  145|      0|	{
  146|      0|		trace_back(destinations[i], paths[i]);
  147|      0|	}
  148|      0|}
  149|       |
  150|       |inline void GeodesicAlgorithmBase::set_stop_conditions(std::vector<SurfacePoint>* stop_points, 
  151|       |														double stop_distance)
  152|      0|{
  153|      0|	m_max_propagation_distance = stop_distance;
  154|      0|
  155|      0|	if(!stop_points)
  156|      0|	{
  157|      0|		m_stop_vertices.clear();
  158|      0|		return;
  159|      0|	}
  160|      0|
  161|      0|	m_stop_vertices.resize(stop_points->size());
  162|      0|
  163|      0|	std::vector<vertex_pointer> possible_vertices;
  164|      0|	for(unsigned i = 0; i < stop_points->size(); ++i)
  165|      0|	{
  166|      0|		SurfacePoint* point = &(*stop_points)[i];
  167|      0|
  168|      0|		possible_vertices.clear();
  169|      0|		m_mesh->closest_vertices(point, &possible_vertices);
  170|      0|		
  171|      0|		vertex_pointer closest_vertex = NULL;
  172|      0|		double min_distance = 1e100;
  173|      0|		for(unsigned j = 0; j < possible_vertices.size(); ++j)
  174|      0|		{
  175|      0|			double distance = point->distance(possible_vertices[j]);
  176|      0|			if(distance < min_distance)
  177|      0|			{
  178|      0|				min_distance = distance;
  179|      0|				closest_vertex = possible_vertices[j];
  180|      0|			}
  181|      0|		}
  182|      0|		assert(closest_vertex);
  183|      0|
  184|      0|		m_stop_vertices[i].first = closest_vertex;
  185|      0|		m_stop_vertices[i].second = min_distance;
  186|      0|	}
  187|      0|}
  188|       |
  189|       |}//geodesic
  190|       |
  191|       |#endif //GEODESIC_ALGORITHM_BASE_122806

/workspaces/cg/src/cgmesh/geodesic_constants_and_simple_functions.h:
    1|       |//Copyright (C) 2008 Danil Kirsanov, MIT License
    2|       |#ifndef GEODESIC_CONSTANTS_20071231
    3|       |#define GEODESIC_CONSTANTS_20071231
    4|       |
    5|       |// some constants and simple math functions
    6|       |
    7|       |#include <assert.h>
    8|       |#include <math.h>
    9|       |#include <limits>
   10|       |#include <fstream>
   11|       |
   12|       |namespace geodesic{
   13|       |
   14|       |#ifndef M_PI
   15|       |#define M_PI 3.14159265358979323846
   16|       |#endif
   17|       |
   18|       |//double const GEODESIC_INF = std::numeric_limits<double>::max();
   19|       |double const GEODESIC_INF = 1e100;
   20|       |
   21|       |//in order to avoid numerical problems with "infinitely small" intervals,
   22|       |//we drop all the intervals smaller than SMALLEST_INTERVAL_RATIO*edge_length
   23|       |double const SMALLEST_INTERVAL_RATIO = 1e-6;		
   24|       |//double const SMALL_EPSILON = 1e-10;
   25|       |
   26|       |
   27|       |inline double cos_from_edges(double const a,			//compute the cosine of the angle given the lengths of the edges
   28|       |			     double const b,
   29|       |			     double const c)
   30|      0|{
   31|      0|	assert(a>1e-50);
   32|      0|	assert(b>1e-50);
   33|      0|	assert(c>1e-50);
   34|      0|
   35|      0|	double result = (b*b + c*c - a*a)/(2.0*b*c);
   36|      0|	result = (std::max)(result, -1.0);
   37|      0|	return (std::min)(result, 1.0);
   38|      0|}
   39|       |
   40|       |inline double angle_from_edges(double const a,			//compute the cosine of the angle given the lengths of the edges
   41|       |							   double const b,
   42|       |							   double const c)
   43|      0|{
   44|      0|	return acos(cos_from_edges(a,b,c));
   45|      0|}
   46|       |
   47|       |template<class Points, class Faces>
   48|       |inline bool read_mesh_from_file(char* filename,
   49|       |				Points& points,
   50|       |				Faces& faces)
   51|       |{
   52|       |	std::ifstream file(filename);
   53|       |	assert(file.is_open());
   54|       |	if(!file.is_open()) return false;
   55|       |	
   56|       |	unsigned num_points;
   57|       |	file >> num_points;
   58|       |	assert(num_points>=3);
   59|       |
   60|       |	unsigned num_faces;
   61|       |	file >> num_faces;
   62|       |
   63|       |	points.resize(num_points*3);
   64|       |	for(typename Points::iterator i=points.begin(); i!=points.end(); ++i)
   65|       |	{
   66|       |		file >> *i;
   67|       |	}
   68|       |
   69|       |	faces.resize(num_faces*3);
   70|       |	for(typename Faces::iterator i=faces.begin(); i!=faces.end(); ++i)
   71|       |	{
   72|       |		file >> *i;
   73|       |	}
   74|       |	file.close();
   75|       |
   76|       |	return true;
   77|       |}
   78|       |
   79|       |} //geodesic
   80|       |
   81|       |#endif	//GEODESIC_CONSTANTS_20071231

/workspaces/cg/src/cgmesh/geodesic_memory.h:
    1|       |//Copyright (C) 2008 Danil Kirsanov, MIT License
    2|       |#ifndef _GEODESIC_MEMORY_20071231
    3|       |#define _GEODESIC_MEMORY_20071231
    4|       |
    5|       |//two fast and simple memory allocators
    6|       |
    7|       |#include <vector>
    8|       |#include <memory>
    9|       |#include <assert.h>
   10|       |#include <math.h>
   11|       |
   12|       |namespace geodesic{
   13|       |
   14|       |template<class T>	//quickly allocates multiple elements of a given type; no deallocation
   15|       |class SimpleMemoryAllocator
   16|       |{
   17|       |public:
   18|       |	typedef T* pointer;
   19|       |
   20|       |	SimpleMemoryAllocator(unsigned block_size = 0, 
   21|       |			      unsigned max_number_of_blocks = 0)
   22|       |	{
   23|       |		reset(block_size, max_number_of_blocks);
   24|       |	};
   25|       |
   26|       |	~SimpleMemoryAllocator(){};
   27|       |
   28|       |	void reset(unsigned block_size, unsigned max_number_of_blocks)
   29|      0|	{
   30|      0|		m_block_size = block_size;
   31|      0|		m_max_number_of_blocks = max_number_of_blocks;
   32|      0|		m_current_position = 0;
   33|      0|		m_storage.reserve(max_number_of_blocks);
   34|      0|		m_storage.resize(1);
   35|      0|		m_storage[0].resize(block_size);
   36|      0|	};
   37|       |
   38|       |	pointer allocate(unsigned const n) //allocate n units
   39|      0|	{
   40|      0|		assert(n < m_block_size);
   41|      0|
   42|      0|		if(m_current_position + n >= m_block_size)
   43|      0|		{
   44|      0|			m_storage.push_back( std::vector<T>() );
   45|      0|			m_storage.back().resize(m_block_size);
   46|      0|			m_current_position = 0;
   47|      0|		}
   48|      0|		pointer result = & m_storage.back()[m_current_position];
   49|      0|		m_current_position += n;
   50|      0|
   51|      0|		return result;
   52|      0|	};
   53|       |private:
   54|       |	std::vector<std::vector<T> > m_storage;	
   55|       |	unsigned m_block_size;				//size of a single block
   56|       |	unsigned m_max_number_of_blocks;		//maximum allowed number of blocks
   57|       |	unsigned m_current_position;			//first unused element inside the current block
   58|       |};
   59|       |
   60|       |
   61|       |template<class T>	//quickly allocates and deallocates single elements of a given type
   62|       |class MemoryAllocator
   63|       |{
   64|       |public:
   65|       |	typedef T* pointer;
   66|       |
   67|       |	MemoryAllocator(unsigned block_size = 1024, unsigned max_number_of_blocks = 1024)
   68|       |	{
   69|       |		reset(block_size, max_number_of_blocks);
   70|       |	};
   71|       |
   72|       |	~MemoryAllocator(){};
   73|       |
   74|       |	void clear()
   75|       |	{
   76|       |		reset(m_block_size, m_max_number_of_blocks);
   77|       |	}
   78|       |
   79|       |	void reset(unsigned block_size, unsigned max_number_of_blocks)
   80|       |	{
   81|       |		m_block_size = block_size;
   82|       |		m_max_number_of_blocks = max_number_of_blocks;
   83|       |
   84|       |		assert(m_block_size > 0);
   85|       |		assert(m_max_number_of_blocks > 0);
   86|       |
   87|       |		m_current_position = 0;
   88|       |
   89|       |		m_storage.reserve(max_number_of_blocks);
   90|       |		m_storage.resize(1);
   91|       |		m_storage[0].resize(block_size);
   92|       |
   93|       |		m_deleted.clear();
   94|       |		m_deleted.reserve(2*block_size);
   95|       |	};
   96|       |
   97|       |	pointer allocate()		//allocates single unit of memory
   98|       |	{
   99|       |		pointer result;
  100|       |		if(m_deleted.empty())
  101|       |		{
  102|       |			if(m_current_position + 1 >= m_block_size)
  103|       |			{
  104|       |				m_storage.push_back( std::vector<T>() );
  105|       |				m_storage.back().resize(m_block_size);
  106|       |				m_current_position = 0;
  107|       |			}
  108|       |			result = & m_storage.back()[m_current_position];
  109|       |			++m_current_position;
  110|       |		}
  111|       |		else
  112|       |		{
  113|       |			result = m_deleted.back();
  114|       |			m_deleted.pop_back();
  115|       |		}
  116|       |
  117|       |		return result;
  118|       |	};
  119|       |
  120|       |	void deallocate(pointer p)		//allocate n units
  121|       |	{
  122|       |		if(m_deleted.size() < m_deleted.capacity())
  123|       |		{
  124|       |			m_deleted.push_back(p);
  125|       |		}
  126|       |	};
  127|       |
  128|       |private:
  129|       |	std::vector<std::vector<T> > m_storage;
  130|       |	unsigned m_block_size;				//size of a single block
  131|       |	unsigned m_max_number_of_blocks;		//maximum allowed number of blocks
  132|       |	unsigned m_current_position;			//first unused element inside the current block
  133|       |
  134|       |	std::vector<pointer> m_deleted;			//pointers to deleted elemets
  135|       |};
  136|       |
  137|       |
  138|       |class OutputBuffer
  139|       |{
  140|       |public:
  141|       |	OutputBuffer():
  142|       |		m_num_bytes(0)
  143|      0|	{}
  144|       |
  145|       |	void clear()
  146|      0|	{
  147|      0|		m_num_bytes = 0;
  148|      0|		m_buffer = std::make_shared<double>();
  149|      0|	}
  150|       |
  151|       |	template<class T>
  152|       |	T* allocate(unsigned n)
  153|       |	{
  154|       |		double wanted = n*sizeof(T);
  155|       |		if(wanted > m_num_bytes)
  156|       |		{
  157|       |			unsigned new_size = (unsigned) ceil(wanted / (double)sizeof(double));
  158|       |			m_buffer = std::make_shared<double>(new double[new_size]);
  159|       |			m_num_bytes = new_size*sizeof(double);
  160|       |		}
  161|       |
  162|       |		return (T*)m_buffer.get();
  163|       |	}
  164|       |
  165|       |	template <class T>
  166|       |	T* get()
  167|       |	{
  168|       |		return (T*)m_buffer.get();
  169|       |	}
  170|       |
  171|       |	template<class T>
  172|       |	unsigned capacity()
  173|       |	{
  174|       |		return (unsigned)floor((double)m_num_bytes/(double)sizeof(T));
  175|       |	};
  176|       |
  177|       |private:
  178|       |
  179|       |	std::shared_ptr<double> m_buffer;
  180|       |	unsigned m_num_bytes;
  181|       |};
  182|       |
  183|       |} //geodesic
  184|       |
  185|       |#endif	//_GEODESIC_MEMORY_20071231

/workspaces/cg/src/cgmesh/geodesic_mesh.h:
    1|       |//Copyright (C) 2008 Danil Kirsanov, MIT License
    2|       |#ifndef GEODESIC_MESH_20071231
    3|       |#define GEODESIC_MESH_20071231
    4|       |
    5|       |#include <cstddef>
    6|       |#include <vector>
    7|       |#include <cmath>
    8|       |#include <iostream>
    9|       |#include <algorithm>
   10|       |#include <fstream>
   11|       |
   12|       |#include "geodesic_mesh_elements.h"
   13|       |#include "geodesic_memory.h"
   14|       |#include "geodesic_constants_and_simple_functions.h"
   15|       |
   16|       |namespace geodesic{
   17|       |
   18|       |struct edge_visible_from_source
   19|       |{
   20|       |	unsigned source;
   21|       |	edge_pointer edge;
   22|       |};
   23|       |
   24|       |class Mesh
   25|       |{
   26|       |public:
   27|       |	Mesh()
   28|      0|	{};
   29|       |
   30|      0|	~Mesh(){};
   31|       |
   32|       |	template<class Points, class Faces>
   33|       |	void initialize_mesh_data(unsigned num_vertices,
   34|       |				  Points& p, 
   35|       |				  unsigned num_faces,
   36|       |				  Faces& tri);		//build mesh from regular point-triangle representation
   37|       |
   38|       |	template<class Points, class Faces>
   39|       |	void initialize_mesh_data(Points& p, Faces& tri);		//build mesh from regular point-triangle representation
   40|       |
   41|      0|	std::vector<Vertex>& vertices(){return m_vertices;};
   42|      0|	std::vector<Edge>& edges(){return m_edges;};
   43|      0|	std::vector<Face>& faces(){return m_faces;};
   44|       |
   45|       |	unsigned closest_vertices(SurfacePoint* p, std::vector<vertex_pointer>* storage = NULL);		//list vertices closest to the point
   46|       |
   47|       |private:
   48|       |
   49|       |	void build_adjacencies();		//build internal structure of the mesh
   50|       |	bool verify();					//verifies connectivity of the mesh and prints some debug info
   51|       |
   52|       |	typedef void* void_pointer;
   53|       |	void_pointer allocate_pointers(unsigned n) 
   54|      0|	{
   55|      0|		return m_pointer_allocator.allocate(n); 
   56|      0|	}
   57|       |
   58|       |	std::vector<Vertex> m_vertices;
   59|       |	std::vector<Edge> m_edges;
   60|       |	std::vector<Face> m_faces;
   61|       |
   62|       |	SimpleMemoryAllocator<void_pointer> m_pointer_allocator;	//fast memory allocating for Face/Vertex/Edge cross-references
   63|       |};
   64|       |
   65|       |inline unsigned Mesh::closest_vertices(SurfacePoint* p, std::vector<vertex_pointer>* storage)
   66|      0|{
   67|      0|	assert(p->type() != UNDEFINED_POINT);
   68|      0|
   69|      0|	if(p->type() == VERTEX)
   70|      0|	{
   71|      0|		if(storage)
   72|      0|		{
   73|      0|			storage->push_back(static_cast<vertex_pointer>(p->base_element()));
   74|      0|		}
   75|      0|		return 1;
   76|      0|	}
   77|      0|	else if(p->type() == FACE)
   78|      0|	{
   79|      0|		if(storage)
   80|      0|		{
   81|      0|			vertex_pointer* vp= p->base_element()->adjacent_vertices().begin();
   82|      0|			storage->push_back(*vp);
   83|      0|			storage->push_back(*(vp+1));
   84|      0|			storage->push_back(*(vp+2));
   85|      0|		}
   86|      0|		return 2;
   87|      0|	}
   88|      0|	else if(p->type() == EDGE)		//for edge include all 4 adjacent vertices
   89|      0|	{
   90|      0|		edge_pointer edge = static_cast<edge_pointer>(p->base_element());
   91|      0|
   92|      0|		if(storage)
   93|      0|		{
   94|      0|			storage->push_back(edge->adjacent_vertices()[0]);
   95|      0|			storage->push_back(edge->adjacent_vertices()[1]);
   96|      0|
   97|      0|			for(unsigned i = 0; i < edge->adjacent_faces().size(); ++i)
   98|      0|			{
   99|      0|				face_pointer face = edge->adjacent_faces()[i];
  100|      0|				storage->push_back(face->opposite_vertex(edge));
  101|      0|			}
  102|      0|		}
  103|      0|		return 2 + edge->adjacent_faces().size();
  104|      0|	}
  105|      0|
  106|      0|	assert(0);
  107|      0|	return 0;
  108|      0|}
  109|       |
  110|       |template<class Points, class Faces>
  111|       |void Mesh::initialize_mesh_data(Points& p, Faces& tri)		//build mesh from regular point-triangle representation
  112|       |{
  113|       |	assert(p.size() % 3 == 0);
  114|       |	unsigned const num_vertices = p.size() / 3;
  115|       |	assert(tri.size() % 3 == 0);
  116|       |	unsigned const num_faces = tri.size() / 3; 
  117|       |
  118|       |	initialize_mesh_data(num_vertices, p, num_faces, tri);
  119|       |}
  120|       |
  121|       |template<class Points, class Faces>
  122|       |void Mesh::initialize_mesh_data(unsigned num_vertices,
  123|       |				Points& p, 
  124|       |				unsigned num_faces,
  125|       |				Faces& tri)
  126|       |{
  127|       |	unsigned const approximate_number_of_internal_pointers = (num_vertices + num_faces)*4;
  128|       |	unsigned const max_number_of_pointer_blocks = 100; 
  129|       |	m_pointer_allocator.reset(approximate_number_of_internal_pointers, 
  130|       |				  max_number_of_pointer_blocks);
  131|       |
  132|       |	m_vertices.resize(num_vertices);
  133|       |	for(unsigned i=0; i<num_vertices; ++i)		//copy coordinates to vertices
  134|       |	{
  135|       |		Vertex& v = m_vertices[i];
  136|       |		v.id() = i;
  137|       |
  138|       |		unsigned shift = 3*i;
  139|       |		v.x() = p[shift];
  140|       |		v.y() = p[shift + 1];
  141|       |		v.z() = p[shift + 2];
  142|       |	}
  143|       |
  144|       |	m_faces.resize(num_faces);
  145|       |	for(unsigned i=0; i<num_faces; ++i)		//copy adjacent vertices to polygons/faces
  146|       |	{
  147|       |		Face& f = m_faces[i];
  148|       |		f.id() = i;
  149|       |		f.adjacent_vertices().set_allocation(allocate_pointers(3),3);	//allocate three units of memory
  150|       |
  151|       |		unsigned shift = 3*i;
  152|       |		for(unsigned j=0; j<3; ++j)
  153|       |		{
  154|       |			unsigned vertex_index = tri[shift + j];
  155|       |			assert(vertex_index < num_vertices);
  156|       |			f.adjacent_vertices()[j] = &m_vertices[vertex_index];
  157|       |		}
  158|       |	}
  159|       |
  160|       |	build_adjacencies();	//build the structure of the mesh
  161|       |}
  162|       |
  163|       |inline void Mesh::build_adjacencies()
  164|      0|{
  165|      0|	//		Vertex->adjacent Faces
  166|      0|	std::vector<unsigned> count(m_vertices.size());	//count adjacent vertices
  167|      0|	for(unsigned i=0; i<m_faces.size(); ++i)
  168|      0|	{
  169|      0|		Face& f = m_faces[i];
  170|      0|		for(unsigned j=0; j<3; ++j)
  171|      0|		{
  172|      0|			unsigned vertex_id = f.adjacent_vertices()[j]->id();
  173|      0|			assert(vertex_id < m_vertices.size());
  174|      0|			count[vertex_id]++;
  175|      0|		}
  176|      0|	}
  177|      0|
  178|      0|	for(unsigned i=0; i<m_vertices.size(); ++i)		//reserve space
  179|      0|	{
  180|      0|		Vertex& v = m_vertices[i];
  181|      0|		unsigned num_adjacent_faces = count[i];
  182|      0|
  183|      0|		v.adjacent_faces().set_allocation(allocate_pointers(num_adjacent_faces),		//allocate three units of memory
  184|      0|										  num_adjacent_faces);	
  185|      0|	}
  186|      0|
  187|      0|	std::fill(count.begin(), count.end(), 0);
  188|      0|	for(unsigned i=0; i<m_faces.size(); ++i)
  189|      0|	{
  190|      0|		Face& f = m_faces[i];
  191|      0|		for(unsigned j=0; j<3; ++j)
  192|      0|		{
  193|      0|			vertex_pointer v = f.adjacent_vertices()[j];
  194|      0|			v->adjacent_faces()[count[v->id()]++] = &f;
  195|      0|		}
  196|      0|	}
  197|      0|
  198|      0|	//find all edges
  199|      0|	//i.e. find all half-edges, sort and combine them into edges
  200|      0|	std::vector<HalfEdge> half_edges(m_faces.size()*3);
  201|      0|	unsigned k = 0;
  202|      0|	for(unsigned i=0; i<m_faces.size(); ++i)
  203|      0|	{
  204|      0|		Face& f = m_faces[i];
  205|      0|		for(unsigned j=0; j<3; ++j)
  206|      0|		{
  207|      0|			half_edges[k].face_id = i;
  208|      0|			unsigned vertex_id_1 = f.adjacent_vertices()[j]->id();
  209|      0|			unsigned vertex_id_2 = f.adjacent_vertices()[(j+1) % 3]->id();
  210|      0|			half_edges[k].vertex_0 = (std::min)(vertex_id_1, vertex_id_2);
  211|      0|			half_edges[k].vertex_1 = (std::max)(vertex_id_1, vertex_id_2);
  212|      0|
  213|      0|			k++;	
  214|      0|		}
  215|      0|	}
  216|      0|	std::sort(half_edges.begin(), half_edges.end());
  217|      0|
  218|      0|	unsigned number_of_edges = 1;
  219|      0|	for(unsigned i=1; i<half_edges.size(); ++i)
  220|      0|	{
  221|      0|		if(half_edges[i] != half_edges[i-1])
  222|      0|		{
  223|      0|			++number_of_edges;
  224|      0|		}
  225|      0|		else
  226|      0|		{
  227|      0|			if(i<half_edges.size()-1)		//sanity check: there should be at most two equal half-edges
  228|      0|			{								//if it fails, most likely the input data are messed up
  229|      0|				assert(half_edges[i] != half_edges[i+1]);
  230|      0|			}
  231|      0|		}
  232|      0|	}
  233|      0|
  234|      0|	//		Edges->adjacent Vertices and Faces
  235|      0|	m_edges.resize(number_of_edges);
  236|      0|	unsigned edge_id = 0;
  237|      0|	for(unsigned i=0; i<half_edges.size();)
  238|      0|	{
  239|      0|		Edge& e = m_edges[edge_id];
  240|      0|		e.id() = edge_id++;
  241|      0|
  242|      0|		e.adjacent_vertices().set_allocation(allocate_pointers(2),2);		//allocate two units of memory
  243|      0|
  244|      0|		e.adjacent_vertices()[0] = &m_vertices[half_edges[i].vertex_0];
  245|      0|		e.adjacent_vertices()[1] = &m_vertices[half_edges[i].vertex_1];
  246|      0|
  247|      0|		e.length() = e.adjacent_vertices()[0]->distance(e.adjacent_vertices()[1]);
  248|      0|		assert(e.length() > 1e-100);		//algorithm works well with non-degenerate meshes only 
  249|      0|
  250|      0|		if(i != half_edges.size()-1 && half_edges[i] == half_edges[i+1])	//double edge
  251|      0|		{
  252|      0|			e.adjacent_faces().set_allocation(allocate_pointers(2),2);
  253|      0|			e.adjacent_faces()[0] = &m_faces[half_edges[i].face_id];
  254|      0|			e.adjacent_faces()[1] = &m_faces[half_edges[i+1].face_id];
  255|      0|			i += 2;
  256|      0|		}
  257|      0|		else			//single edge
  258|      0|		{
  259|      0|			e.adjacent_faces().set_allocation(allocate_pointers(1),1);		//one adjucent faces
  260|      0|			e.adjacent_faces()[0] = &m_faces[half_edges[i].face_id];
  261|      0|			i += 1;
  262|      0|		}
  263|      0|	}
  264|      0|
  265|      0|	//			Vertices->adjacent Edges
  266|      0|	std::fill(count.begin(), count.end(), 0);
  267|      0|	for(unsigned i=0; i<m_edges.size(); ++i)
  268|      0|	{
  269|      0|		Edge& e = m_edges[i];
  270|      0|		assert(e.adjacent_vertices().size()==2);
  271|      0|		count[e.adjacent_vertices()[0]->id()]++;
  272|      0|		count[e.adjacent_vertices()[1]->id()]++;
  273|      0|	}
  274|      0|	for(unsigned i=0; i<m_vertices.size(); ++i)
  275|      0|	{
  276|      0|		m_vertices[i].adjacent_edges().set_allocation(allocate_pointers(count[i]),
  277|      0|													  count[i]);	
  278|      0|	}
  279|      0|	std::fill(count.begin(), count.end(), 0);
  280|      0|	for(unsigned i=0; i<m_edges.size(); ++i)
  281|      0|	{
  282|      0|		Edge& e = m_edges[i];
  283|      0|		for(unsigned j=0; j<2; ++j)
  284|      0|		{
  285|      0|			vertex_pointer v = e.adjacent_vertices()[j];
  286|      0|			v->adjacent_edges()[count[v->id()]++] = &e;
  287|      0|		}
  288|      0|	}	
  289|      0|
  290|      0|	//			Faces->adjacent Edges
  291|      0|	for(unsigned i=0; i<m_faces.size(); ++i)
  292|      0|	{
  293|      0|		m_faces[i].adjacent_edges().set_allocation(allocate_pointers(3),3);	
  294|      0|	}
  295|      0|
  296|      0|	count.resize(m_faces.size());
  297|      0|	std::fill(count.begin(), count.end(), 0);
  298|      0|	for(unsigned i=0; i<m_edges.size(); ++i)
  299|      0|	{
  300|      0|		Edge& e = m_edges[i];
  301|      0|		for(unsigned j=0; j<e.adjacent_faces().size(); ++j)
  302|      0|		{
  303|      0|			face_pointer f = e.adjacent_faces()[j];
  304|      0|			assert(count[f->id()]<3);
  305|      0|			f->adjacent_edges()[count[f->id()]++] = &e;
  306|      0|		}
  307|      0|	}	
  308|      0|
  309|      0|		//compute angles for the faces
  310|      0|	for(unsigned i=0; i<m_faces.size(); ++i)
  311|      0|	{
  312|      0|		Face& f = m_faces[i];
  313|      0|		double abc[3];		
  314|      0|		double sum = 0;
  315|      0|		for(unsigned j=0; j<3; ++j)		//compute angle adjacent to the vertex j
  316|      0|		{
  317|      0|			for(unsigned k=0; k<3; ++k)
  318|      0|			{
  319|      0|				vertex_pointer v = f.adjacent_vertices()[(j + k)%3];
  320|      0|				abc[k] = f.opposite_edge(v)->length();
  321|      0|			}
  322|      0|
  323|      0|			double angle = angle_from_edges(abc[0], abc[1], abc[2]);
  324|      0|			assert(angle>1e-5);						//algorithm works well with non-degenerate meshes only 
  325|      0|
  326|      0|			f.corner_angles()[j] = angle;
  327|      0|			sum += angle;
  328|      0|		}
  329|      0|		assert(std::abs(sum - M_PI) < 1e-5);		//algorithm works well with non-degenerate meshes only 
  330|      0|	}
  331|      0|
  332|      0|		//define m_turn_around_flag for vertices
  333|      0|	std::vector<double> total_vertex_angle(m_vertices.size());
  334|      0|	for(unsigned i=0; i<m_faces.size(); ++i)
  335|      0|	{
  336|      0|		Face& f = m_faces[i];
  337|      0|		for(unsigned j=0; j<3; ++j)
  338|      0|		{
  339|      0|			vertex_pointer v = f.adjacent_vertices()[j];
  340|      0|			total_vertex_angle[v->id()] += f.corner_angles()[j];
  341|      0|		}
  342|      0|	}
  343|      0|
  344|      0|	for(unsigned i=0; i<m_vertices.size(); ++i)
  345|      0|	{
  346|      0|		Vertex& v = m_vertices[i];
  347|      0|		v.saddle_or_boundary() = (total_vertex_angle[v.id()] > 2.0*M_PI - 1e-5); 
  348|      0|	}
  349|      0|
  350|      0|	for(unsigned i=0; i<m_edges.size(); ++i)
  351|      0|	{
  352|      0|		Edge& e = m_edges[i];
  353|      0|		if(e.is_boundary())
  354|      0|		{
  355|      0|			e.adjacent_vertices()[0]->saddle_or_boundary() = true;
  356|      0|			e.adjacent_vertices()[1]->saddle_or_boundary() = true;
  357|      0|		}
  358|      0|	}
  359|      0|
  360|      0|	assert(verify());
  361|      0|}
  362|       |
  363|       |inline bool Mesh::verify()		//verifies connectivity of the mesh and prints some debug info
  364|      0|{
  365|      0|	bool bDump = false;
  366|      0|
  367|      0|	if (bDump) std::cout << std::endl;
  368|      0|	// make sure that all vertices are mentioned at least once. 
  369|      0|	// though the loose vertex is not a bug, it most likely indicates that something is wrong with the mesh
  370|      0|	std::vector<bool> map(m_vertices.size(), false);
  371|      0|	for(unsigned i=0; i<m_edges.size(); ++i)
  372|      0|	{
  373|      0|		edge_pointer e = &m_edges[i];
  374|      0|		map[e->adjacent_vertices()[0]->id()] = true;
  375|      0|		map[e->adjacent_vertices()[1]->id()] = true;
  376|      0|	}
  377|      0|	assert(std::find(map.begin(), map.end(), false) == map.end());
  378|      0|
  379|      0|	//make sure that the mesh is connected trough its edges
  380|      0|	//if mesh has more than one connected component, it is most likely a bug
  381|      0|	std::vector<face_pointer> stack(1,&m_faces[0]);
  382|      0|	stack.reserve(m_faces.size());
  383|      0|
  384|      0|	map.resize(m_faces.size());
  385|      0|	std::fill(map.begin(), map.end(), false);
  386|      0|	map[0] = true;
  387|      0|
  388|      0|	while(!stack.empty())
  389|      0|	{
  390|      0|		face_pointer f = stack.back();
  391|      0|		stack.pop_back();
  392|      0|
  393|      0|		for(unsigned i=0; i<3; ++i)
  394|      0|		{
  395|      0|			edge_pointer e = f->adjacent_edges()[i];
  396|      0|			face_pointer f_adjacent = e->opposite_face(f);
  397|      0|			if(f_adjacent && !map[f_adjacent->id()])
  398|      0|			{
  399|      0|				map[f_adjacent->id()] = true;
  400|      0|				stack.push_back(f_adjacent);
  401|      0|			}
  402|      0|		}
  403|      0|	}
  404|      0|	assert(std::find(map.begin(), map.end(), false) == map.end());
  405|      0|	if (!bDump)
  406|      0|		return true;
  407|      0|
  408|      0|	//print some mesh statistics that can be useful in debugging
  409|      0|	std::cout << "mesh has "	<< m_vertices.size() 
  410|      0|		  << " vertices, "	<< m_faces.size() 
  411|      0|		  << " faces, "		<< m_edges.size() 
  412|      0|		  << " edges\n";
  413|      0|	
  414|      0|	unsigned total_boundary_edges = 0;
  415|      0|	double longest_edge = 0;
  416|      0|	double shortest_edge = 1e100;
  417|      0|	for(unsigned i=0; i<m_edges.size(); ++i)
  418|      0|	{
  419|      0|		Edge& e = m_edges[i];
  420|      0|		total_boundary_edges += e.is_boundary() ? 1 : 0;
  421|      0|		longest_edge = (std::max)(longest_edge, e.length());
  422|      0|		shortest_edge = (std::min)(shortest_edge, e.length());
  423|      0|	}
  424|      0|	std::cout << total_boundary_edges << " edges are boundary edges\n";
  425|      0|	std::cout << "shortest/longest edges are " 
  426|      0|		  << shortest_edge << "/"
  427|      0|		  << longest_edge << " = "
  428|      0|		  << shortest_edge/longest_edge
  429|      0|		  << std::endl;
  430|      0|
  431|      0|	double minx = 1e100;
  432|      0|	double maxx = -1e100;
  433|      0|	double miny = 1e100;
  434|      0|	double maxy = -1e100;
  435|      0|	double minz = 1e100;
  436|      0|	double maxz = -1e100;
  437|      0|	for(unsigned i=0; i<m_vertices.size(); ++i)
  438|      0|	{
  439|      0|		Vertex& v = m_vertices[i];
  440|      0|		minx = (std::min)(minx, v.x());
  441|      0|		maxx = (std::max)(maxx, v.x());
  442|      0|		miny = (std::min)(miny, v.y());
  443|      0|		maxy = (std::max)(maxy, v.y());
  444|      0|		minz = (std::min)(minz, v.z());
  445|      0|		maxz = (std::max)(maxz, v.z());
  446|      0|	}
  447|      0|	std::cout << "enclosing XYZ box:"
  448|      0|			  <<" X[" << minx << "," << maxx << "]"
  449|      0|			  <<" Y[" << miny << "," << maxy << "]"
  450|      0|			  <<" Z[" << minz << "," << maxz << "]"
  451|      0|			  << std::endl;
  452|      0|
  453|      0|	double dx = maxx - minx;
  454|      0|	double dy = maxy - miny;
  455|      0|	double dz = maxz - minz;
  456|      0|	std::cout << "approximate diameter of the mesh is "
  457|      0|		  << sqrt(dx*dx + dy*dy + dz*dz)
  458|      0|		  << std::endl;
  459|      0|
  460|      0|	double min_angle = 1e100;
  461|      0|	double max_angle = -1e100;
  462|      0|	for(unsigned i=0; i<m_faces.size(); ++i)
  463|      0|	{
  464|      0|		Face& f = m_faces[i];
  465|      0|		for(unsigned j=0; j<3; ++j)
  466|      0|		{
  467|      0|			double angle = f.corner_angles()[j];
  468|      0|			min_angle = (std::min)(min_angle, angle);
  469|      0|			max_angle = (std::max)(max_angle, angle);
  470|      0|		}
  471|      0|	}
  472|      0|	std::cout << "min/max face angles are "
  473|      0|		  << min_angle/M_PI*180.0 << "/"
  474|      0|		  << max_angle/M_PI*180.0
  475|      0|		  << " degrees\n";
  476|      0|
  477|      0|	std::cout << std::endl;
  478|      0|	return true;
  479|      0|}
  480|       |
  481|       |inline void fill_surface_point_structure(geodesic::SurfacePoint* point, 
  482|       |					 double* data, 
  483|       |					 Mesh* mesh)
  484|      0|{
  485|      0|	point->set(data);
  486|      0|	unsigned type = (unsigned) data[3];
  487|      0|	unsigned id = (unsigned) data[4];
  488|      0|	
  489|      0|
  490|      0|	if(type == 0)		//vertex
  491|      0|	{
  492|      0|		point->base_element() = &mesh->vertices()[id];
  493|      0|	}
  494|      0|	else if(type == 1)	//edge
  495|      0|	{
  496|      0|		point->base_element() = &mesh->edges()[id];
  497|      0|	}
  498|      0|	else				//face
  499|      0|	{
  500|      0|		point->base_element() = &mesh->faces()[id];
  501|      0|	}
  502|      0|}
  503|       |
  504|       |inline void fill_surface_point_double(geodesic::SurfacePoint* point, 
  505|       |				      double* data, 
  506|       |				      long mesh_id)
  507|      0|{
  508|      0|	data[0] = point->x();
  509|      0|	data[1] = point->y();
  510|      0|	data[2] = point->z();
  511|      0|	data[4] = point->base_element()->id();
  512|      0|
  513|      0|	if(point->type() == VERTEX)		//vertex
  514|      0|	{
  515|      0|		data[3] = 0;
  516|      0|	}
  517|      0|	else if(point->type() == EDGE)	//edge
  518|      0|	{
  519|      0|		data[3] = 1;
  520|      0|	}
  521|      0|	else				//face
  522|      0|	{
  523|      0|		data[3] = 2;
  524|      0|	}
  525|      0|}
  526|       |
  527|       |} //geodesic
  528|       |
  529|       |#endif	

/workspaces/cg/src/cgmesh/geodesic_mesh_elements.h:
    1|       |//Copyright (C) 2008 Danil Kirsanov, MIT License
    2|       |#ifndef GEODESIC_MESH_ELEMENTS_20071231
    3|       |#define GEODESIC_MESH_ELEMENTS_20071231
    4|       |
    5|       |// here we define the building elements of the mesh: 
    6|       |// 3D-points, vertices, edges, faces, and surface points
    7|       |
    8|       |#include <assert.h>
    9|       |#include <cstddef>
   10|       |
   11|       |namespace geodesic{
   12|       |
   13|       |class Vertex; 
   14|       |class Edge; 
   15|       |class Face; 
   16|       |class Mesh; 
   17|       |class MeshElementBase;
   18|       |
   19|       |typedef Vertex* vertex_pointer;
   20|       |typedef Edge* edge_pointer;
   21|       |typedef Face* face_pointer;
   22|       |typedef Mesh* mesh_pointer;
   23|       |typedef MeshElementBase* base_pointer;
   24|       |
   25|       |template <class Data>		//simple vector that stores info about mesh references 
   26|       |class SimpleVector			//for efficiency, it uses an outside memory allocator
   27|       |{
   28|       |public:
   29|       |	SimpleVector():
   30|       |	  m_size(0),
   31|       |	  m_begin(NULL)
   32|       |	{};
   33|       |
   34|       |	typedef Data* iterator;
   35|       |
   36|      0|	unsigned size(){return m_size;};
  ------------------
  | Unexecuted instantiation: _ZN8geodesic12SimpleVectorIPNS_4FaceEE4sizeEv
  ------------------
  | Unexecuted instantiation: _ZN8geodesic12SimpleVectorIPNS_6VertexEE4sizeEv
  ------------------
   37|      0|	iterator begin(){return m_begin;};
   38|       |	iterator end(){return m_begin + m_size;};
   39|       |
   40|       |	template<class DataPointer>
   41|       |	void set_allocation(DataPointer begin, unsigned size)
   42|      0|	{
   43|      0|		assert(begin != NULL || size == 0);
   44|      0|		m_size = size;
   45|      0|		m_begin = (iterator)begin;
   46|      0|	}
  ------------------
  | Unexecuted instantiation: _ZN8geodesic12SimpleVectorIPNS_4FaceEE14set_allocationIPvEEvT_j
  ------------------
  | Unexecuted instantiation: _ZN8geodesic12SimpleVectorIPNS_6VertexEE14set_allocationIPvEEvT_j
  ------------------
  | Unexecuted instantiation: _ZN8geodesic12SimpleVectorIPNS_4EdgeEE14set_allocationIPvEEvT_j
  ------------------
   47|       |
   48|       |	Data& operator[](unsigned i)
   49|      0|	{
   50|      0|		assert(i < m_size);
   51|      0|		return *(m_begin + i);
   52|      0|	}
  ------------------
  | Unexecuted instantiation: _ZN8geodesic12SimpleVectorIPNS_6VertexEEixEj
  ------------------
  | Unexecuted instantiation: _ZN8geodesic12SimpleVectorIPNS_4FaceEEixEj
  ------------------
  | Unexecuted instantiation: _ZN8geodesic12SimpleVectorIPNS_4EdgeEEixEj
  ------------------
   53|       |
   54|       |	void clear()
   55|       |	{
   56|       |		m_size = 0;
   57|       |		m_begin = NULL;
   58|       |	}
   59|       |
   60|       |private:
   61|       |	unsigned m_size;
   62|       |	Data* m_begin;
   63|       |};
   64|       |
   65|       |enum PointType
   66|       |{
   67|       |    VERTEX,
   68|       |    EDGE,
   69|       |    FACE,
   70|       |	UNDEFINED_POINT
   71|       |};
   72|       |
   73|       |class MeshElementBase	//prototype of vertices, edges and faces
   74|       |{
   75|       |public:
   76|       |	typedef SimpleVector<vertex_pointer> vertex_pointer_vector;	
   77|       |	typedef SimpleVector<edge_pointer> edge_pointer_vector;	
   78|       |	typedef SimpleVector<face_pointer> face_pointer_vector;	
   79|       |
   80|       |	MeshElementBase():
   81|       |		m_id(0),
   82|       |		m_type(UNDEFINED_POINT)
   83|      0|	{};
   84|       |
   85|      0|	vertex_pointer_vector& adjacent_vertices(){return m_adjacent_vertices;};
   86|      0|	edge_pointer_vector& adjacent_edges(){return m_adjacent_edges;};
   87|      0|	face_pointer_vector& adjacent_faces(){return m_adjacent_faces;};
   88|       |
   89|      0|	unsigned& id(){return m_id;}; 
   90|      0|	PointType type(){return m_type;};
   91|       |
   92|       |protected:
   93|       |	vertex_pointer_vector m_adjacent_vertices;		//list of the adjacent vertices
   94|       |	edge_pointer_vector m_adjacent_edges;			//list of the adjacent edges
   95|       |	face_pointer_vector m_adjacent_faces;			//list of the adjacent faces
   96|       |
   97|       |	unsigned m_id;							//unique id
   98|       |	PointType m_type;							//vertex, edge or face
   99|       |};
  100|       |
  101|       |class Point3D			//point in 3D and corresponding operations
  102|       |{
  103|       |public:
  104|      0|	Point3D(){};
  105|       |	Point3D(Point3D* p)
  106|      0|	{
  107|      0|		x() = p->x();
  108|      0|		y() = p->y();
  109|      0|		z() = p->z();
  110|      0|	};
  111|       |
  112|      0|	double* xyz(){return m_coordinates;};
  113|      0|	double& x(){return *m_coordinates;};
  114|      0|	double& y(){return *(m_coordinates+1);};
  115|      0|	double& z(){return *(m_coordinates+2);};
  116|       |
  117|       |	void set(double new_x, double new_y, double new_z)
  118|      0|	{
  119|      0|		x() = new_x;
  120|      0|		y() = new_y;
  121|      0|		z() = new_z;
  122|      0|	}
  123|       |
  124|       |	void set(double* data)
  125|      0|	{
  126|      0|		x() = *data;
  127|      0|		y() = *(data+1);
  128|      0|		z() = *(data+2);
  129|      0|	}
  130|       |
  131|       |	double distance(double* v)
  132|      0|	{
  133|      0|		double dx = m_coordinates[0] - v[0];
  134|      0|		double dy = m_coordinates[1] - v[1];
  135|      0|		double dz = m_coordinates[2] - v[2];
  136|      0|
  137|      0|		return sqrt(dx*dx + dy*dy + dz*dz);
  138|      0|	};
  139|       |
  140|       |    double distance(Point3D* v)
  141|      0|	{
  142|      0|		return distance(v->xyz());
  143|      0|	};
  144|       |
  145|       |	void add(Point3D* v)
  146|      0|	{
  147|      0|		x() += v->x();
  148|      0|		y() += v->y();
  149|      0|		z() += v->z();
  150|      0|	};
  151|       |
  152|       |	void multiply(double v)
  153|      0|	{
  154|      0|		x() *= v;
  155|      0|		y() *= v;
  156|      0|		z() *= v;
  157|      0|	};
  158|       |
  159|       |private:
  160|       |	double m_coordinates[3];					//xyz
  161|       |};
  162|       |
  163|       |class Vertex: public MeshElementBase, public Point3D
  164|       |{
  165|       |public:
  166|       |	Vertex()
  167|      0|	{
  168|      0|		m_type = VERTEX;
  169|      0|	};
  170|       |
  171|      0|	~Vertex(){};
  172|       |
  173|      0|	bool& saddle_or_boundary(){return m_saddle_or_boundary;};
  174|       |private:					
  175|       |									//this flag speeds up exact geodesic algorithm
  176|       |	bool m_saddle_or_boundary;		//it is true if total adjacent angle is larger than 2*PI or this vertex belongs to the mesh boundary
  177|       |};
  178|       |
  179|       |
  180|       |class Face: public MeshElementBase
  181|       |{
  182|       |public:
  183|       |	Face()
  184|      0|	{
  185|      0|		m_type = FACE;
  186|      0|	};
  187|       |
  188|      0|	~Face(){};
  189|       |
  190|       |	edge_pointer opposite_edge(vertex_pointer v);
  191|       |	vertex_pointer opposite_vertex(edge_pointer e);
  192|       |	edge_pointer next_edge(edge_pointer e, vertex_pointer v);
  193|       |
  194|       |	double vertex_angle(vertex_pointer v)
  195|      0|	{
  196|      0|		for(unsigned i=0; i<3; ++i)
  197|      0|		{
  198|      0|			if(adjacent_vertices()[i]->id() == v->id())
  199|      0|			{
  200|      0|				return m_corner_angles[i];
  201|      0|			}
  202|      0|		}
  203|      0|		assert(0);
  204|      0|		return 0;
  205|      0|	}
  206|       |
  207|      0|	double* corner_angles(){return m_corner_angles;};
  208|       |
  209|       |private:
  210|       |	double m_corner_angles[3];		//triangle angles in radians; angles correspond to vertices in m_adjacent_vertices
  211|       |};
  212|       |
  213|       |class Edge: public MeshElementBase
  214|       |{
  215|       |public:
  216|       |	Edge()
  217|      0|	{
  218|      0|		m_type = EDGE;
  219|      0|	};
  220|       |
  221|      0|	~Edge(){};
  222|       |
  223|      0|	double& length(){return m_length;};
  224|       |
  225|       |	face_pointer opposite_face(face_pointer f)
  226|      0|	{
  227|      0|		if(adjacent_faces().size() == 1)
  228|      0|		{
  229|      0|			assert(adjacent_faces()[0]->id() == f->id());
  230|      0|			return NULL;
  231|      0|		}
  232|      0|
  233|      0|		assert(adjacent_faces()[0]->id() == f->id() || 
  234|      0|			   adjacent_faces()[1]->id() == f->id());
  235|      0|
  236|      0|		return adjacent_faces()[0]->id() == f->id() ? 
  237|      0|			   adjacent_faces()[1] : adjacent_faces()[0];
  238|      0|	};
  239|       |
  240|       |	vertex_pointer opposite_vertex(vertex_pointer v)
  241|      0|	{
  242|      0|		assert(belongs(v));
  243|      0|
  244|      0|		return adjacent_vertices()[0]->id() == v->id() ?
  245|      0|			   adjacent_vertices()[1] : adjacent_vertices()[0];
  246|      0|	};
  247|       |
  248|       |	bool belongs(vertex_pointer v)
  249|      0|	{
  250|      0|		return adjacent_vertices()[0]->id() == v->id() || 
  251|      0|			   adjacent_vertices()[1]->id() == v->id();
  252|      0|	}
  253|       |
  254|      0|	bool is_boundary(){return adjacent_faces().size() == 1;};
  255|       |
  256|      0|	vertex_pointer v0(){return adjacent_vertices()[0];};
  257|      0|	vertex_pointer v1(){return adjacent_vertices()[1];};
  258|       |
  259|       |	void local_coordinates(Point3D* point, 
  260|       |						   double& x, 
  261|       |						   double& y)
  262|      0|	{
  263|      0|		double d0 = point->distance(v0());
  264|      0|		if(d0 < 1e-50)
  265|      0|		{
  266|      0|			x = 0.0;
  267|      0|			y = 0.0;
  268|      0|			return;
  269|      0|		}
  270|      0|
  271|      0|		double d1 = point->distance(v1());
  272|      0|		if(d1 < 1e-50)
  273|      0|		{
  274|      0|			x = m_length;
  275|      0|			y = 0.0;
  276|      0|			return;
  277|      0|		}
  278|      0|
  279|      0|		x = m_length/2.0 + (d0*d0 - d1*d1)/(2.0*m_length);
  280|      0|		y = sqrt((std::max)(0.0, d0*d0 - x*x));
  281|      0|		return;
  282|      0|	}
  283|       |
  284|       |private:
  285|       |	double m_length;							//length of the edge
  286|       |};
  287|       |
  288|       |class SurfacePoint:public Point3D  //point on the surface of the mesh
  289|       |{
  290|       |public:
  291|       |	SurfacePoint():
  292|       |		m_p(NULL)
  293|      0|	{};
  294|       |
  295|       |	SurfacePoint(vertex_pointer v):		//set the surface point in the vertex
  296|       |		SurfacePoint::Point3D(v),
  297|       |		m_p(v)
  298|      0|	{};
  299|       |
  300|       |	SurfacePoint(face_pointer f):		//set the surface point in the center of the face
  301|       |		m_p(f)
  302|      0|	{
  303|      0|		set(0,0,0);
  304|      0|		add(f->adjacent_vertices()[0]);
  305|      0|		add(f->adjacent_vertices()[1]);
  306|      0|		add(f->adjacent_vertices()[2]);
  307|      0|		multiply(1./3.);
  308|      0|	};
  309|       |
  310|       |	SurfacePoint(edge_pointer e,		//set the surface point in the middle of the edge
  311|       |				 double a = 0.5):		
  312|       |		m_p(e)
  313|      0|	{
  314|      0|		double b = 1 - a;
  315|      0|
  316|      0|		vertex_pointer v0 = e->adjacent_vertices()[0];
  317|      0|		vertex_pointer v1 = e->adjacent_vertices()[1];
  318|      0|
  319|      0|		x() = b*v0->x() + a*v1->x();
  320|      0|		y() = b*v0->y() + a*v1->y();
  321|      0|		z() = b*v0->z() + a*v1->z();
  322|      0|	};
  323|       |
  324|       |	SurfacePoint(base_pointer g, 
  325|       |				 double x,
  326|       |				 double y,
  327|       |				 double z,
  328|       |				 PointType t = UNDEFINED_POINT):
  329|       |		m_p(g)
  330|      0|	{
  331|      0|		set(x,y,z);
  332|      0|	};
  333|       |
  334|       |	void initialize(SurfacePoint const& p)
  335|      0|	{
  336|      0|		*this = p;
  337|      0|	}
  338|       |
  339|      0|	~SurfacePoint(){};
  340|       |
  341|      0|	PointType type(){return m_p ? m_p->type() : UNDEFINED_POINT;};
  342|      0|	base_pointer& base_element(){return m_p;};
  343|       |protected:
  344|       |	base_pointer m_p;			//could be face, vertex or edge pointer
  345|       |};
  346|       |
  347|       |inline edge_pointer Face::opposite_edge(vertex_pointer v)
  348|      0|{
  349|      0|	for(unsigned i=0; i<3; ++i)
  350|      0|	{
  351|      0|		edge_pointer e = adjacent_edges()[i];
  352|      0|		if(!e->belongs(v))
  353|      0|		{
  354|      0|			return e;
  355|      0|		}
  356|      0|	}
  357|      0|	assert(0);
  358|      0|	return NULL;
  359|      0|}
  360|       |
  361|       |inline vertex_pointer Face::opposite_vertex(edge_pointer e)
  362|      0|{
  363|      0|	for(unsigned i=0; i<3; ++i)
  364|      0|	{
  365|      0|		vertex_pointer v = adjacent_vertices()[i];
  366|      0|		if(!e->belongs(v))
  367|      0|		{
  368|      0|			return v;
  369|      0|		}
  370|      0|	}
  371|      0|	assert(0);
  372|      0|	return NULL;
  373|      0|}
  374|       |
  375|       |inline edge_pointer Face::next_edge(edge_pointer e, vertex_pointer v)
  376|      0|{
  377|      0|	assert(e->belongs(v));
  378|      0|
  379|      0|	for(unsigned i=0; i<3; ++i)
  380|      0|	{
  381|      0|		edge_pointer next = adjacent_edges()[i];
  382|      0|		if(e->id() != next->id() && next->belongs(v))
  383|      0|		{
  384|      0|			return next;
  385|      0|		}
  386|      0|	}
  387|      0|	assert(0);
  388|      0|	return NULL;
  389|      0|}
  390|       |
  391|       |struct HalfEdge			//prototype of the edge; used for mesh construction
  392|       |{
  393|       |	unsigned face_id;
  394|       |	unsigned vertex_0;		//adjacent vertices sorted by id value
  395|       |	unsigned vertex_1;		//they are sorted, vertex_0 < vertex_1
  396|       |};
  397|       |
  398|       |inline bool operator < (const HalfEdge &x, const HalfEdge &y)
  399|      0|{
  400|      0|	if(x.vertex_0 == y.vertex_0)
  401|      0|	{
  402|      0|	    return x.vertex_1 < y.vertex_1;
  403|      0|	}
  404|      0|	else
  405|      0|	{
  406|      0|		return x.vertex_0 < y.vertex_0;
  407|      0|	}
  408|      0|}
  409|       |
  410|       |inline bool operator != (const HalfEdge &x, const HalfEdge &y)
  411|      0|{
  412|      0|	return x.vertex_0 != y.vertex_0 || x.vertex_1 != y.vertex_1;
  413|      0|}
  414|       |
  415|       |inline bool operator == (const HalfEdge &x, const HalfEdge &y)
  416|      0|{
  417|      0|	return x.vertex_0 == y.vertex_0 && x.vertex_1 == y.vertex_1;
  418|      0|}
  419|       |
  420|       |} //geodesic
  421|       |
  422|       |#endif	

/workspaces/cg/src/cgmesh/geodesic_wrapper.h:
    1|       |#ifndef __GEODESIC_WRAPPER_H__
    2|       |#define __GEODESIC_WRAPPER_H__
    3|       |
    4|       |//
    5|       |// wrapper for the code found here :
    6|       |// https://code.google.com/p/geodesic/
    7|       |//
    8|       |#include "geodesic_algorithm_base.h"
    9|       |
   10|       |class GeodesicWrapper
   11|       |{
   12|       |public:
   13|       |	GeodesicWrapper ();
   14|       |	~GeodesicWrapper ();
   15|       |
   16|       |	bool input (char *filename);
   17|       |	bool SetMesh (unsigned int nvertices, float *vertices, unsigned int nfaces, unsigned int *faces);
   18|       |	bool OuputDistances (float *distances);
   19|       |
   20|      0|	inline unsigned int GetNVertices (void) { return mesh.vertices().size(); };
   21|       |
   22|       |	inline bool AddSource (unsigned int source_vertex_index)
   23|      0|		{
   24|      0|			sources.push_back(geodesic::SurfacePoint(&mesh.vertices()[source_vertex_index]));
   25|      0|			return true;
   26|      0|		}
   27|       |	inline bool AddTarget (unsigned int target_vertex_index)
   28|      0|		{
   29|      0|			targets.push_back(geodesic::SurfacePoint(&mesh.vertices()[target_vertex_index]));
   30|      0|			return true;
   31|      0|		}
   32|       |/*
   33|       |	std::vector<geodesic::SurfacePoint> sources;
   34|       |	sources.push_back(geodesic::SurfacePoint(&mesh.vertices()[0]));		//one source is located at vertex zero
   35|       |	sources.push_back(geodesic::SurfacePoint(&mesh.edges()[12]));		//second source is located in the middle of edge 12
   36|       |	sources.push_back(geodesic::SurfacePoint(&mesh.faces()[20]));		//third source is located in the middle of face 20
   37|       |
   38|       |	std::vector<geodesic::SurfacePoint> targets;		//same thing with targets
   39|       |	targets.push_back(geodesic::SurfacePoint(&mesh.vertices().back()));		
   40|       |	targets.push_back(geodesic::SurfacePoint(&mesh.edges()[10]));		
   41|       |	targets.push_back(geodesic::SurfacePoint(&mesh.faces()[3]));		
   42|       |*/
   43|       |	bool ComputeDistances (float *distances, geodesic::GeodesicAlgorithmBase::AlgorithmType algorithmType, int subdivision_level = 2);
   44|       |
   45|       |	geodesic::Mesh mesh;
   46|       |private:
   47|       |	//geodesic::GeodesicAlgorithmExact *m_algorithm;
   48|       |	geodesic::GeodesicAlgorithmBase *m_algorithm;
   49|       |	std::vector<geodesic::SurfacePoint> sources;
   50|       |	std::vector<geodesic::SurfacePoint> targets;
   51|       |};
   52|       |
   53|       |#endif // __GEODESIC_WRAPPER_H__

/workspaces/cg/src/cgmesh/geometric_primitives.h:
    1|       |#ifndef __GEOMETRIC_PRIMITIVES_H__
    2|       |#define __GEOMETRIC_PRIMITIVES_H__
    3|       |
    4|       |#include "../cgmath/cgmath.h"
    5|       |#include "mesh_half_edge.h"
    6|       |
    7|       |//
    8|       |//
    9|       |//
   10|       |class VectorizedElement
   11|       |{
   12|       |public:
   13|       |	enum VectorizedElementType {GEOMETRIC_PRIMITIVE_UNKNOWN = 0,
   14|       |								GEOMETRIC_PRIMITIVE_POINT,
   15|       |								GEOMETRIC_PRIMITIVE_LINE,
   16|       |								GEOMETRIC_PRIMITIVE_PLANE,
   17|       |								GEOMETRIC_PRIMITIVE_CIRCLE};
   18|       |	VectorizedElement (unsigned int *pElements, unsigned int nElements, VectorizedElementType type);
   19|      0|	~VectorizedElement() {};
   20|      0|	inline VectorizedElementType get_type () { return m_type; };
   21|       |
   22|      0|	inline unsigned int get_n_elements (void) { return m_nElements; };
   23|      0|	inline unsigned int* get_elements (void) { return m_pElements; };
   24|       |
   25|       |private:
   26|       |	VectorizedElementType m_type;
   27|       |	//Mesh_half_edge *m_pMesh;
   28|       |	unsigned int m_nElements;
   29|       |	unsigned int *m_pElements;
   30|       |};
   31|       |
   32|       |//
   33|       |// Vectorized Point
   34|       |//
   35|       |class VectorizedPoint : public VectorizedElement
   36|       |{
   37|       |public:
   38|       |	VectorizedPoint (unsigned int *pElements, unsigned int nElements, Vector3f pos);
   39|      0|	~VectorizedPoint () {};
   40|       |
   41|       |//private:
   42|       |	Vector3f m_position;
   43|       |};
   44|       |
   45|       |//
   46|       |// Vectorized Line
   47|       |//
   48|       |class VectorizedLine : public VectorizedElement
   49|       |{
   50|       |public:
   51|       |	VectorizedLine (unsigned int *pElements, unsigned int nElements, Vector3f start, Vector3f end);
   52|      0|	~VectorizedLine () {};
   53|       |
   54|       |//private:
   55|       |	Vector3f m_start, m_end;
   56|       |};
   57|       |
   58|       |//
   59|       |// Vectorized Plane
   60|       |//
   61|       |class VectorizedPlane : public VectorizedElement, Plane
   62|       |{
   63|       |public:
   64|       |	VectorizedPlane (unsigned int *pElements, unsigned int nElements, Plane *pPlane);
   65|      0|	~VectorizedPlane () {};
   66|       |
   67|      0|	void set_area (float fArea) { m_fArea = fArea; };
   68|      0|	float get_area (void) { return m_fArea; };
   69|       |
   70|       |//private:
   71|       |	Plane *m_pPlane;
   72|       |	float m_fArea;
   73|       |};
   74|       |
   75|       |//
   76|       |//
   77|       |//
   78|       |class Cgeometric_primitives
   79|       |{
   80|       |	public:
   81|       |		Cgeometric_primitives (Mesh_half_edge *model, char *filename);
   82|       |		~Cgeometric_primitives ();
   83|       |
   84|       |		void add_geometric_primitive (VectorizedElement *geometric_primitive);
   85|       |		int  get_n_geometric_primitives (void);
   86|       |	    VectorizedElement* get_geometric_primitive (int index);
   87|       |
   88|       |		void dump (void);
   89|       |		void refresh_vertices_colors (void);
   90|       |		void draw (void);
   91|       |	
   92|       |	private:
   93|       |		Mesh_half_edge *model;
   94|       |		int ngp;
   95|       |		VectorizedElement **gp;	
   96|       |};
   97|       |
   98|       |#endif // __GEOMETRIC_PRIMITIVES_H__

/workspaces/cg/src/cgmesh/half_edge.cpp:
    1|       |#include <stdio.h>
    2|       |#include <stdlib.h>
    3|       |#include <assert.h>
    4|       |#include <math.h>
    5|       |#include <string.h>
    6|       |
    7|       |#ifdef linux
    8|       |#include <sys/time.h>
    9|       |#endif // linux
   10|       |#ifdef WIN32
   11|       |#define WIN32_LEAN_AND_MEAN
   12|       |#include <windows.h>
   13|       |#endif // WIN32
   14|       |
   15|       |#include "half_edge.h"
   16|       |
   17|       |/*** Begin class Cedges_visited ***/
   18|       |Cedges_visited::Cedges_visited (int par_nv)
   19|      1|{
   20|      1|	int i;
   21|      1|	m_nv = par_nv;
   22|      1|	m_n_connected_to    = (int*)malloc(m_nv*sizeof(int));
   23|      1|	m_n_connections_max = (int*)malloc(m_nv*sizeof(int));
   24|      1|	m_connected_to      = (int**)malloc(m_nv*sizeof(int*));
   25|      1|	for (i=0; i<m_nv; i++)
   26|      0|	{
   27|      0|		m_n_connections_max[i] = 9;
   28|      0|		m_connected_to[i] = (int*)malloc(2*m_n_connections_max[i]*sizeof(int));
   29|      0|		m_n_connected_to[i] = 0;
   30|      0|	}
   31|      1|}
   32|       |
   33|       |Cedges_visited::~Cedges_visited ()
   34|      1|{
   35|      1|	for (int i=0; i<m_nv; i++)
   36|      0|		if (m_connected_to[i])
   37|      0|			free (m_connected_to[i]);
   38|      1|	if (m_n_connected_to)
   39|      1|		free (m_n_connected_to);
   40|      1|	if (m_n_connections_max)
   41|      1|		free (m_n_connections_max);
   42|      1|}
   43|       |  
   44|       |void Cedges_visited::add_edge (int par_a, int par_b, int par_index)
   45|      0|{
   46|       |	// update the connections to par_a
   47|      0|	if (m_n_connected_to[par_a] == m_n_connections_max[par_a])
   48|      0|	{
   49|      0|		m_n_connections_max[par_a] *= 2;
   50|      0|		m_connected_to[par_a] = (int*)realloc ((void*)m_connected_to[par_a], 2*m_n_connections_max[par_a]*sizeof(int));
   51|      0|	}
   52|      0|	m_connected_to[par_a][2*m_n_connected_to[par_a]]   = par_b;
   53|      0|	m_connected_to[par_a][2*m_n_connected_to[par_a]+1] = par_index;
   54|      0|	m_n_connected_to[par_a]++;
   55|       |	
   56|       |	// update the connections to par_b
   57|      0|	if (m_n_connected_to[par_b] == m_n_connections_max[par_b])
   58|      0|	{
   59|      0|		m_n_connections_max[par_b] *= 2;
   60|      0|		m_connected_to[par_b] = (int*)realloc ((void*)m_connected_to[par_b], 2*m_n_connections_max[par_b]*sizeof(int));
   61|      0|	}
   62|      0|	m_connected_to[par_b][2*m_n_connected_to[par_b]]   = par_a;
   63|      0|	m_connected_to[par_b][2*m_n_connected_to[par_b]+1] = par_index;
   64|      0|	m_n_connected_to[par_b]++;
   65|      0|}
   66|       |
   67|       |void Cedges_visited::delete_edge (int par_a, int par_b)
   68|      0|{
   69|      0|	int i;
   70|       |	
   71|       |	// update the connections to a
   72|      0|	for (i=0; i<m_n_connected_to[par_a]; i++)
   73|      0|	{
   74|      0|		if (m_connected_to[par_a][2*i] == par_b)
   75|      0|		{
   76|      0|			m_connected_to[par_a][2*i]   = m_connected_to[par_a][2*(m_n_connected_to[par_a]-1)];
   77|      0|			m_connected_to[par_a][2*i+1] = m_connected_to[par_a][2*(m_n_connected_to[par_a]-1)+1];
   78|      0|			m_n_connected_to[par_a]--;
   79|      0|			break;
   80|      0|		}
   81|      0|	}
   82|       |	
   83|       |	// update the connections to b
   84|      0|	for (i=0; i<m_n_connected_to[par_b]; i++)
   85|      0|	{
   86|      0|		if (m_connected_to[par_b][2*i] == par_a)
   87|      0|		{
   88|      0|			m_connected_to[par_b][2*i]   = m_connected_to[par_b][2*(m_n_connected_to[par_b]-1)];
   89|      0|			m_connected_to[par_b][2*i+1] = m_connected_to[par_b][2*(m_n_connected_to[par_b]-1)+1];
   90|      0|			m_n_connected_to[par_b]--;
   91|      0|			break;
   92|      0|		}
   93|      0|	}
   94|      0|}
   95|       |
   96|       |int Cedges_visited::is_edge_visited (int par_a, int par_b)
   97|      0|{
   98|      0|	int i;
   99|      0|	for (i=0; i<m_n_connected_to[par_a]; i++)
  100|      0|		if (m_connected_to[par_a][2*i] == par_b)
  101|      0|			return m_connected_to[par_a][2*i+1];
  102|      0|		return -1;
  103|      0|}
  104|       |/*** End class Cedges_visited ***/
  105|       |
  106|       |
  107|       |/**
  108|       | * Constructor
  109|       | */
  110|       |Che_edge::Che_edge ()
  111|      0|{
  112|      0|	m_v_begin = -1;
  113|      0|	m_v_end = -1;
  114|      0|	m_pair = NULL;
  115|      0|	m_face = -1;
  116|      0|	m_he_next = NULL;
  117|      0|	m_visited = false;
  118|      0|	m_valid = 1;
  119|      0|	m_data = NULL;
  120|      0|}
  121|       |
  122|       |Che_edge::~Che_edge ()
  123|      0|{
  124|      0|}
  125|       |
  126|       |void Che_edge::dump (void)
  127|      0|{
  128|      0|	printf ("edge 0x%x : ", this);
  129|      0|	if (m_valid)
  130|      0|	{
  131|      0|		printf ("(face %d) (vertices %d -> %d) (pair 0x%x %d -> %d) (next 0x%x %d -> %d) (data : %x)\n",
  132|      0|			m_face, m_v_begin, m_v_end,
  133|      0|			m_pair, (m_pair)?m_pair->m_v_begin:-1, (m_pair)?m_pair->m_v_end:-1,
  134|      0|			m_he_next, (m_he_next)?m_he_next->m_v_begin:-1, (m_he_next)?m_he_next->m_v_end:-1,
  135|      0|			m_data);
  136|      0|	}
  137|      0|	else
  138|      0|		printf ("not valid\n", m_valid);
  139|      0|}
  140|       |
  141|       |Che_mesh::Che_mesh ()
  142|      1|{
  143|      1|	m_edges = NULL;
  144|       |	//n_vertices = 0;
  145|      1|	m_edges_vertex = NULL;
  146|       |	//n_faces = 0;
  147|      1|	m_edges_face = NULL;
  148|      1|	m_map_edges = new map_edges;
  149|      1|	map_edges_vertex = new std::map<int,Che_edge*>;
  150|      1|	map_edges_face = new std::map<int,Che_edge*>;
  151|      1|}
  152|       |
  153|       |Che_mesh::~Che_mesh ()
  154|      0|{
  155|      0|	if (m_edges)
  156|      0|	{
  157|      0|		for (int i=0; i<m_ne; i++)
  158|      0|		{
  159|      0|			delete m_edges[i];
  160|      0|			m_edges[i] = NULL;
  161|      0|		}
  162|      0|		free (m_edges);
  163|      0|	}
  164|      0|}
  165|       |
  166|       |void Che_mesh::dump (void)
  167|      0|{
  168|      0|	printf ("map_edges :\n");
  169|      0|	for (std::map<std::pair<int,int>,Che_edge*>::iterator it=m_map_edges->begin ();
  170|      0|	     it != m_map_edges->end ();
  171|      0|	     it++)
  172|      0|	{
  173|      0|		Che_edge *he = it->second;
  174|      0|		if (he)
  175|      0|			he->dump ();
  176|      0|	}
  177|      0|}
  178|       |
  179|       |void Che_mesh::dump_around_vertex (unsigned int vi)
  180|      0|{
  181|      0|	std::map<int,Che_edge*>::iterator it = map_edges_vertex->find (vi);
  182|      0|	if (it == map_edges_vertex->end())
  183|      0|	{
  184|      0|		printf ("no edge starting from %d\n", vi);
  185|      0|		return;
  186|      0|	}
  187|       |		
  188|      0|	Che_edge *e = it->second;
  189|      0|	if (!e) // isolated vertex
  190|      0|	{
  191|      0|		printf ("no edge starting from %d (isolated vertex)\n", vi);
  192|      0|		return;
  193|      0|	}
  194|       |
  195|      0|	Che_edge *e_walk = e;
  196|      0|	do
  197|      0|	{
  198|      0|		if (e_walk && e_walk->m_valid)
  199|      0|			e_walk->dump ();
  200|       |
  201|      0|		e_walk = e_walk->m_he_next->m_he_next->m_pair;
  202|      0|	} while (e_walk != e);
  203|      0|}
  204|       |
  205|       |void Che_mesh::add_face (int fi, int v1, int v2, int v3)
  206|      0|{
  207|      0|	std::map<std::pair<int,int>,Che_edge*>::iterator it;
  208|       |
  209|      0|	Che_edge *e_v1v2 = new Che_edge ();
  210|      0|	Che_edge *e_v2v3 = new Che_edge ();
  211|      0|	Che_edge *e_v3v1 = new Che_edge ();
  212|       |
  213|      0|	e_v1v2->m_v_begin = v1;
  214|      0|	e_v1v2->m_v_end = v2;
  215|      0|	e_v1v2->m_he_next = e_v2v3;
  216|      0|	e_v1v2->m_face = fi;
  217|      0|	it = m_map_edges->find (std::make_pair(v2, v1));
  218|      0|	if (it != m_map_edges->end ())
  219|      0|	{
  220|      0|		e_v1v2->m_pair = it->second;
  221|      0|		it->second->m_pair = e_v1v2;
  222|      0|	}
  223|       |
  224|      0|	e_v2v3->m_v_begin = v2;
  225|      0|	e_v2v3->m_v_end = v3;
  226|      0|	e_v2v3->m_he_next = e_v3v1;
  227|      0|	e_v2v3->m_face = fi;
  228|      0|	it = m_map_edges->find (std::make_pair(v3, v2));
  229|      0|	if (it != m_map_edges->end ())
  230|      0|	{
  231|      0|		e_v2v3->m_pair = it->second;
  232|      0|		it->second->m_pair = e_v2v3;
  233|      0|	}
  234|       |
  235|      0|	e_v3v1->m_v_begin = v3;
  236|      0|	e_v3v1->m_v_end = v1;
  237|      0|	e_v3v1->m_he_next = e_v1v2;
  238|      0|	e_v3v1->m_face = fi;
  239|      0|	it = m_map_edges->find (std::make_pair(v1, v3));
  240|      0|	if (it != m_map_edges->end ())
  241|      0|	{
  242|      0|		e_v3v1->m_pair = it->second;
  243|      0|		it->second->m_pair = e_v3v1;
  244|      0|	}
  245|       |
  246|      0|	m_map_edges->insert (std::make_pair (std::make_pair(v1,v2), e_v1v2));
  247|      0|	m_map_edges->insert (std::make_pair (std::make_pair(v2,v3), e_v2v3));
  248|      0|	m_map_edges->insert (std::make_pair (std::make_pair(v3,v1), e_v3v1));
  249|       |
  250|      0|	map_edges_vertex->insert (std::make_pair (v1, e_v1v2));
  251|      0|	map_edges_vertex->insert (std::make_pair (v2, e_v2v3));
  252|      0|	map_edges_vertex->insert (std::make_pair (v3, e_v3v1));
  253|      0|	map_edges_face->insert (std::make_pair (fi, e_v1v2));
  254|      0|}
  255|       |
  256|       |int Che_mesh::is_border (int vi)
  257|      0|{
  258|      0|	std::map<int,Che_edge*>::iterator it = map_edges_vertex->find (vi);
  259|      0|	if (it == map_edges_vertex->end())
  260|      0|		return -1;
  261|       |		
  262|      0|	Che_edge *e = it->second;
  263|      0|	if (!e) // isolated vertex
  264|      0|		return 1;
  265|       |
  266|      0|	Che_edge *e_walk = e;
  267|      0|	do
  268|      0|	{
  269|      0|		if (e_walk == NULL || !e_walk->m_valid)
  270|      0|			return 1;
  271|      0|		e_walk = e_walk->m_he_next->m_he_next->m_pair;
  272|      0|	} while (e_walk != e);
  273|       |
  274|      0| 	return 0;
  275|      0|}
  276|       |
  277|       |int Che_mesh::vertex_is_near_border (int vi)
  278|      0|{
  279|      0|	std::map<int,Che_edge*>::iterator it = map_edges_vertex->find (vi);
  280|      0|	if (it == map_edges_vertex->end ())
  281|      0|		return -1;
  282|       |
  283|      0|	Che_edge *e = it->second;
  284|      0|	Che_edge *e_walk = e;
  285|      0|	do
  286|      0|	{
  287|      0|		if (is_border (e_walk->m_v_end))
  288|      0|			return 1;
  289|       |		
  290|      0|		e_walk = e_walk->m_he_next->m_he_next->m_pair;
  291|      0|	} while (e_walk != e);
  292|       |
  293|      0|	return 0;
  294|      0|}
  295|       |
  296|       |// search
  297|       |Che_edge* Che_mesh::get_edge (int v1, int v2)
  298|      0|{
  299|      0|	std::map<std::pair<int,int>,Che_edge*>::iterator it = m_map_edges->find (std::make_pair(v1, v2));
  300|      0|	return (it == m_map_edges->end())? NULL : it->second;
  301|      0|}
  302|       |
  303|       |Che_edge* Che_mesh::get_edge_from_vertex (int vi)
  304|      0|{
  305|      0|	std::map<int,Che_edge*>::iterator it = map_edges_vertex->find (vi);
  306|      0|	if (it == map_edges_vertex->end())
  307|      0|		return NULL;
  308|      0|	return it->second;
  309|      0|}
  310|       |
  311|       |Che_edge* Che_mesh::get_edge_from_face (int fi)
  312|      0|{
  313|      0|	std::map<int,Che_edge*>::iterator it = map_edges_face->find (fi);
  314|      0|	if (it == map_edges_vertex->end())
  315|      0|		return NULL;
  316|      0|	return it->second;
  317|      0|}
  318|       |
  319|       |/**
  320|       | * Create the half edge structure from the arrays containing the vertices and the faces.
  321|       | */
  322|       |void Che_mesh::create_half_edge (unsigned int nVertices, unsigned int nFaces, unsigned int *pFaces)
  323|      1|{
  324|      1|	if (!m_map_edges)
  325|      0|		m_map_edges = new map_edges;
  326|      1|	int i;
  327|       |
  328|       |	// init the half edge structure
  329|      1|	m_edges_vertex = (Che_edge**)malloc(nVertices*sizeof(Che_edge*));
  330|      1|	m_edges_face   = (Che_edge**)malloc(nFaces*sizeof(Che_edge*));
  331|      1|	m_ne           = 3*nFaces;
  332|      1|	m_edges        = (Che_edge**)malloc(m_ne*sizeof(Che_edge*));
  333|      1|	for (i=0; i<nVertices; i++)
  334|      0|		m_edges_vertex[i] = NULL;
  335|      1|	for (i=0; i<nFaces; i++)
  336|      0|	{
  337|      0|		int loc_a = pFaces[3*i];
  338|      0|		int loc_b = pFaces[3*i+1];
  339|      0|		int loc_c = pFaces[3*i+2];
  340|       |
  341|      0|		add_face (i, loc_a, loc_b, loc_c); // fill m_map_edges
  342|       |		
  343|      0|		m_edges[3*i] = new Che_edge ();
  344|      0|		m_edges[3*i]->m_v_begin = loc_a;
  345|      0|		m_edges[3*i]->m_v_end   = loc_b;
  346|      0|		m_edges[3*i]->m_face    = i;
  347|      0|		m_edges_vertex[loc_a] = m_edges[3*i];
  348|       |		
  349|      0|		m_edges[3*i+1] = new Che_edge ();
  350|      0|		m_edges[3*i+1]->m_v_begin = loc_b;
  351|      0|		m_edges[3*i+1]->m_v_end   = loc_c;
  352|      0|		m_edges[3*i+1]->m_face    = i;
  353|      0|		m_edges_vertex[loc_b] = m_edges[3*i+1];
  354|       |		
  355|      0|		m_edges[3*i+2] = new Che_edge ();
  356|      0|		m_edges[3*i+2]->m_v_begin = loc_c;
  357|      0|		m_edges[3*i+2]->m_v_end   = loc_a;
  358|      0|		m_edges[3*i+2]->m_face    = i;
  359|      0|		m_edges_vertex[loc_c] = m_edges[3*i+2];
  360|       |		
  361|      0|		m_edges[3*i]->m_he_next   = m_edges[3*i+1];
  362|      0|		m_edges[3*i+1]->m_he_next = m_edges[3*i+2];
  363|      0|		m_edges[3*i+2]->m_he_next = m_edges[3*i];
  364|       |		
  365|      0|		m_edges_face[i] = m_edges[3*i+2];
  366|      0|	}
  367|       |	
  368|       |	// build the half edge structure
  369|      1|	Cedges_visited *loc_ev = new Cedges_visited (nVertices);
  370|      1|	for (i=0; i<3*nFaces; i++)
  371|      0|	{
  372|      0|		int loc_a,loc_b,index;
  373|      0|		loc_a = m_edges[i]->m_v_begin;
  374|      0|		loc_b = m_edges[i]->m_v_end;
  375|       |		
  376|      0|		index = loc_ev->is_edge_visited (loc_a,loc_b);
  377|      0|		if (index != -1)
  378|      0|		{
  379|      0|			m_edges[i]->m_pair	= m_edges[index];
  380|      0|			m_edges[index]->m_pair	= m_edges[i];
  381|      0|			loc_ev->delete_edge (loc_a,loc_b);
  382|      0|		}
  383|      0|		else
  384|      0|			loc_ev->add_edge (loc_a,loc_b,i);
  385|      0|	}
  386|      1|	delete loc_ev;
  387|      1|}
  388|       |
  389|       |
  390|       |/**
  391|       |* Flip an edge.
  392|       |*
  393|       |\verbatim
  394|       |       *                     *
  395|       |      /|\                   / \ 
  396|       |     / | \                 /   \ 
  397|       | e1 /  |  \ e4         e1 /     \ e4
  398|       |   /   |   \             /  ep   \ 
  399|       |  * edge    *    --->   *---------*
  400|       |   \   |ep /             \ edge  /
  401|       | e2 \  |  / e3         e2 \     / e3
  402|       |     \ | /                 \   /
  403|       |      \|/                   \ /
  404|       |       *                     *
  405|       |\endverbatim
  406|       |*/
  407|       |void Che_mesh::edge_flip (Che_edge *par_edge)
  408|      0|{
  409|      0|	if (par_edge->m_pair == NULL)
  410|      0|		return;
  411|       |
  412|       |	// get the half edges
  413|      0|	Che_edge *loc_e1 = par_edge->m_he_next;
  414|      0|	Che_edge *loc_e2 = loc_e1->m_he_next;
  415|      0|	Che_edge *loc_ep = par_edge->m_pair;
  416|      0|	Che_edge *loc_e3 = loc_ep->m_he_next;
  417|      0|	Che_edge *loc_e4 = loc_e3->m_he_next;
  418|       |
  419|       |	// update the links
  420|      0|	par_edge->m_he_next	= loc_e2;
  421|      0|	loc_e2->m_he_next	= loc_e3;
  422|      0|	loc_e3->m_he_next	= par_edge;
  423|       |
  424|      0|	loc_ep->m_he_next	= loc_e4;
  425|      0|	loc_e4->m_he_next	= loc_e1;
  426|      0|	loc_e1->m_he_next	= loc_ep;
  427|       |
  428|       |	// update the extremities
  429|      0|	par_edge->m_v_begin	= loc_e3->m_v_end;
  430|      0|	par_edge->m_v_end	= loc_e2->m_v_begin;
  431|      0|	loc_ep->m_v_begin	= loc_e1->m_v_end;
  432|      0|	loc_ep->m_v_end		= loc_e4->m_v_begin;
  433|       |
  434|       |	// update the faces
  435|      0|	int loc_f1 = par_edge->m_face;
  436|      0|	int loc_f2 = loc_ep->m_face;
  437|       |
  438|      0|	loc_e1->m_face = loc_f2;
  439|      0|	loc_e2->m_face = loc_f1;
  440|      0|	loc_e3->m_face = loc_f1;
  441|      0|	loc_e4->m_face = loc_f2;
  442|       |/*
  443|       |	m_pFaces[3*loc_f1]->SetVertex (0, loc_e4->m_v_begin);
  444|       |	m_pFaces[3*loc_f1]->SetVertex (1, loc_e2->m_v_begin);
  445|       |	m_pFaces[3*loc_f1]->SetVertex (2, loc_e3->m_v_begin);
  446|       |
  447|       |	m_pFaces[3*loc_f2]->SetVertex (0, loc_e2->m_v_begin);
  448|       |	m_pFaces[3*loc_f2]->SetVertex (1, loc_e4->m_v_begin);
  449|       |	m_pFaces[3*loc_f2]->SetVertex (2, loc_e1->m_v_begin);
  450|       |*/
  451|       |	// update half edge from vertex
  452|      0|	m_edges_vertex[loc_e1->m_v_begin] = loc_e1;
  453|      0|	m_edges_vertex[loc_e2->m_v_begin] = loc_e2;
  454|      0|	m_edges_vertex[loc_e3->m_v_begin] = loc_e3;
  455|      0|	m_edges_vertex[loc_e4->m_v_begin] = loc_e4;
  456|       |
  457|       |	// update half edge from face (not necessary)
  458|      0|	m_edges_face[loc_f1] = par_edge;
  459|      0|	m_edges_face[loc_f2] = loc_ep;
  460|      0|}
  461|       |
  462|       |/**
  463|       |* Split an edge.
  464|       |*
  465|       |\verbatim
  466|       |
  467|       |       *                     *
  468|       |      / \                   /|\ 
  469|       |     /   \                 / | \ 
  470|       | e4 /     \ e3         e4 /  |  \ e3
  471|       |   /  ep   \             /   |   \ 
  472|       |  *---------*    --->   *----*----*
  473|       |   \ edge  /             \   |   /
  474|       | e1 \     / e2         e1 \  |  / e2
  475|       |     \   /                 \ | /
  476|       |      \ /                   \|/
  477|       |       *                     *
  478|       |
  479|       |\endverbatim
  480|       |*/
  481|       |void Che_mesh::edge_split (Che_edge *par_edge)
  482|      0|{
  483|      0|	if (par_edge->m_pair == NULL)
  484|      0|		return;
  485|      0|}
  486|       |
  487|       |/**
  488|       |* Contract an edge.
  489|       |*
  490|       |\verbatim
  491|       |    *---------*
  492|       |    |\       /|
  493|       |    | \     / |
  494|       |    |  \v2 /  |
  495|       |    |   \ /   |
  496|       |    |    *    |          *---------*
  497|       |    |e1p/|\e4p|          |\       /|
  498|       |    |  / | \  |          | \     / |
  499|       |    | /e1|e4\ |          |  \   /  |
  500|       |    |/   |   \|          |e1p\ /e4p|
  501|       | v3 *   e|ep  * v4--->   *----*----*
  502|       |    |\   |   /|          |e2p/ \e3p|
  503|       |    | \e2|e3/ |          |  /   \  |
  504|       |    |  \ | /  |          | /     \ |
  505|       |    |e2p\|/e3p|          |/       \|
  506|       |    |    *    |          *---------*
  507|       |    |   / \   |
  508|       |    |  / v1\  |
  509|       |    | /     \ |
  510|       |    |/       \|
  511|       |    *---------*
  512|       |\endverbatim
  513|       |*/
  514|       |void Che_mesh::edge_contract (Che_edge *edge)
  515|      0|{
  516|      0|	if (edge->m_pair == NULL)
  517|      0|		return;
  518|       |
  519|       |	// vertices implied in the edge
  520|      0|	int iv1 = edge->m_v_begin;
  521|      0|	int iv2 = edge->m_v_end;
  522|       |	
  523|       |	// faces implied int the edge
  524|      0|	int f1 = edge->m_face;
  525|      0|	int f2 = edge->m_pair->m_face;
  526|       |
  527|       |	// init the half edges
  528|      0|	Che_edge *e1 = edge->m_he_next;
  529|      0|	Che_edge *e2 = e1->m_he_next;
  530|      0|	Che_edge *ep = edge->m_pair;
  531|      0|	Che_edge *e3 = ep->m_he_next;
  532|      0|	Che_edge *e4 = e3->m_he_next;
  533|       |
  534|      0|	Che_edge *e1p = e1->m_pair;
  535|      0|	Che_edge *e2p = e2->m_pair;
  536|      0|	Che_edge *e3p = e3->m_pair;
  537|      0|	Che_edge *e4p = e4->m_pair;
  538|       |
  539|       |	// update the links between the remaining half edges
  540|      0|	if (e1p != NULL) e1p->m_pair = e2p;
  541|      0|	if (e2p != NULL) e2p->m_pair = e1p;
  542|      0|	if (e3p != NULL) e3p->m_pair = e4p;
  543|      0|	if (e4p != NULL) e4p->m_pair = e3p;
  544|      0|	if (e1p != NULL) e1p->m_v_end   = iv1;
  545|      0|	if (e4p != NULL) e4p->m_v_begin = iv1;
  546|       |
  547|       |/*
  548|       |	// update the vertex
  549|       |	m_pVertices[3*iv1]   = (m_pVertices[3*iv1] + m_pVertices[3*iv2])*0.5;
  550|       |	m_pVertices[3*iv1+1] = (m_pVertices[3*iv1+1] + m_pVertices[3*iv2+1])*0.5;
  551|       |	m_pVertices[3*iv1+2] = (m_pVertices[3*iv1+2] + m_pVertices[3*iv2+2])*0.5;
  552|       |*/
  553|      0|	m_edges_vertex[iv1] = e4p;//NULL;
  554|      0|	m_edges_vertex[iv2] = NULL;
  555|       |
  556|       |	// delete e1, e2, e3, e4, edge and ep
  557|       |	/*
  558|       |	delete e1;		e1   = NULL;
  559|       |	delete e2;		e2   = NULL;
  560|       |	delete e3;		e3   = NULL;
  561|       |	delete e4;		e4   = NULL;
  562|       |	delete edge;	        edge = NULL;
  563|       |	delete ep;		ep   = NULL;
  564|       |	*/
  565|      0|	e1->m_valid = 0;
  566|      0|	e2->m_valid = 0;
  567|      0|	e3->m_valid = 0;
  568|      0|	e4->m_valid = 0;
  569|      0|	edge->m_valid = 0;
  570|      0|	ep->m_valid = 0;
  571|       |
  572|       |/*
  573|       |	// init the faces
  574|       |	int f1 = par_edge->m_face;
  575|       |	int f2 = ep->m_face;
  576|       |
  577|       |	// delete f1 and f2
  578|       |	m_pFaces[3*f1]->SetVertex (0, m_pFaces[3*(m_nFaces-1)]->GetVertex (0));
  579|       |	m_pFaces[3*f1]->SetVertex (1, m_pFaces[3*(m_nFaces-1)]->GetVertex (1));
  580|       |	m_pFaces[3*f1]->SetVertex (2, m_pFaces[3*(m_nFaces-1)]->GetVertex (2));
  581|       |
  582|       |	m_pFaces[3*f2]->SetVertex (0, m_pFaces[3*(m_nFaces-2)]->GetVertex (0));
  583|       |	m_pFaces[3*f2]->SetVertex (1, m_pFaces[3*(m_nFaces-2)]->GetVertex (1));
  584|       |	m_pFaces[3*f2]->SetVertex (2, m_pFaces[3*(m_nFaces-2)]->GetVertex (2));
  585|       |
  586|       |	m_nFaces -= 2;
  587|       |*/
  588|      0|	m_edges_face[f1] = NULL;
  589|      0|       	m_edges_face[f2] = NULL;
  590|      0|}
  591|       |
  592|       |int Che_mesh::is_edge_contract2_valid (Che_edge *edge)
  593|      0|{
  594|      0|	if (!edge->m_valid)
  595|      0|	{
  596|      0|		printf ("unvalid edge : 0x%x : %d -> %d\n", edge, edge->m_v_begin, edge->m_v_end);
  597|      0|		return 0;
  598|      0|	}
  599|       |
  600|      0|	if (edge->m_pair == NULL)
  601|      0|		return 0;
  602|       |	// vertices implied in the edge
  603|      0|	int iv1 = edge->m_v_begin;
  604|      0|	int iv2 = edge->m_v_end;
  605|       |	
  606|      0|	int iv3 = edge->m_he_next->m_v_end;
  607|      0|	int iv4 = edge->m_pair->m_he_next->m_v_end;
  608|       |	
  609|      0|	Che_edge *e1 = get_edge_from_vertex (iv1);
  610|      0|	Che_edge *e2 = get_edge_from_vertex (iv2);
  611|      0|	if (!e1 || !e2)
  612|      0|		return 0;
  613|       |
  614|      0|	Che_edge *walk1 = e1;
  615|      0|	do {
  616|      0|		int vwalk1 = walk1->m_v_end;
  617|      0|		if (vwalk1 == iv1 || vwalk1 == iv3 || vwalk1 == iv4)
  618|      0|			continue;
  619|       |
  620|      0|		Che_edge *walk2 = e2;
  621|      0|		do {
  622|      0|			int vwalk2 = walk1->m_v_end;
  623|      0|			if (vwalk1 == vwalk2)
  624|      0|				return 0;
  625|       |
  626|      0|			walk2 = walk2->m_pair;
  627|      0|		} while (walk2 != e2);
  628|       |
  629|      0|		walk1 = walk1->m_pair;
  630|      0|	} while (walk1 != e1);
  631|       |
  632|      0|	return 1;
  633|      0|}
  634|       |
  635|       |int Che_mesh::edge_contract2 (Che_edge *edge)
  636|      0|{
  637|      0|	if (!is_edge_contract2_valid (edge))
  638|      0|		return -1;
  639|       |
  640|       |	// vertices implied in the edge
  641|      0|	int iv1 = edge->m_v_begin;
  642|      0|	int iv2 = edge->m_v_end;
  643|       |	
  644|      0|	int iv3 = edge->m_he_next->m_v_end;
  645|      0|	int iv4 = edge->m_pair->m_he_next->m_v_end;
  646|       |
  647|       |	// faces implied int the edge
  648|      0|	int f1 = edge->m_face;
  649|      0|	int f2 = edge->m_pair->m_face;
  650|       |
  651|       |	// init the half edges
  652|      0|	Che_edge *e1 = edge->m_he_next;
  653|      0|	Che_edge *e2 = e1->m_he_next;
  654|      0|	Che_edge *ep = edge->m_pair;
  655|      0|	Che_edge *e3 = ep->m_he_next;
  656|      0|	Che_edge *e4 = e3->m_he_next;
  657|       |
  658|      0|	Che_edge *e1p = e1->m_pair;
  659|      0|	Che_edge *e2p = e2->m_pair;
  660|      0|	Che_edge *e3p = e3->m_pair;
  661|      0|	Che_edge *e4p = e4->m_pair;
  662|       |
  663|       |	// replace v2 by v1 all around v2
  664|      0|	{
  665|      0|		Che_edge *walk = edge->m_pair;
  666|      0|		do {
  667|      0|			std::map<std::pair<int,int>,Che_edge*>::iterator it;
  668|      0|			it = m_map_edges->find (std::make_pair(walk->m_v_begin, walk->m_v_end));
  669|      0|			if (it != m_map_edges->end ())
  670|      0|				m_map_edges->erase (it);
  671|       |
  672|       |
  673|       |			//printf ("%x %x\n", walk, edge->m_pair);
  674|      0|			if (walk != e1 && walk != edge->m_pair)
  675|      0|			{
  676|      0|				walk->m_v_begin = iv1;
  677|      0|				m_map_edges->insert (std::make_pair(std::make_pair(walk->m_v_begin, walk->m_v_end), walk));
  678|      0|			}
  679|       |			
  680|      0|			walk = walk->m_he_next->m_he_next;
  681|       |
  682|      0|			it = m_map_edges->find (std::make_pair(walk->m_v_begin, walk->m_v_end));
  683|      0|			if (it != m_map_edges->end ())
  684|      0|				m_map_edges->erase (it);
  685|       |
  686|      0|			if (walk != edge && walk != e4)
  687|      0|			{
  688|      0|				walk->m_v_end = iv1;
  689|      0|				m_map_edges->insert (std::make_pair(std::make_pair(walk->m_v_begin, walk->m_v_end), walk));
  690|      0|			}
  691|       |
  692|      0|			walk = walk->m_pair;
  693|      0|		} while (walk != edge->m_pair);
  694|       |/*
  695|       |		walk = edge;
  696|       |		do {
  697|       |			//printf ("%x %x\n", walk, edge);
  698|       |			walk = walk->m_he_next->m_he_next;
  699|       |			walk = walk->m_pair;
  700|       |		} while (walk != edge);
  701|       |*/
  702|      0|	}
  703|       |
  704|       |	// update the links between the remaining half edges
  705|      0|	if (e1p) e1p->m_pair = e2p;
  706|      0|	if (e2p) e2p->m_pair = e1p;
  707|      0|	if (e3p) e3p->m_pair = e4p;
  708|      0|	if (e4p) e4p->m_pair = e3p;
  709|       |	//if (e1p) e1p->m_v_end   = iv1;
  710|       |	//if (e4p) e4p->m_v_begin = iv1;
  711|       |
  712|       |
  713|       |	// discard edge, ep, e1, e2, e3 & e4
  714|       |/*
  715|       |	if (1) {
  716|       |		Che_edge *edges_to_delete[6] = {e1, e2, e3, e4, edge, ep};
  717|       |		for (int i=4; i<6; i++)
  718|       |		{
  719|       |			Che_edge *e = edges_to_delete[i];
  720|       |			e->dump ();
  721|       |			std::map<std::pair<int,int>,Che_edge*>::iterator it;
  722|       |			printf ("%d %d\n", e->m_v_begin, e->m_v_end);
  723|       |			it = m_map_edges->find (std::make_pair(e->m_v_begin, e->m_v_end));
  724|       |			if (it != m_map_edges->end ())
  725|       |			{
  726|       |				delete (it->second);
  727|       |				m_map_edges->erase (it);
  728|       |			}
  729|       |		}
  730|       |	}
  731|       |	else
  732|       |	{
  733|       |		std::map<std::pair<int,int>,Che_edge*>::iterator it;
  734|       |		it = m_map_edges->find (std::make_pair(iv1, iv2));
  735|       |		if (it != m_map_edges->end ())
  736|       |		{
  737|       |			delete (it->second);
  738|       |			m_map_edges->erase (it);
  739|       |		}
  740|       |		it = m_map_edges->find (std::make_pair(iv2, iv1));
  741|       |		if (it != m_map_edges->end ())
  742|       |		{
  743|       |			delete (it->second);
  744|       |			m_map_edges->erase (it);
  745|       |		}
  746|       |	}
  747|       |*/
  748|       |
  749|       |
  750|      0|	e1->m_valid = 0;
  751|      0|	e2->m_valid = 0;
  752|      0|	e3->m_valid = 0;
  753|      0|	e4->m_valid = 0;
  754|      0|	edge->m_valid = 0;
  755|      0|	ep->m_valid = 0;
  756|       |
  757|       |
  758|       |
  759|       |/*
  760|       |	// update the vertex
  761|       |	m_pVertices[3*iv1]   = (m_pVertices[3*iv1] + m_pVertices[3*iv2])*0.5;
  762|       |	m_pVertices[3*iv1+1] = (m_pVertices[3*iv1+1] + m_pVertices[3*iv2+1])*0.5;
  763|       |	m_pVertices[3*iv1+2] = (m_pVertices[3*iv1+2] + m_pVertices[3*iv2+2])*0.5;
  764|       |*/
  765|      0|	map_edges_vertex->erase (iv1);
  766|      0|	map_edges_vertex->insert (std::make_pair (iv1, e4p));
  767|      0|	map_edges_vertex->erase (iv2);
  768|       |
  769|      0|	map_edges_vertex->erase (iv3);
  770|      0|	map_edges_vertex->insert (std::make_pair (iv3, e1p));
  771|      0|	map_edges_vertex->erase (iv4);
  772|      0|	map_edges_vertex->insert (std::make_pair (iv4, e3p));
  773|       |
  774|       |	// delete e1, e2, e3, e4, edge and ep
  775|       |/*
  776|       |	delete e1;		e1   = NULL;
  777|       |	delete e2;		e2   = NULL;
  778|       |	delete e3;		e3   = NULL;
  779|       |	delete e4;		e4   = NULL;
  780|       |	delete edge;	        edge = NULL;
  781|       |	delete ep;		ep   = NULL;
  782|       |*/
  783|       |
  784|       |/*
  785|       |	// init the faces
  786|       |	int f1 = par_edge->m_face;
  787|       |	int f2 = ep->m_face;
  788|       |
  789|       |	// delete f1 and f2
  790|       |	m_pFaces[3*f1]->SetVertex (0, m_pFaces[3*(m_nFaces-1)]->GetVertex (0));
  791|       |	m_pFaces[3*f1]->SetVertex (1, m_pFaces[3*(m_nFaces-1)]->GetVertex (1));
  792|       |	m_pFaces[3*f1]->SetVertex (2, m_pFaces[3*(m_nFaces-1)]->GetVertex (2));
  793|       |
  794|       |	m_pFaces[3*f2]->SetVertex (0, m_pFaces[3*(m_nFaces-2)]->GetVertex (0));
  795|       |	m_pFaces[3*f2]->SetVertex (1, m_pFaces[3*(m_nFaces-2)]->GetVertex (1));
  796|       |	m_pFaces[3*f2]->SetVertex (2, m_pFaces[3*(m_nFaces-2)]->GetVertex (2));
  797|       |
  798|       |	m_nFaces -= 2;
  799|       |*/
  800|      0|	map_edges_face->erase (f1);
  801|      0|	map_edges_face->erase (f2);
  802|       |
  803|      0|	return 0;
  804|      0|}
  805|       |

/workspaces/cg/src/cgmesh/half_edge.h:
    1|       |#ifndef __HALF_EDGE_H__
    2|       |#define __HALF_EDGE_H__
    3|       |
    4|       |#include <map>
    5|       |
    6|       |//
    7|       |// Half edge structure
    8|       |//
    9|       |class Che_edge
   10|       |{
   11|       |public:
   12|       |	Che_edge ();
   13|       |	~Che_edge ();
   14|       |
   15|       |public:
   16|       |	int m_v_begin;	      //!< vertex at the beginning of the half-edge
   17|       |	int m_v_end;	      //!< vertex at the end of the half-edge
   18|       |	Che_edge *m_pair;     //!< opposite half-edge
   19|       |	int m_face;			  //!< index of the face
   20|       |	Che_edge *m_he_next;  //!< next half-edge around the face
   21|       |	bool m_visited;	      //!< flag
   22|       |	int m_flag;
   23|       |	void *m_data;
   24|       |
   25|       |	void dump (void);
   26|       |
   27|       |	char m_valid;
   28|       |};
   29|       |
   30|       |//
   31|       |// Half edge mesh structure
   32|       |//
   33|       |class Che_mesh
   34|       |{
   35|       |	friend class Citerator_half_edges_vertex;
   36|       |
   37|       |public:
   38|       |	Che_mesh ();
   39|       |	~Che_mesh ();
   40|       |
   41|       |	void dump (void);
   42|       |	void dump_around_vertex (unsigned int vi);
   43|       |
   44|       |	void create_half_edge (unsigned int nVertices, unsigned int nFaces, unsigned int *pFaces);
   45|       |	void add_face (int fi, int v1, int v2, int v3);
   46|       |	
   47|       |	int is_border (int v1); 
   48|       |	int vertex_is_near_border (int vi);
   49|       |
   50|       |	// get
   51|       |	Che_edge* get_edge (int v1, int v2);
   52|       |	Che_edge* get_edge_from_vertex (int vi);
   53|       |	Che_edge* get_edge_from_face (int fi);
   54|       |
   55|       |	// basic operations
   56|       |	void edge_flip     (Che_edge *e);
   57|       |	void edge_split    (Che_edge *e);
   58|       |	void edge_contract (Che_edge *e);
   59|       |
   60|       |	int is_edge_contract2_valid (Che_edge *edge);
   61|       |	int edge_contract2 (Che_edge *e);
   62|       |
   63|       |public:
   64|       |	int m_ne;
   65|       |	Che_edge **m_edges;
   66|       |	//unsigned int n_vertices;
   67|       |	Che_edge **m_edges_vertex;
   68|       |	//unsigned int n_faces;
   69|       |	Che_edge **m_edges_face;
   70|       |
   71|       |	std::map<int,Che_edge*> *map_edges_vertex;
   72|       |	std::map<int,Che_edge*> *map_edges_face;
   73|       |	typedef std::map<std::pair<int,int>,Che_edge*> map_edges;
   74|       |	map_edges *m_map_edges;
   75|       |};
   76|       |
   77|       |//
   78|       |// Half edge iterator
   79|       |//
   80|       |// This iterator is used to visit the vertices around a vertex identified by the index par_ivertex.
   81|       |//
   82|       |class Citerator_half_edges_vertex
   83|       |{
   84|       |public:
   85|       |
   86|       |	Citerator_half_edges_vertex (Che_mesh *par_model, int par_ivertex)
   87|      0|	{
   88|      0|		m_he_first = par_model->m_edges_vertex[par_ivertex];
   89|      0|		m_he_current = m_he_first;
   90|      0|		m_is_last = false;
   91|      0|	};
   92|       |
   93|      0|	Che_edge* first (void) { return m_he_first; };
   94|      0|	bool isLast (void) { return m_is_last; };
   95|       |
   96|      0|	Che_edge* prev (void) {
   97|      0|		m_he_current = m_he_current->m_pair->m_he_next;
   98|      0|		return m_he_current;
   99|      0|	};
  100|       |
  101|      0|	Che_edge* next (void) {
  102|      0|		m_he_current = m_he_current->m_he_next->m_he_next->m_pair;
  103|      0|		if (m_he_current == m_he_first) m_is_last = true;
  104|      0|		return m_he_current; 
  105|      0|	};
  106|       |
  107|      0|	Che_edge* current (void) { return m_he_current; };
  108|       |
  109|       |private:
  110|       |	Che_edge* m_he_first;
  111|       |	Che_edge* m_he_current;
  112|       |	bool m_is_last;
  113|       |};
  114|       |
  115|       |// cache for half edges
  116|       |class Cedges_visited
  117|       |{
  118|       |public:
  119|       |	Cedges_visited (int par_nv);
  120|       |	~Cedges_visited ();
  121|       |
  122|       |	void add_edge        (int par_a, int par_b, int par_index);
  123|       |	void delete_edge     (int par_a, int par_b);
  124|       |	int  is_edge_visited (int par_a, int par_b);
  125|       |
  126|       |private:
  127|       |	int **m_connected_to;
  128|       |	int *m_n_connected_to;
  129|       |	int *m_n_connections_max;
  130|       |	int m_nv;
  131|       |};
  132|       |
  133|       |#endif // __HALF_EDGE_H__
  134|       |

/workspaces/cg/src/cgmesh/image_vectorization.h:
    1|       |#ifndef __IMAGE_VECTORIZATION_H__
    2|       |#define __IMAGE_VECTORIZATION_H__
    3|       |
    4|       |#include <stdlib.h>
    5|       |#include <map>
    6|       |#include <list>
    7|       |#include <set>
    8|       |#include <vector>
    9|       |using namespace std;
   10|       |
   11|       |#include "../cgmath/cgmath.h"
   12|       |#include "../cgimg/cgimg.h"
   13|       |
   14|       |class TPoint
   15|       |{
   16|       |public:
   17|      0|	TPoint(){}
   18|      0|	TPoint(const int &xx,const int &yy) { x = xx; y = yy; }
   19|      0|	bool operator==(const TPoint& pt) const { return (x == pt.x && y == pt.y); }
   20|       |	int x;
   21|       |	int y;
   22|       |};
   23|       |typedef map<unsigned int,Vector2f> MapCoord;
   24|       |
   25|       |class TSegment
   26|       |{
   27|       |public:
   28|      0|	TSegment() {}
   29|      0|	TSegment(const TPoint& S,const TPoint& E) { s = S; e = E; }
   30|       |	TPoint s, e;
   31|       |};
   32|       |
   33|       |typedef list<TPoint>	    TPath;
   34|       |typedef list<TPath*>	    ListPath;
   35|       |typedef map<int, ListPath*> MapListPath;
   36|       |typedef multimap<int,int>   MapOrder;
   37|       |typedef map<unsigned long,TPath*> MapPath; 
   38|       |typedef map<unsigned long,set<unsigned long> > MapAdjacence;
   39|       |
   40|       |class CLitRasterToVector
   41|       |{
   42|       |public:
   43|       |	CLitRasterToVector(void);
   44|       |	virtual ~CLitRasterToVector(void);
   45|       |	bool Vectorize (Img* pInput,
   46|       |			Color colorMask,
   47|       |			bool bUseMask,
   48|       |			Palette *pPalette = NULL); // if NULL, a palette is calculated
   49|       |
   50|       |	void WriteFile (float fLineWidth) const;
   51|       |	void WriteFilePolygonWithHole (/*bool bBottomTop,
   52|       |				       bool bFill,
   53|       |				       bool bBorderColor,
   54|       |				       bool bDrawWhiteLayer,
   55|       |				       const Color* pForceFillColor,*/
   56|       |				       float fLineWidth/*,
   57|       |				       const Color& borderColor,
   58|       |				       bool bBorder*/) const;
   59|       |	void WriteFilePolygonWithHole2 (float fLineWidth);
   60|       |
   61|       |private:
   62|       |	bool GeneratePath	( const Img& sIndexed); 
   63|       |	void AddPath		( ListPath& listPath,const TPath& pathToAdd,MapPath& mapPathStart,MapPath& mapPathEnd);
   64|       |	bool MergePath		( ListPath& listPath,MapPath& mapPathStart,MapPath& mapPathEnd);
   65|       |
   66|       |	void SmoothCoords	( void );
   67|       |
   68|       |	void RemoveHoles	( ListPath& listPath, int iColorIndex, const Img& sIndexed );
   69|       |	bool GetLimitColor      ( const TPath& path,const Img& sIndexed,int& iInteriorColor,int& iExteriorColor);
   70|       |	bool GetLimitPixelCoord ( const TPath& path,TPoint& ptLimit);
   71|       |
   72|       |	const Vector2f& GetInterpolatedCoord( const TPoint& pt	);
   73|       |	const Vector2f& GetFinalCoord				( const TPoint& pt	) const;
   74|       |
   75|       |	void CalculateLayerOrder	( const Img& sPalettized);
   76|       |	void RemoveUselessPoint		( void );
   77|       |	void Simplify							( float fErr );
   78|       |	void BuildAdjacencyMap(MapAdjacence& mapAdjacence);
   79|       |
   80|       |	// result data
   81|       |	MapListPath	m_mapListPath;	// one list path by color index
   82|       |	Color*	    m_palette;
   83|       |	int		    m_iPaletteSize;
   84|       |	MapCoord	m_mapCoord;
   85|       |
   86|       |	list<TPath*>	m_layerOrder;
   87|       |	map<TPath*,int> m_pathColor;
   88|       |};
   89|       |
   90|       |#endif // __IMAGE_VECTORIZATION_H__

/workspaces/cg/src/cgmesh/light.cpp:
    1|       |#include <stdio.h>
    2|       |#include <math.h>
    3|       |
    4|       |#include "light.h"
    5|       |
    6|       |Light::Light()
    7|      8|{
    8|      8|	SetLightType (CG_LIGHT_TYPE_POINT);
    9|      8|	SetAmbientValue(0.5f, 0.5f, 0.5f, 1.0f);
   10|      8|	SetDiffuseValue (1.0f, 1.0f, 1.0f, 1.0f);
   11|      8|	SetSpecularValue (1.0f, 1.0f, 1.0f, 1.0f);
   12|       |	//SetPosition (2.0f, 3.0f, 5.0f);
   13|       |	//SetDirection (-2.0f, -3.0f, -5.0f);
   14|      8|	SetPosition (0.0f, 0.0f, 5.0f);
   15|      8|	SetDirection (0.0f, 0.0f, -1.0f);
   16|      8|	SetRange (180.0f);
   17|      8|	SetConstantAttenuation (1.0f);
   18|      8|	SetLinearAttenuation (0.0f);
   19|      8|	SetQuadraticAttenuation (0.0f);
   20|       |
   21|      8|	bEnable = false;
   22|      8|	bDisplay = false;
   23|      8|}
   24|       |
   25|       |Light::~Light()
   26|      4|{
   27|      4|}
   28|       |
   29|       |void Light::SetLightType(CG_LIGHT_TYPE eType)
   30|      8|{
   31|      8|	Type = eType;
   32|      8|}
   33|       |
   34|       |void Light::SetDiffuseValue( float r, float g, float b, float a)
   35|      8|{
   36|      8|	Diffuse[0] = r;
   37|      8|	Diffuse[1] = g;
   38|      8|	Diffuse[2] = b;
   39|      8|	Diffuse[3] = a;
   40|      8|}
   41|       |
   42|       |void Light::SetSpecularValue( float r, float g, float b, float a)
   43|      8|{
   44|      8|	Specular[0] = r;
   45|      8|	Specular[1] = g;
   46|      8|	Specular[2] = b;
   47|      8|	Specular[3] = a;
   48|      8|}
   49|       |
   50|       |void Light::SetAmbientValue(float r, float g, float b, float a)
   51|      8|{
   52|      8|	Ambient[0] = r;
   53|      8|	Ambient[1] = g;
   54|      8|	Ambient[2] = b;
   55|      8|	Ambient[3] = a;
   56|      8|}
   57|       |
   58|       |void Light::SetPosition(float x, float y, float z)
   59|     16|{
   60|     16|	Position[0] = x;
   61|     16|	Position[1] = y;
   62|     16|	Position[2] = z;
   63|     16|}
   64|       |
   65|       |void Light::SetDirection(float x, float y, float z)
   66|      8|{
   67|      8|	float fInvLength = 1.f / sqrt(x*x + y*y + z*z);
   68|      8|	Direction[0] = x * fInvLength;
   69|      8|	Direction[1] = y * fInvLength;
   70|      8|	Direction[2] = z * fInvLength;
   71|      8|}
   72|       |
   73|       |void Light::SetRange(float fValue)
   74|      8|{
   75|      8|	Range = fValue;
   76|      8|}
   77|       |
   78|       |void Light::SetFalloff(float fValue)
   79|      0|{
   80|      0|	Falloff = fValue;
   81|      0|}
   82|       |
   83|       |void Light::SetConstantAttenuation(float fValue)
   84|      8|{
   85|      8|	Attenuation0 = fValue;
   86|      8|}
   87|       |
   88|       |void Light::SetLinearAttenuation(float fValue)
   89|      8|{
   90|      8|	Attenuation1 = fValue;
   91|      8|}
   92|       |
   93|       |void Light::SetQuadraticAttenuation(float fValue)
   94|      8|{
   95|      8|	Attenuation2 = fValue;
   96|      8|}
   97|       |
   98|       |void Light::SetInnerAngle(float fValue)
   99|      0|{
  100|      0|	Theta = fValue;
  101|      0|}
  102|       |
  103|       |void Light::SetOuterAngle(float fValue)
  104|      0|{
  105|      0|	Phi = fValue;
  106|      0|}
  107|       |
  108|       |void Light::SetEnable (bool status)
  109|      0|{
  110|      0|	bEnable = status;
  111|      0|}
  112|       |
  113|       |bool Light::GetEnable (void)
  114|      0|{
  115|      0|	return bEnable;
  116|      0|}
  117|       |
  118|       |void Light::SetDisplay (bool status)
  119|      0|{
  120|      0|	bDisplay = status;
  121|      0|}
  122|       |
  123|       |bool Light::GetDisplay (void)
  124|      0|{
  125|      0|	return bDisplay;
  126|      0|}
  127|       |
  128|       |void Light::Dump(void)
  129|      0|{
  130|      0|	switch (Type)
  131|      0|	{
  132|      0|	case 0:// POINT
  133|      0|		printf ("light point\n");
  134|      0|		break;
  135|      0|	case 1://SPOT:
  136|      0|		printf ("light spot\n");
  137|      0|		break;
  138|      0|	case 2://DIRECTIONAL:
  139|      0|		printf ("light directional\n");
  140|      0|		break;
  141|      0|	default:
  142|      0|		printf ("unknown type of light\n");
  143|      0|		break;
  144|      0|	}
  145|      0|	printf (" ambient : %f %f %f %f\n", Ambient[0], Ambient[1], Ambient[2], Ambient[3]);
  146|      0|	printf (" diffuse : %f %f  %f %f\n", Diffuse[0], Diffuse[1], Diffuse[2], Diffuse[3]);
  147|      0|	printf (" specular : %f %f %f %f\n", Specular[0], Specular[1], Specular[2], Specular[3]);
  148|      0|	printf (" position : %f %f %f\n", Position[0], Position[1], Position[2]);
  149|      0|}

/workspaces/cg/src/cgmesh/lights_manager.h:
    1|       |#ifndef __LIGHTS_MANAGER_H__
    2|       |#define __LIGHTS_MANAGER_H__
    3|       |
    4|       |#include "light.h"
    5|       |
    6|       |class LightsManager
    7|       |{
    8|       |private:
    9|       |	LightsManager();
   10|       |	~LightsManager ();
   11|       |
   12|       |public:
   13|      0|	static LightsManager* getInstance (void) { return m_pInstance; };
   14|       |
   15|       |	void Initialize (void);
   16|       |
   17|       |	int		AddLight		(Light* light);
   18|       |	
   19|       |	void	EnableLight		(unsigned int id, bool bFlag);
   20|       |
   21|       |	Light*	GetLight (unsigned int id);
   22|       |
   23|       |	void	dump (void);
   24|       |
   25|       |public:
   26|       |	static LightsManager *m_pInstance;
   27|       |
   28|       |	int m_nLights;
   29|       |	Light* m_pLights[8];
   30|       |};
   31|       |
   32|       |#endif // __LIGHTS_MANAGER_H__

/workspaces/cg/src/cgmesh/material.cpp:
    1|       |#include "material.h"
    2|       |
    3|       |//
    4|       |// Material Color
    5|       |//
    6|       |MaterialColor::MaterialColor ()
    7|      0|{
    8|      0|}
    9|       |
   10|       |MaterialColor::MaterialColor (unsigned char r, unsigned char g, unsigned char b, unsigned char a)
   11|      0|{
   12|      0|	m_r = r;
   13|      0|	m_g = g;
   14|      0|	m_b = b;
   15|      0|	m_a = a;
   16|      0|}
   17|       |
   18|       |MaterialColor::MaterialColor (const MaterialColor &m)
   19|      0|{
   20|      0|	m_r = m.m_r;
   21|      0|	m_g = m.m_g;
   22|      0|	m_b = m.m_b;
   23|      0|	m_a = m.m_a;
   24|      0|}
   25|       |
   26|       |MaterialType MaterialColor::GetType (void)
   27|      0|{
   28|      0|	return MATERIAL_COLOR;
   29|      0|}
   30|       |
   31|       |void MaterialColor::Dump (void)
   32|      0|{
   33|      0|	printf ("MATERIAL_COLOR : %d %d %d %d\n", m_r, m_g, m_b, m_a);
   34|      0|}
   35|       |
   36|       |//
   37|       |// Material Color Extended
   38|       |//
   39|       |static float _material_extended_parameters[] = 
   40|       |{   // Ambient Diffuse Specular Shininess
   41|       |	0.0215, 0.1745, 0.0215, 0.07568, 0.61424, 0.07568, 0.633, 0.727811, 0.633, 0.6, // emerald
   42|       |	0.135, 0.2225, 0.1575, 0.54, 0.89, 0.63, 0.316228, 0.316228, 0.316228, 0.1, // jade
   43|       |	0.05375, 0.05, 0.06625, 0.18275, 0.17, 0.22525, 0.332741, 0.328634, 0.346435, 0.3, // obsidian
   44|       |	0.25, 0.20725, 0.20725, 1, 0.829, 0.829, 0.296648, 0.296648, 0.296648, 0.088, // pearl
   45|       |	0.1745, 0.01175, 0.01175, 0.61424, 0.04136, 0.04136, 0.727811, 0.626959, 0.626959, 0.6, // ruby
   46|       |	0.1, 0.18725, 0.1745, 0.396, 0.74151, 0.69102, 0.297254, 0.30829, 0.306678, 0.1,  // turquoise
   47|       |	0.329412, 0.223529, 0.027451, 0.780392, 0.568627, 0.113725, 0.992157, 0.941176, 0.807843, 0.21794872,  // brass
   48|       |	0.2125, 0.1275, 0.054, 0.714, 0.4284, 0.18144, 0.393548, 0.271906, 0.166721, 0.2,  // bronze
   49|       |	0.25, 0.25, 0.25, 0.4, 0.4, 0.4, 0.774597, 0.774597, 0.774597, 0.6,  // chrome
   50|       |	0.19125, 0.0735, 0.0225, 0.7038, 0.27048, 0.0828, 0.256777, 0.137622, 0.086014, 0.1,  // copper
   51|       |	0.24725, 0.1995, 0.0745, 0.75164, 0.60648, 0.22648, 0.628281, 0.555802, 0.366065, 0.4,  // gold
   52|       |	0.19225, 0.19225, 0.19225, 0.50754, 0.50754, 0.50754, 0.508273, 0.508273, 0.508273, 0.4,  // silver
   53|       |	0.0, 0.0, 0.0, 0.01, 0.01, 0.01, 0.50, 0.50, 0.50, .25,  // black, plastic
   54|       |	0.0, 0.1, 0.06, 0.0, 0.50980392, 0.50980392, 0.50196078, 0.50196078, 0.50196078, .25,  // cyan, plastic
   55|       |	0.0, 0.0, 0.0, 0.1, 0.35, 0.1, 0.45, 0.55, 0.45, .25,  // green plastic
   56|       |	0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.7, 0.6, 0.6, .25,  // red plastic
   57|       |	0.0, 0.0, 0.0, 0.55, 0.55, 0.55, 0.70, 0.70, 0.70, .25,  // white, plastic
   58|       |	0.0, 0.0, 0.0, 0.5, 0.5, 0.0, 0.60, 0.60, 0.50, .25,  // yellow, plastic
   59|       |	0.02, 0.02, 0.02, 0.01, 0.01, 0.01, 0.4, 0.4, 0.4, .078125,  // black, rubber
   60|       |	0.0, 0.05, 0.05, 0.4, 0.5, 0.5, 0.04, 0.7, 0.7, .078125,  // cyan, rubber
   61|       |	0.0, 0.05, 0.0, 0.4, 0.5, 0.4, 0.04, 0.7, 0.04, .078125,  // green, rubber
   62|       |	0.05, 0.0, 0.0, 0.5, 0.4, 0.4, 0.7, 0.04, 0.04, .078125,  // red, rubber
   63|       |	0.05, 0.05, 0.05, 0.5, 0.5, 0.5, 0.7, 0.7, 0.7, .078125,  // white, rubber,
   64|       |	0.05, 0.05, 0.0, 0.5, 0.5, 0.4, 0.7, 0.7, 0.04, .078125 // yellow, rubber
   65|       |};
   66|       |
   67|       |void MaterialColorExt::Init_From_Library (MaterialColorExtType index)
   68|      1|{
   69|      1|	SetAmbient (_material_extended_parameters[10*index], _material_extended_parameters[10*index+1], _material_extended_parameters[10*index+2], 1.);
   70|      1|	SetDiffuse (_material_extended_parameters[10*index+3], _material_extended_parameters[10*index+4], _material_extended_parameters[10*index+5], 1.);
   71|      1|	SetSpecular (_material_extended_parameters[10*index+6], _material_extended_parameters[10*index+7], _material_extended_parameters[10*index+8], 1.);
   72|      1|	SetShininess (_material_extended_parameters[10*index+9]);
   73|      1|	SetEmission (0., 0., 0., 1.);
   74|      1|}
   75|       |
   76|       |
   77|       |
   78|       |//
   79|       |// Texture
   80|       |//
   81|       |MaterialTexture::MaterialTexture (char const *filename, char const *path)
   82|      0|{
   83|      0|	m_pFilename = strdup (filename);
   84|       |	/*
   85|       |	m_pImage = new Img ();
   86|       |	m_pImage->load (m_pFilename, path);
   87|       |	*/
   88|       |	
   89|      0|}
   90|       |
   91|       |MaterialTexture::MaterialTexture (unsigned int nWidth, unsigned int nHeight)
   92|      0|{
   93|      0|}
   94|       |
   95|       |MaterialTexture::MaterialTexture (const MaterialTexture &m) // constructor of copy
   96|      0|{
   97|      0|}
   98|       |
   99|       |MaterialTexture::~MaterialTexture ()
  100|      0|{
  101|      0|}
  102|       |
  103|       |MaterialType MaterialTexture::GetType (void)
  104|      0|{
  105|      0|	return MATERIAL_TEXTURE;
  106|      0|}
  107|       |
  108|       |void MaterialTexture::Dump (void)
  109|      0|{
  110|      0|	printf ("MATERIAL_TEXTURE : %s\n", m_pFilename);
  111|      0|}
  112|       |
  113|       |char* MaterialTexture::GetFilename ()
  114|      0|{
  115|      0|	return m_pFilename;
  116|      0|}
  117|       |
  118|       |Img* MaterialTexture::GetImage ()
  119|      0|{
  120|      0|	return m_pImage;
  121|      0|}
  122|       |

/workspaces/cg/src/cgmesh/material.h:
    1|       |#pragma once
    2|       |
    3|       |#include "../cgimg/cgimg.h"
    4|       |
    5|       |// material definition
    6|       |enum MaterialType {
    7|       |	MATERIAL_NONE = ((unsigned int)-1),
    8|       |	MATERIAL_COLOR = 0,
    9|       |	MATERIAL_COLOR_ADV = 1,
   10|       |	MATERIAL_TEXTURE = 2
   11|       |};
   12|       |
   13|       |//
   14|       |//
   15|       |//
   16|       |class Material
   17|       |{
   18|       |public:
   19|  10.0k|	Material () { m_pName = NULL; };
   20|      0|	Material (const Material &m) {}; // constructor of copy
   21|       |	//virtual ~Material ();
   22|       |
   23|      0|	virtual MaterialType GetType (void) { return MATERIAL_NONE; };
   24|      0|	virtual void Dump (void) {};
   25|       |	
   26|      0|	void SetName (char const *name) { m_pName = strdup (name); };
   27|      0|	char *GetName (void) { return m_pName; };
   28|       |
   29|       |protected:
   30|       |	char *m_pName;
   31|       |};
   32|       |
   33|       |//
   34|       |//
   35|       |//
   36|       |class MaterialColor : public Material
   37|       |{
   38|       |	friend class Mesh;
   39|       |public:
   40|       |	MaterialColor ();
   41|       |	MaterialColor (unsigned char r, unsigned char g, unsigned char b, unsigned char a=255);
   42|       |	MaterialColor (const MaterialColor &m); // constructor of copy
   43|       |
   44|       |	//virtual ~MaterialColor () {};
   45|       |	MaterialType GetType (void);
   46|       |
   47|      0|	float GetFloatRed() const { return m_r / 255.f; };
   48|      0|	float GetFloatGreen() const { return m_g / 255.f; };
   49|      0|	float GetFloatBlue() const { return m_b / 255.f; };
   50|      0|	float GetFloatAlpha() const { return m_a / 255.f; };
   51|       |
   52|       |	void Dump (void);
   53|       |private:
   54|       |	unsigned char m_r, m_g, m_b, m_a;
   55|       |};
   56|       |
   57|       |//
   58|       |// Material color extended
   59|       |//
   60|       |class MaterialColorExt : public Material
   61|       |{
   62|       |	friend class Mesh;
   63|       |
   64|       |public:
   65|       |	// material color extended library
   66|       |	enum MaterialColorExtType {
   67|       |		EMERALD = 0,
   68|       |		JADE,
   69|       |		OBSIDIAN,
   70|       |		PEARL,
   71|       |		RUBY,
   72|       |		TURQUOISE,
   73|       |		BRASS,
   74|       |		BRONZE,
   75|       |		CHROME,
   76|       |		COPPER,
   77|       |		GOLD,
   78|       |		SILVER,
   79|       |		BLACK_PLASTIC,
   80|       |		CYAN_PLASTIC,
   81|       |		GREEN_PLASTIC,
   82|       |		RED_PLASTIC,
   83|       |		WHITE_PLASTIC,
   84|       |		YELLOW_PLASTIC,
   85|       |		BLACK_RUBBER,
   86|       |		CYAN_RUBBER,
   87|       |		GREEN_RUBBER,
   88|       |		RED_RUBBER,
   89|       |		WHITE_RUBBER,
   90|       |		YELLOW_RUBBER
   91|       |	};
   92|       |
   93|       |	MaterialColorExt ()
   94|  10.0k|		{
   95|  10.0k|			{
   96|  50.1k|				for (int i=0; i<4; i++)
   97|  40.1k|				{
   98|  40.1k|					m_fAmbient[i] = 0.;
   99|  40.1k|					m_fDiffuse[i] = 0.;
  100|  40.1k|					m_fSpecular[i] = 0.;
  101|  40.1k|					m_fEmission[i] = 0.;
  102|  40.1k|				}
  103|  10.0k|				m_fShininess[0] = 0.;
  104|  10.0k|			}
  105|  10.0k|		};
  106|       |	MaterialColorExt (const MaterialColorExt &m) // constructor of copy
  107|      0|		{
  108|      0|			memcpy (m_fAmbient, m.m_fAmbient, 4*sizeof(float));
  109|      0|			memcpy (m_fDiffuse, m.m_fDiffuse, 4*sizeof(float));
  110|      0|			memcpy (m_fSpecular, m.m_fSpecular, 4*sizeof(float));
  111|      0|			memcpy (m_fEmission, m.m_fEmission, 4*sizeof(float));
  112|      0|			memcpy (m_fShininess, m.m_fShininess, 1*sizeof(float));
  113|      0|		};
  114|       |	//virtual ~MaterialColorExt () {};
  115|       |
  116|       |	inline void SetAmbient (float fR, float fG, float fB, float fA)
  117|  10.0k|	{
  118|  10.0k|		m_fAmbient[0] = fR;
  119|  10.0k|		m_fAmbient[1] = fG;
  120|  10.0k|		m_fAmbient[2] = fB;
  121|  10.0k|		m_fAmbient[3] = fA;
  122|  10.0k|	};
  123|       |	inline void SetDiffuse (float fR, float fG, float fB, float fA)
  124|  10.0k|	{
  125|  10.0k|		m_fDiffuse[0] = fR;
  126|  10.0k|		m_fDiffuse[1] = fG;
  127|  10.0k|		m_fDiffuse[2] = fB;
  128|  10.0k|		m_fDiffuse[3] = fA;
  129|  10.0k|	};
  130|       |	inline void GetDiffuse (float diffuse[4])
  131|      0|	{
  132|      0|		memcpy (diffuse, m_fDiffuse, 4*sizeof(float));
  133|      0|	};
  134|       |	inline void SetSpecular (float fR, float fG, float fB, float fA)
  135|  10.0k|	{
  136|  10.0k|		m_fSpecular[0] = fR;
  137|  10.0k|		m_fSpecular[1] = fG;
  138|  10.0k|		m_fSpecular[2] = fB;
  139|  10.0k|		m_fSpecular[3] = fA;
  140|  10.0k|	};
  141|       |	inline void SetEmission (float fR, float fG, float fB, float fA)
  142|      1|	{
  143|      1|		m_fEmission[0] = fR;
  144|      1|		m_fEmission[1] = fG;
  145|      1|		m_fEmission[2] = fB;
  146|      1|		m_fEmission[3] = fA;
  147|      1|	};
  148|       |	inline void SetShininess (float fPower)
  149|      1|	{
  150|      1|		m_fShininess[0] = fPower;
  151|      1|	};
  152|       |	void Init_From_Library (MaterialColorExtType eType);
  153|       |
  154|      0|	inline MaterialType GetType () { return MATERIAL_COLOR_ADV; };
  155|      0|	void Dump () {
  156|      0|		printf ("MATERIAL_COLOR_ADV :\n");
  157|      0|		printf ("   ambient : %f %f %f %f\n", m_fAmbient[0], m_fAmbient[1], m_fAmbient[2], m_fAmbient[3]);
  158|      0|		printf ("   diffuse : %f %f %f %f\n", m_fDiffuse[0], m_fDiffuse[1], m_fDiffuse[2], m_fDiffuse[3]);
  159|      0|		printf ("   specular : %f %f %f %f\n", m_fSpecular[0], m_fSpecular[1], m_fSpecular[2], m_fSpecular[3]);
  160|      0|		printf ("   emission : %f %f %f %f\n", m_fEmission[0], m_fEmission[1], m_fEmission[2], m_fEmission[3]);
  161|      0|		printf ("   shininess : %f\n", m_fShininess[0]);
  162|      0|	};
  163|       |public:
  164|       |	float m_fAmbient[4];
  165|       |	float m_fDiffuse[4];
  166|       |	float m_fSpecular[4];
  167|       |	float m_fEmission[4];
  168|       |	float m_fShininess[1];
  169|       |};
  170|       |
  171|       |
  172|       |//
  173|       |//
  174|       |//
  175|       |class MaterialTexture : public Material
  176|       |{
  177|       |public:
  178|       |	MaterialTexture (char const *filename, char const *path = NULL);
  179|       |	MaterialTexture (unsigned int nWidth, unsigned int nHeight);
  180|       |	MaterialTexture (const MaterialTexture &m); // constructor of copy
  181|       |	virtual ~MaterialTexture ();
  182|       |
  183|       |	MaterialType GetType (void);
  184|       |	void Dump (void);
  185|       |	char* GetFilename ();
  186|       |	Img* GetImage ();
  187|       |private:
  188|       |	char *m_pFilename;
  189|       |	Img *m_pImage;
  190|       |	unsigned int m_nWidth, m_nHeight;
  191|       |	unsigned char *m_pPixels;
  192|       |};

/workspaces/cg/src/cgmesh/mesh.cpp:
    1|       |#include <stdlib.h>
    2|       |#include <stdio.h>
    3|       |#include <string.h>
    4|       |#include <map>
    5|       |#include <algorithm>
    6|       |
    7|       |#include "mesh.h"
    8|       |#include "../cgmath/cgmath.h"
    9|       |#include "../cgimg/cgimg.h"
   10|       |#include "octree.h"
   11|       |
   12|       |//
   13|       |// Face
   14|       |//
   15|       |void Face::Init (void)
   16|  7.30k|{
   17|  7.30k|	m_nVertices = 0;
   18|  7.30k|	m_pVertices = nullptr;
   19|  7.30k|	m_bUseTextureCoordinates = false;
   20|  7.30k|	m_pTextureCoordinatesIndices = nullptr;
   21|  7.30k|	m_pTextureCoordinates = nullptr;
   22|  7.30k|	m_iMaterialId = MATERIAL_NONE;
   23|  7.30k|};
   24|       |
   25|       |Face::Face ()
   26|  7.30k|{
   27|  7.30k|	Init ();
   28|  7.30k|	SetNVertices (3);
   29|  7.30k|}
   30|       |
   31|       |Face::Face (const Face &f)
   32|      0|{
   33|      0|	Init ();
   34|      0|	SetNVertices(f.m_nVertices);
   35|       |
   36|      0|	m_nVertices = f.m_nVertices;
   37|      0|	memcpy (m_pVertices, f.m_pVertices, f.m_nVertices*sizeof(unsigned int));
   38|       |
   39|      0|	m_bUseTextureCoordinates = f.m_bUseTextureCoordinates;
   40|      0|	if (m_bUseTextureCoordinates)
   41|      0|	{
   42|      0|		m_pTextureCoordinatesIndices = new unsigned int[2*f.m_nVertices];
   43|      0|		memcpy (m_pTextureCoordinatesIndices, f.m_pTextureCoordinatesIndices, 2*m_nVertices*sizeof(float));
   44|       |
   45|      0|		m_pTextureCoordinates = new float[2*m_nVertices];
   46|      0|		memcpy (m_pTextureCoordinates, f.m_pTextureCoordinates, 2*m_nVertices*sizeof(float));
   47|      0|	}
   48|      0|	else
   49|      0|		m_pTextureCoordinates = NULL;
   50|       |
   51|      0|	m_iMaterialId = f.m_iMaterialId;
   52|      0|}
   53|       |
   54|       |Face::~Face ()
   55|      0|{
   56|      0|	if (m_pVertices)
   57|      0|		delete m_pVertices;
   58|      0|	if (m_pTextureCoordinatesIndices)
   59|      0|		delete m_pTextureCoordinatesIndices;
   60|      0|	if (m_pTextureCoordinates)
   61|      0|		delete m_pTextureCoordinates;
   62|      0|};
   63|       |
   64|       |int Face::SetNVertices (unsigned int n)
   65|  12.1k|{
   66|  12.1k|	if (m_nVertices == n)
   67|  4.84k|		return 0;
   68|       |
   69|  7.30k|	m_nVertices = n;
   70|  7.30k|	if (m_pVertices)
   71|      0|		delete m_pVertices;
   72|  7.30k|	m_pVertices = new unsigned int[m_nVertices];
   73|       |
   74|  7.30k|	if (m_pTextureCoordinatesIndices)
   75|      0|		delete m_pTextureCoordinatesIndices;
   76|  7.30k|	m_pTextureCoordinatesIndices = new unsigned int[2*m_nVertices];
   77|       |
   78|  7.30k|	if (m_pTextureCoordinates)
   79|      0|		delete m_pTextureCoordinates;
   80|  7.30k|	m_pTextureCoordinates = new float[2*m_nVertices];
   81|       |
   82|  7.30k|	return 0;
   83|  12.1k|}
   84|       |
   85|       |void Face::SetTriangle (unsigned int a, unsigned int b, unsigned int c)
   86|  2.45k|{
   87|  2.45k|	SetNVertices (3);
   88|  2.45k|	m_pVertices[0] = a;
   89|  2.45k|	m_pVertices[1] = b;
   90|  2.45k|	m_pVertices[2] = c;
   91|  2.45k|}
   92|       |
   93|       |void Face::SetQuad (unsigned int a, unsigned int b, unsigned int c, unsigned int d)
   94|      0|{
   95|      0|	SetNVertices (4);
   96|      0|	m_pVertices[0] = a;
   97|      0|	m_pVertices[1] = b;
   98|      0|	m_pVertices[2] = c;
   99|      0|	m_pVertices[3] = d;
  100|      0|}
  101|       |
  102|       |void Face::dump (void)
  103|      0|{
  104|      0|	printf ("%d vertices stored in %xd : ", m_nVertices, m_pVertices);
  105|      0|	for (unsigned int i=0; i<m_nVertices; i++)
  106|      0|		printf ("%d ", m_pVertices[i]);
  107|      0|	printf ("\n");
  108|      0|}
  109|       |
  110|       |//
  111|       |// Mesh
  112|       |//
  113|       |void Mesh::Init ()
  114|     14|{
  115|     14|	m_name = std::string("#NoName#");
  116|     14|	m_nVertices = 0;
  117|     14|	m_nFaces = 0;
  118|     14|	m_pVertices = NULL;
  119|     14|	m_pVertexNormals = NULL;
  120|     14|	m_pVertexColors = NULL;
  121|     14|	m_pFaces = NULL;
  122|     14|	m_pFaceNormals = NULL;
  123|     14|	m_nMaterials = 0;
  124|     14|	m_pMaterials = NULL;
  125|     14|	m_nTextureCoordinates = 0;
  126|     14|	m_pTextureCoordinates = NULL;
  127|     14|	m_pTensors = NULL;
  128|     14|	m_pOctree = NULL;
  129|     14|}
  130|       |
  131|       |void Mesh::InitVertexColors (float r, float g, float b)
  132|      0|{
  133|      0|	if (m_pVertexColors)
  134|      0|		delete m_pVertexColors;
  135|      0|	m_pVertexColors = NULL;
  136|       |
  137|      0|	if (m_nVertices > 0)
  138|      0|	{
  139|      0|		m_pVertexColors = new float[3*m_nVertices];
  140|      0|		for (int i=0; i<m_nVertices; i++)
  141|      0|		{
  142|      0|			m_pVertexColors[3*i]   = r;
  143|      0|			m_pVertexColors[3*i+1] = g;
  144|      0|			m_pVertexColors[3*i+2] = b;
  145|      0|		}
  146|       |		//memset (m_pVertexColors, 0, 3*m_nVertices*sizeof(float));
  147|      0|	}
  148|      0|}
  149|       |
  150|       |void Mesh::InitVertexColorsFromCurvatures (Tensor::eCurvature curvature)
  151|      0|{
  152|      0|	if (!m_pTensors)
  153|      0|		return;
  154|       |
  155|      0|	if (m_nVertices > 0)
  156|      0|	{
  157|      0|		float *array = (float*)malloc(m_nVertices*sizeof(float));
  158|      0|		char *defined = (char*)malloc(m_nVertices*sizeof(char));
  159|      0|		for (int i=0; i<m_nVertices; i++)
  160|      0|		{
  161|      0|			if (m_pTensors[i])
  162|      0|			{
  163|      0|				defined[i] = 1;
  164|      0|				float kappa1 = m_pTensors[i]->GetKappaMax ();
  165|      0|				float kappa2 = m_pTensors[i]->GetKappaMin ();
  166|      0|				switch (curvature)
  167|      0|				{
  168|      0|				case Tensor::CURVATURE_MAX:
  169|      0|					array[i] = kappa1;
  170|      0|					break;
  171|      0|				case Tensor::CURVATURE_MIN:
  172|      0|					array[i] = kappa2;
  173|      0|					break;
  174|      0|				case Tensor::CURVATURE_GAUSSIAN:
  175|      0|					array[i] = kappa1*kappa2;
  176|      0|					break;
  177|      0|				case Tensor::CURVATURE_MEAN:
  178|      0|					array[i] = (kappa1+kappa2)/2.0;
  179|      0|					break;
  180|      0|				default:
  181|      0|					printf ("type unknown\n");
  182|      0|					break;
  183|      0|				}
  184|      0|			}
  185|      0|			else
  186|      0|				defined[i] = 0;
  187|      0|		}
  188|       |
  189|      0|		InitVertexColorsFromArray (array, defined);
  190|       |
  191|      0|		free (defined);
  192|      0|		free (array);
  193|      0|	}
  194|      0|}
  195|       |
  196|       |void Mesh::InitVertexColorsFromArray (float *array, char *defined)
  197|      0|{
  198|      0|	if (!array)
  199|      0|		return;
  200|       |
  201|      0|	if (m_pVertexColors)
  202|      0|		delete m_pVertexColors;
  203|      0|	m_pVertexColors = NULL;
  204|       |
  205|      0|	if (m_nVertices > 0)
  206|      0|	{
  207|      0|		m_pVertexColors = new float[3*m_nVertices];
  208|       |
  209|      0|		float min = array[0];
  210|      0|		float max = array[0];
  211|      0|		for (int i=1; i<m_nVertices; i++)
  212|      0|		{
  213|      0|			if (defined && !defined[i])
  214|      0|				continue;
  215|       |
  216|      0|			if (min > array[i]) min = array[i];
  217|      0|			if (max < array[i]) max = array[i];
  218|      0|		}
  219|       |		/*if (fabs(min) > fabs(max))
  220|       |		{
  221|       |			min = -fabs(min);
  222|       |			max =  fabs(min);
  223|       |		}
  224|       |		else
  225|       |		{
  226|       |			min =  fabs(max);
  227|       |			max = -fabs(max);
  228|       |		}*/
  229|       |
  230|      0|		float r, g, b;
  231|      0|		if (min == max)
  232|      0|		{
  233|       |			//color_jet(0.5, &r, &g, &b);
  234|      0|			InitVertexColors (0., 0., 0.);
  235|      0|		}
  236|      0|		else
  237|      0|		{
  238|      0|			m_nTextureCoordinates = m_nVertices;
  239|      0|			m_pTextureCoordinates = new float[2 * m_nTextureCoordinates];
  240|       |
  241|      0|			float invdenom = 1./(max-min);
  242|      0|			for (int i=0; i<m_nVertices; i++)
  243|      0|			{
  244|      0|				m_pTextureCoordinates[2 * i] = (array[i] - min)*invdenom;
  245|      0|				m_pTextureCoordinates[2 * i + 1] = .5f;
  246|       |
  247|      0|				if (defined && !defined[i])
  248|      0|				{
  249|      0|					m_pVertexColors[3*i]   = 0.;
  250|      0|					m_pVertexColors[3*i+1] = 0.;
  251|      0|					m_pVertexColors[3*i+2] = 0.;
  252|      0|				}
  253|      0|				color_jet((array[i]-min)*invdenom, &m_pVertexColors[3*i], &m_pVertexColors[3*i+1], &m_pVertexColors[3*i+2]);
  254|       |
  255|      0|			}
  256|       |
  257|       |			
  258|      0|			for (int i = 0; i < m_nFaces; i++)
  259|      0|			{
  260|      0|				Face* pFace = m_pFaces[i];
  261|      0|				pFace->ActivateTextureCoordinatesIndices();
  262|      0|				pFace->InitTexCoord();
  263|      0|			}
  264|      0|		}
  265|      0|	}	
  266|      0|}
  267|       |
  268|       |void Mesh::InitVertices (unsigned int nVertices)
  269|      8|{
  270|      8|	m_pVertices = NULL;
  271|      8|	m_pVertexColors = NULL;
  272|      8|	m_pVertexNormals = NULL;
  273|       |
  274|      8|	m_nVertices = nVertices;
  275|      8|	if (m_nVertices)
  276|      8|	{
  277|      8|		m_pVertices = new float[3*nVertices];
  278|      8|		memset (m_pVertices, 0, 3*nVertices*sizeof(float));
  279|       |		
  280|      8|		m_pVertexNormals = new float[3*nVertices];
  281|      8|		memset (m_pVertexNormals, 0, 3*nVertices*sizeof(float));
  282|      8|	}
  283|      8|}
  284|       |
  285|       |void Mesh::InitFaces (unsigned int nFaces)
  286|      8|{
  287|      8|	m_pFaces = NULL;
  288|      8|	m_pFaceNormals = NULL;
  289|       |
  290|      8|	m_nFaces = nFaces;
  291|      8|	if (m_nFaces)
  292|      8|	{
  293|      8|		m_pFaces = new Face*[m_nFaces];
  294|       |		//memset (m_pFaces, 0, nFaces*sizeof(Face*));
  295|  4.85k|		for (int  i=0; i<m_nFaces; i++)
  296|  4.84k|			m_pFaces[i] = new Face ();
  297|      8|		m_pFaceNormals = new float[3*m_nFaces];
  298|      8|		memset (m_pFaceNormals, 0, 3*m_nFaces*sizeof(float));
  299|      8|	}
  300|      8|}
  301|       |
  302|       |void Mesh::InitTensors (void)
  303|      0|{
  304|      0|	m_pTensors = NULL;
  305|      0|	if (m_nVertices)
  306|      0|	{
  307|      0|		m_pTensors = new Tensor*[m_nVertices];
  308|      0|		memset (m_pTensors, 0, m_nVertices*sizeof(Tensor*));
  309|      0|	}
  310|      0|}
  311|       |
  312|       |Tensor* Mesh::GetTensor (unsigned int index)
  313|      0|{
  314|      0|	return m_pTensors[index];
  315|      0|}
  316|       |
  317|       |void Mesh::Init (unsigned int nVertices, unsigned int nFaces)
  318|      8|{
  319|      8|	Init ();
  320|       |
  321|      8|	InitVertices (nVertices);
  322|      8|	InitFaces (nFaces);
  323|       |
  324|      8|	m_nMaterials = 0;
  325|      8|	m_pMaterials = NULL;
  326|      8|}
  327|       |
  328|      6|Mesh::Mesh () : Geometry()
  329|      6|{
  330|      6|	Init ();
  331|      6|}
  332|       |
  333|       |Mesh::Mesh (unsigned int nVertices, unsigned int nFaces)
  334|      2|{
  335|      2|	Init (nVertices, nFaces);
  336|      2|}
  337|       |
  338|       |Mesh::Mesh (Mesh &m)
  339|      0|{
  340|      0|}
  341|       |
  342|       |void Mesh::DeleteFaces (void)
  343|      0|{
  344|      0|	if (m_pFaces)
  345|      0|	{
  346|      0|		for (unsigned int i=0; i<m_nFaces; i++)
  347|      0|		{
  348|      0|			Face *pFace = m_pFaces[i];
  349|      0|			delete pFace;
  350|      0|		}
  351|      0|		delete m_pFaces;
  352|      0|	}
  353|      0|	m_pFaces = NULL;
  354|      0|	m_nFaces = 0;
  355|      0|}
  356|       |
  357|       |Mesh::~Mesh ()
  358|      0|{
  359|      0|	if (m_pVertices)	delete m_pVertices;
  360|      0|	if (m_pVertexNormals)	delete m_pVertexNormals;
  361|      0|	if (m_pVertexColors)	delete m_pVertexColors;
  362|      0|	DeleteFaces ();
  363|      0|	if (m_pMaterials) delete m_pMaterials;
  364|      0|	if (m_pOctree) delete m_pOctree;
  365|      0|}
  366|       |
  367|       |void Mesh::Dump ()
  368|      0|{
  369|      0|	printf ("nVertices : %d\n", m_nVertices);
  370|      0|	printf ("pVertices : 0x%x\n", &m_pVertices);
  371|      0|	printf ("pVertexNormals : 0x%x\n", &m_pVertexNormals);
  372|      0|	printf ("pVertexColors : 0x%x\n", &m_pVertexColors);
  373|      0|	printf ("nFace : %d\n", m_nFaces);
  374|      0|	printf ("pFaces : 0x%x\n", &m_pFaces);
  375|      0|	printf ("pTextureCoordinates : 0x%x\n", &m_pTextureCoordinates);
  376|      0|	printf ("nMaterials : %d\n", m_nMaterials);
  377|      0|	printf ("pMaterials : 0x%x\n", &m_pMaterials);
  378|      0|	for (int i=0; i<m_nMaterials; i++)
  379|      0|		m_pMaterials[i]->Dump();
  380|      0|}
  381|       |
  382|       |unsigned int* Mesh::GetTriangles (void)
  383|      2|{
  384|      2|	unsigned int *pFaces = (unsigned int*)malloc(3*m_nFaces*sizeof(unsigned int));
  385|    664|	for (unsigned int i=0; i<m_nFaces; i++)
  386|    662|	{
  387|    662|		pFaces[3*i]   = m_pFaces[i]->GetVertex(0);
  388|    662|		pFaces[3*i+1] = m_pFaces[i]->GetVertex(1);
  389|    662|		pFaces[3*i+2] = m_pFaces[i]->GetVertex(2);
  390|    662|	}
  391|      2|	return pFaces;
  392|      2|}
  393|       |
  394|       |int Mesh::SetVertices (unsigned int nVertices, float *pVertices)
  395|      0|{
  396|      0|	if (!m_pVertices || (m_pVertices && nVertices != m_nVertices))
  397|      0|	{
  398|      0|		delete m_pVertices;
  399|      0|		m_pVertices = new float[3*nVertices];
  400|      0|	}
  401|      0|	m_nVertices = nVertices;
  402|      0|	memcpy (m_pVertices, pVertices, 3*nVertices*sizeof(float));
  403|       |
  404|      0|	return 0;
  405|      0|}
  406|       |
  407|       |int Mesh::SetFaces (unsigned int nFaces, unsigned int nVerticesPerFace, unsigned int *pFaces, unsigned int *pTextureCoordinates)
  408|      0|{
  409|      0|	if (m_pFaces) delete m_pFaces;
  410|      0|	m_pFaces = new Face*[nFaces];
  411|      0|	m_nFaces = nFaces;
  412|      0|	for (unsigned int i=0; i<nFaces; i++)
  413|      0|	{
  414|      0|		Face *pFace = new Face ();
  415|      0|		pFace->SetNVertices (nVerticesPerFace);
  416|      0|		for (unsigned int j=0; j<nVerticesPerFace; j++)
  417|      0|			pFace->m_pVertices[j] = pFaces[nVerticesPerFace*i+j];
  418|       |
  419|      0|		m_pFaces[i] = pFace;
  420|      0|	}
  421|      0|	return 1;
  422|      0|}
  423|       |
  424|       |int Mesh::SetVertex (unsigned int i, float x, float y, float z)
  425|    121|{
  426|    121|	if (!m_pVertices || i>=m_nVertices)
  427|      0|		return -1;
  428|       |	
  429|    121|	m_pVertices[3*i+0] = x;
  430|    121|	m_pVertices[3*i+1] = y;
  431|    121|	m_pVertices[3*i+2] = z;
  432|       |
  433|    121|	return 0;
  434|    121|}
  435|       |
  436|       |int Mesh::SetFace (unsigned int i,
  437|       |		   unsigned int a, unsigned int b, unsigned int c)
  438|      0|{
  439|      0|	if (m_pFaces[i])
  440|      0|		delete m_pFaces[i];
  441|      0|	m_pFaces[i] = new Face ();
  442|      0|	m_pFaces[i]->SetNVertices (3);
  443|      0|	m_pFaces[i]->m_pVertices[0] = a;
  444|      0|	m_pFaces[i]->m_pVertices[1] = b;
  445|      0|	m_pFaces[i]->m_pVertices[2] = c;
  446|       |
  447|      0|	return 0;
  448|      0|}
  449|       |
  450|       |int Mesh::SetFace (unsigned int i,
  451|       |		   unsigned int a, unsigned int b, unsigned int c, unsigned int d)
  452|      0|{
  453|      0|	if (m_pFaces[i])
  454|      0|		delete m_pFaces[i];
  455|      0|	m_pFaces[i] = new Face ();
  456|      0|	m_pFaces[i]->SetQuad (a, b, c, d);
  457|      0|	return 0;
  458|      0|}
  459|       |
  460|       |
  461|       |int Mesh::computebbox (void)
  462|      1|{
  463|       |	/*
  464|       |	for (int i = 0; i < m_nFaces; i++)
  465|       |	{
  466|       |		auto pFace = m_pFaces[i];
  467|       |		for (int j = 0; j < pFace->GetNVertices(); j++)
  468|       |		{
  469|       |			int vindex = pFace->GetVertex(j);
  470|       |			m_bbox.AddPoint(m_pVertices[3 * vindex], m_pVertices[3 * vindex + 1], m_pVertices[3 * vindex + 2]);
  471|       |		}
  472|       |	}
  473|       |	*/
  474|       |
  475|  1.98k|	for (int i = 0; i < m_nVertices; i++)
  476|  1.98k|		m_bbox.AddPoint(m_pVertices[3 * i], m_pVertices[3 * i + 1], m_pVertices[3 * i + 2]);
  477|       |	
  478|      1|	return 0;
  479|      1|}
  480|       |
  481|       |const BoundingBox& Mesh::bbox() const
  482|      0|{
  483|      0|	return m_bbox;
  484|      0|}
  485|       |
  486|       |float Mesh::bbox_diagonal_length(void) const
  487|      0|{
  488|      0|	return m_bbox.GetDiagonalLength();
  489|      0|}
  490|       |
  491|       |float Mesh::GetLargestLength(void) const
  492|      0|{
  493|      0|	return m_bbox.GetLargestLength();
  494|      0|}
  495|       |
  496|       |//
  497|       |// area
  498|       |//
  499|       |float Mesh::GetFaceArea (unsigned int fi)
  500|      0|{
  501|      0|	unsigned int vi1 = 3*m_pFaces[fi]->m_pVertices[0];
  502|      0|	unsigned int vi2 = 3*m_pFaces[fi]->m_pVertices[1];
  503|      0|	unsigned int vi3 = 3*m_pFaces[fi]->m_pVertices[2];
  504|      0|	vec3 v1, v2, v3;
  505|       |
  506|      0|	vec3_init (v1, m_pVertices[vi1], m_pVertices[vi1+1], m_pVertices[vi1+2]);
  507|      0|	vec3_init (v2, m_pVertices[vi2], m_pVertices[vi2+1], m_pVertices[vi2+2]);
  508|      0|	vec3_init (v3, m_pVertices[vi3], m_pVertices[vi3+1], m_pVertices[vi3+2]);
  509|       |	
  510|      0|	return vec3_triangle_area (v1, v2, v3);
  511|      0|}
  512|       |
  513|       |float Mesh::GetArea (void)
  514|      0|{
  515|      0|	float area = 0.;
  516|      0|	for (unsigned int i=0; i<m_nFaces; i++)
  517|      0|		area += GetFaceArea(i);
  518|      0|	return area;
  519|      0|}
  520|       |
  521|       |float* Mesh::GetAreas (void)
  522|      0|{
  523|      0|	float *areas = (float*)malloc(m_nFaces*sizeof(float));
  524|      0|	for (unsigned int i=0; i<m_nFaces; i++)
  525|      0|		areas[i] = GetFaceArea(i);
  526|      0|	return areas;
  527|      0|}
  528|       |
  529|       |float* Mesh::GetCumulativeAreas (void)
  530|      0|{
  531|      0|	float *areas = GetAreas ();
  532|      0|	for (unsigned int i=1; i<m_nFaces; i++)
  533|      0|		areas[i] += areas[i-1];
  534|      0|	return areas;
  535|      0|}
  536|       |
  537|       |int Mesh::stats_vertices_in_faces (int *verticesinfaces, int n)
  538|      0|{	
  539|      0|	memset (verticesinfaces, 0, n*sizeof(int));
  540|      0|	for (int i=0; i<m_nFaces; i++)
  541|      0|	{
  542|      0|		Face *f = m_pFaces[i];
  543|      0|		if (f == NULL)
  544|      0|			continue;
  545|      0|		if (f->GetNVertices() >= n)
  546|      0|			(verticesinfaces[n-1])++;
  547|      0|		else
  548|      0|			(verticesinfaces[f->GetNVertices()])++;
  549|      0|	}
  550|       |
  551|      0|	return 0;
  552|      0|}
  553|       |
  554|       |unsigned int Mesh::GetNVertices() const
  555|      3|{
  556|      3|	return m_nVertices;
  557|      3|}
  558|       |
  559|       |unsigned int Mesh::GetNFaces() const
  560|      3|{
  561|      3|	return m_nFaces;
  562|      3|}
  563|       |
  564|       |bool Mesh::IsTriangleMesh() const
  565|      0|{
  566|      0|	for (int i = 0; i < m_nFaces; i++)
  567|      0|	{
  568|      0|		Face* pFace = m_pFaces[i];
  569|      0|		if (pFace->GetNVertices() != 3)
  570|      0|			return false;
  571|      0|	}
  572|      0|	return true;
  573|      0|}
  574|       |
  575|       |//
  576|       |//
  577|       |//
  578|       |void Mesh::ComputeNormals (void)
  579|      0|{
  580|      0|	if (!m_pVertexNormals)
  581|      0|		m_pVertexNormals = new float[3*m_nVertices];
  582|      0|	memset (m_pVertexNormals, 0, 3*m_nVertices*sizeof(float));
  583|       |
  584|       |	//
  585|      0|	if (!m_pFaceNormals)
  586|      0|		m_pFaceNormals = new float[3*m_nFaces];
  587|      0|	memset (m_pFaceNormals, 0, 3*m_nFaces*sizeof(float));
  588|       |	
  589|       |
  590|       |	//
  591|      0|	int *nfaces = new int[m_nVertices];
  592|      0|	memset (nfaces, 0, m_nVertices*sizeof(int));
  593|       |	
  594|      0|	for (int i=0; i<m_nFaces; i++)
  595|      0|	{
  596|      0|		Face *pFace = m_pFaces[i];
  597|      0|		int k1 = pFace->m_pVertices[0];
  598|      0|		int k2 = pFace->m_pVertices[1];
  599|      0|		int k3 = pFace->m_pVertices[2];
  600|      0|		vec3 p1p2, p1p3, n;
  601|      0|		vec3_init (p1p2,
  602|      0|			   m_pVertices[3*k2]   - m_pVertices[3*k1],
  603|      0|			   m_pVertices[3*k2+1] - m_pVertices[3*k1+1],
  604|      0|			   m_pVertices[3*k2+2] - m_pVertices[3*k1+2]);
  605|      0|		vec3_init (p1p3,
  606|      0|			   m_pVertices[3*k3]   - m_pVertices[3*k1],
  607|      0|			   m_pVertices[3*k3+1] - m_pVertices[3*k1+1],
  608|      0|			   m_pVertices[3*k3+2] - m_pVertices[3*k1+2]);
  609|      0|		vec3_cross_product (n, p1p2, p1p3);
  610|      0|		vec3_normalize (n);
  611|      0|		m_pFaceNormals[3*i]   = n[0];
  612|      0|		m_pFaceNormals[3*i+1] = n[1];
  613|      0|		m_pFaceNormals[3*i+2] = n[2];
  614|       |		
  615|      0|		for (int j=0; j<pFace->m_nVertices; j++)
  616|      0|		{
  617|      0|			int k = pFace->m_pVertices[j];
  618|       |			
  619|      0|			m_pVertexNormals[3*k]   += m_pFaceNormals[3*i];
  620|      0|			m_pVertexNormals[3*k+1] += m_pFaceNormals[3*i+1];
  621|      0|			m_pVertexNormals[3*k+2] += m_pFaceNormals[3*i+2];
  622|       |			
  623|      0|			nfaces[k]++;
  624|      0|		}
  625|      0|	}
  626|       |
  627|      0|	for (int i=0; i<m_nVertices; i++)
  628|      0|	{
  629|      0|		m_pVertexNormals[3*i]   /= nfaces[i];
  630|      0|		m_pVertexNormals[3*i+1] /= nfaces[i];
  631|      0|		m_pVertexNormals[3*i+2] /= nfaces[i];
  632|      0|	}
  633|       |
  634|       |	// cleaning
  635|      0|	delete[] nfaces;
  636|      0|}
  637|       |
  638|       |int Mesh::Append (Mesh *m)
  639|      0|{
  640|      0|	if (!m)
  641|      0|		return 0;
  642|       |
  643|       |	// vertices
  644|      0|	unsigned int res_nv = m_nVertices + m->m_nVertices;
  645|      0|	float *res_v = new float[3*res_nv];
  646|       |
  647|      0|	for (unsigned int i=0; i<3*m_nVertices; i++)
  648|      0|		res_v[i] = m_pVertices[i];
  649|       |
  650|      0|	for (unsigned int i=0; i<3*m->m_nVertices; i++)
  651|      0|		res_v[3*m_nVertices+i] = m->m_pVertices[i];
  652|       |
  653|      0|	delete m_pVertices;
  654|       |
  655|       |	// faces
  656|      0|	unsigned int res_nf = m_nFaces + m->m_nFaces;
  657|      0|	Face **res_f = new Face*[res_nf];
  658|       |
  659|      0|	for (unsigned int i=0; i<m_nFaces; i++)
  660|      0|		res_f[i] = m_pFaces[i];
  661|       |
  662|      0|	for (unsigned int i=0; i<m->m_nFaces; i++)
  663|      0|	{
  664|      0|		res_f[m_nFaces+i] = new Face (*m->m_pFaces[i]);
  665|      0|		for (unsigned int j=0; j<res_f[m_nFaces+i]->m_nVertices; j++)
  666|      0|			res_f[m_nFaces+i]->m_pVertices[j] += m_nVertices;
  667|      0|		res_f[m_nFaces+i]->SetMaterialId(m_nMaterials + m->m_pFaces[i]->GetMaterialId());
  668|      0|	}
  669|       |
  670|       |	// materials
  671|      0|	unsigned int res_nMaterials = m_nMaterials + m->m_nMaterials;
  672|      0|	for (unsigned int i=0; i<m->m_nMaterials; i++)
  673|      0|		Material_Add (m->m_pMaterials[i]);
  674|       |
  675|       |
  676|      0|	m_nVertices = res_nv;
  677|      0|	m_pVertices = res_v;
  678|       |
  679|      0|	m_nFaces = res_nf;
  680|      0|	m_pFaces = res_f;
  681|       |
  682|      0|	m_nMaterials = res_nMaterials;
  683|       |
  684|      0|	return 1;
  685|      0|}
  686|       |
  687|       |//
  688|       |// edit
  689|       |//
  690|       |int Mesh::DeleteVertices (funcptr_v func)
  691|      0|{
  692|      0|	unsigned int nVertices = 0;
  693|      0|	for (unsigned int i=0; i<m_nVertices; i++)
  694|      0|	{
  695|      0|		float x = m_pVertices[3*i];
  696|      0|		float y = m_pVertices[3*i+1];
  697|      0|		float z = m_pVertices[3*i+2];
  698|      0|		if (!func (x, y, z))
  699|      0|		{
  700|      0|			m_pVertices[3*nVertices]   = m_pVertices[3*i];
  701|      0|			m_pVertices[3*nVertices+1] = m_pVertices[3*i+1];
  702|      0|			m_pVertices[3*nVertices+2] = m_pVertices[3*i+2];
  703|       |
  704|      0|			m_pVertexNormals[3*nVertices]   = m_pVertexNormals[3*i];
  705|      0|			m_pVertexNormals[3*nVertices+1] = m_pVertexNormals[3*i+1];
  706|      0|			m_pVertexNormals[3*nVertices+2] = m_pVertexNormals[3*i+2];
  707|      0|			if (m_pVertexColors)
  708|      0|			{
  709|      0|				m_pVertexColors[3*nVertices]   = m_pVertexColors[3*i];
  710|      0|				m_pVertexColors[3*nVertices+1] = m_pVertexColors[3*i+1];
  711|      0|				m_pVertexColors[3*nVertices+2] = m_pVertexColors[3*i+2];
  712|      0|			}
  713|       |
  714|      0|			nVertices++;
  715|      0|		}
  716|      0|	}
  717|      0|	m_nVertices = nVertices;
  718|      0|	return 0;
  719|      0|}
  720|       |
  721|       |/*
  722|       |bool Mesh::ColorizeVerticesDensity_Traverse (Octree &o, void *_data)
  723|       |{
  724|       |	if (o.m_nIndices)
  725|       |	{
  726|       |		float *data = (float*)_data;
  727|       |		vec3 v0, v;
  728|       |		vec3_init (v0, data[0], data[1], data[2]);
  729|       |		float k = data[3];
  730|       |		for (int i=0; i<o.m_nIndices; i++)
  731|       |		{
  732|       |			GetVertex (i, v);
  733|       |			if (vec3_distance (v0, v) < k)
  734|       |				data[4+i]++;
  735|       |		}
  736|       |		
  737|       |	}
  738|       |	return true;
  739|       |}
  740|       |*/
  741|       |// Treatments on vertices
  742|       |int Mesh::ColorizeVerticesDensity (float k)
  743|      0|{
  744|      0|	if (!m_pVertexColors)
  745|      0|		InitVertexColors (m_nVertices);	
  746|       |
  747|      0|	unsigned int *neighbours = (unsigned int*)malloc(m_nVertices*sizeof(unsigned int));
  748|       |	//unsigned int neighbours[m_nVertices];
  749|      0|	memset (neighbours, 0, m_nVertices*sizeof(unsigned int));
  750|       |/*
  751|       |	vec3 v, vtmp;
  752|       |	for (int i=0; i<m_nVertices; i++)
  753|       |	{
  754|       |		printf ("%d / %d\n", i, m_nVertices);
  755|       |		GetVertex (i, v);
  756|       |		for (int j=0; j<m_nVertices; j++)
  757|       |		{
  758|       |			GetVertex (j, vtmp);
  759|       |			if (vec3_distance (v, vtmp) < k)
  760|       |				neighbours[i]++;
  761|       |		}
  762|       |	}
  763|       |*/
  764|       |
  765|      0|	Octree *pOctree = new Octree ();
  766|      0|	pOctree->Build (m_pVertices, m_nVertices, 200, 20);
  767|      0|	vec3 pt;
  768|      0|	for (int i=0; i<m_nVertices; i++)
  769|      0|	{
  770|       |		//printf ("%d %d\n", i, m_nVertices);
  771|      0|		GetVertex (i, pt);
  772|      0|		neighbours[i] = pOctree->GetKNeighbours (pt, k);
  773|      0|	}
  774|       |
  775|      0|	unsigned int max = 0;
  776|      0|	for (int i=0; i<m_nVertices; i++)
  777|      0|		if (neighbours[i] > max)
  778|      0|			max = neighbours[i];
  779|       |
  780|      0|	for (int i=0; i<m_nVertices; i++)
  781|      0|	{
  782|       |
  783|      0|		color_jet ((float)neighbours[i]/max,
  784|      0|			   &m_pVertexColors[3*i], &m_pVertexColors[3*i+1], &m_pVertexColors[3*i+2]);
  785|       |		
  786|       |		//m_pVertexColors[3*i]   = (float)neighbours[i]/max;
  787|       |		//m_pVertexColors[3*i+1] = (float)neighbours[i]/max;
  788|       |		//m_pVertexColors[3*i+2] = (float)neighbours[i]/max;
  789|      0|	}
  790|       |
  791|       |	// cleaning
  792|      0|	delete pOctree;
  793|      0|	free (neighbours);
  794|       |
  795|      0|	return 0;
  796|      0|}
  797|       |
  798|       |// noise
  799|       |void Mesh::add_gaussian_noise (float variance)
  800|      0|{
  801|      0|	for (int i=0; i<m_nVertices; i++)
  802|      0|	{
  803|      0|		static long idum = -247;
  804|      0|		vec3 disp;
  805|      0|		vec3_init (disp, gasdev(&idum), gasdev(&idum), gasdev(&idum));
  806|      0|		m_pVertices[3*i]   += variance*disp[0];
  807|      0|		m_pVertices[3*i+1] += variance*disp[1];
  808|      0|		m_pVertices[3*i+2] += variance*disp[2];
  809|      0|	}
  810|      0|}
  811|       |
  812|       |// topololy
  813|       |void Mesh::GetTopologicIssues(vector<unsigned int>& nonManifoldEdges, vector<unsigned int>& borders) const
  814|      0|{
  815|      0|	std::map<unsigned int, std::map<unsigned int, unsigned int>> occurences;
  816|      0|	for (int i = 0; i < m_nFaces; i++)
  817|      0|	{
  818|      0|		Face* pFace = m_pFaces[i];
  819|      0|		unsigned int nVertices = pFace->GetNVertices();
  820|      0|		for (int j = 0; j < nVertices; j++)
  821|      0|		{
  822|      0|			unsigned int v1 = pFace->GetVertex(j);
  823|      0|			unsigned int v2 = pFace->GetVertex((j + 1) % nVertices);
  824|      0|			if (v1 > v2) // v1 should be the smallest index
  825|      0|			{
  826|      0|				unsigned int tmp = v1;
  827|      0|				v1 = v2;
  828|      0|				v2 = tmp;
  829|      0|			}
  830|      0|			auto it = occurences.find(v1);
  831|      0|			if (it == occurences.end())
  832|      0|			{
  833|      0|				std::map<unsigned int, unsigned int> newOccurence;
  834|      0|				newOccurence.insert(std::pair<unsigned int, unsigned int>(v2, 1));
  835|      0|				occurences.insert(std::pair<unsigned int, std::map<unsigned int, unsigned int>>(v1, newOccurence));
  836|      0|			}
  837|      0|			else
  838|      0|			{
  839|      0|				auto it2 = it->second.find(v2);
  840|      0|				if (it2 != it->second.end())
  841|      0|				{
  842|       |					//if (std::find(it->second.begin(), it->second.end(), v2) != it->second.end())
  843|      0|					it2->second++;
  844|      0|				}
  845|      0|				else
  846|      0|				{
  847|      0|					it->second.insert(std::pair<unsigned int, unsigned int>(v2, 1));
  848|      0|				}
  849|      0|			}
  850|      0|		}
  851|      0|	}
  852|       |
  853|      0|	for (auto occurence : occurences)
  854|      0|	{
  855|      0|		auto v1 = occurence.first;
  856|      0|		for (auto links : occurence.second)
  857|      0|		{
  858|      0|			auto v2 = links.first;
  859|      0|			auto n = links.second;
  860|      0|			if (n == 1)
  861|      0|			{
  862|      0|				borders.push_back(v1);
  863|      0|				borders.push_back(v2);
  864|      0|			}
  865|      0|			else if (n >= 3)
  866|      0|			{
  867|      0|				nonManifoldEdges.push_back(v1);
  868|      0|				nonManifoldEdges.push_back(v2);
  869|      0|			}
  870|      0|		}
  871|      0|	}
  872|       |
  873|      0|	occurences.clear();
  874|      0|}
  875|       |
  876|       |//
  877|       |// from class Geometry
  878|       |//
  879|       |bool Mesh::GetIntersectionBboxWithRay (vec3 o, vec3 d)
  880|  16.3k|{
  881|  16.3k|	float bbox_min[3];
  882|  16.3k|	float bbox_max[3];
  883|  16.3k|	m_bbox.GetMinMax(bbox_min, bbox_max);
  884|  16.3k|	AABox *m_pAABox = new AABox (bbox_min[0], bbox_min[1], bbox_min[2]);
  885|  16.3k|	if (m_pAABox)
  886|  16.3k|	{
  887|  16.3k|		m_pAABox->AddVertex (bbox_max[0], bbox_max[1], bbox_max[2]);
  888|  16.3k|		Ray r (Vector3 (o[0], o[1], o[2]), Vector3 (d[0], d[1], d[2]));
  889|  16.3k|		return m_pAABox->intersection (r, 0., 100.);
  890|  16.3k|	}
  891|      0|	else
  892|      0|		return true;
  893|  16.3k|}
  894|       |
  895|       |int Mesh::GetIntersectionWithRayInOctree (vec3 vOrig, vec3 vDirection, float *_t, vec3 vIntersection, vec3 vNormal, Octree *pOctree)
  896|   120k|{
  897|   120k|	if (pOctree->IsLeaf ())
  898|  74.3k|	{
  899|  74.3k|		unsigned int nTriangles = pOctree->GetNTriangles();
  900|  74.3k|		unsigned int *pTriangles = pOctree->GetTriangles();
  901|  74.3k|		float fTCurrent, fT = -1.;
  902|  74.3k|		Triangle tri;
  903|  3.09M|		for (unsigned int i=0; i<nTriangles; i++)
  904|  3.02M|		{
  905|  3.02M|			float vIntersectionCurrent[3], vNormalCurrent[3];
  906|       |
  907|  3.02M|			unsigned int vi1, vi2, vi3;
  908|  3.02M|			vi1 = 3*pTriangles[3*i];
  909|  3.02M|			vi2 = 3*pTriangles[3*i+1];
  910|  3.02M|			vi3 = 3*pTriangles[3*i+2];
  911|  3.02M|			tri.Init (m_pVertices[vi1], m_pVertices[vi1+1], m_pVertices[vi1+2],
  912|  3.02M|						m_pVertices[vi2], m_pVertices[vi2+1], m_pVertices[vi2+2],
  913|  3.02M|						m_pVertices[vi3], m_pVertices[vi3+1], m_pVertices[vi3+2]);
  914|  3.02M|			if (tri.GetIntersectionWithRay (vOrig, vDirection, &fTCurrent, vIntersectionCurrent, vNormalCurrent))
  915|  17.3k|			{
  916|  17.3k|				if (fT < 0. || fTCurrent < fT)
  917|  17.3k|				{
  918|  17.3k|					fT = fTCurrent;
  919|  17.3k|					vec3_copy (vIntersection, vIntersectionCurrent);
  920|  17.3k|					vec3_copy (vNormal, vNormalCurrent);
  921|  17.3k|				}
  922|  17.3k|			}
  923|  3.02M|		}
  924|       |
  925|  74.3k|		*_t = fT;
  926|  74.3k|		return (fT < 0.)? 0 : 1;
  927|  74.3k|	}
  928|  45.8k|	else
  929|  45.8k|	{
  930|  45.8k|		Ray ray (vOrig[0], vOrig[1], vOrig[2], vDirection[0], vDirection[1], vDirection[2]);
  931|  45.8k|		float fTCurrent, fT = -1.;
  932|   412k|		for (int i=0; i<8; i++)
  933|   366k|		{
  934|   366k|			Octree *pChild = pOctree->GetChildren()[i];
  935|   366k|			if (!pChild)
  936|  11.3k|				continue;
  937|   355k|			AABox AABox(pChild->m_vecMin[0], pChild->m_vecMin[1], pChild->m_vecMin[2]);
  938|   355k|			AABox.AddVertex (pChild->m_vecMax[0], pChild->m_vecMax[1], pChild->m_vecMax[2]);
  939|   355k|			if (AABox.intersection (ray, 0., 10000.))
  940|   106k|			{
  941|   106k|				vec3 vIntersectionCurrent, vNormalCurrent; 
  942|   106k|				if (GetIntersectionWithRayInOctree (vOrig, vDirection, &fTCurrent, vIntersectionCurrent, vNormalCurrent, pChild))
  943|  27.5k|				{
  944|  27.5k|					if (fT < 0. || fTCurrent < fT)
  945|  18.0k|					{
  946|  18.0k|						fT = fTCurrent;
  947|  18.0k|						vec3_copy (vIntersection, vIntersectionCurrent);
  948|  18.0k|						vec3_copy (vNormal, vNormalCurrent);
  949|  18.0k|					}
  950|  27.5k|				}
  951|   106k|			}
  952|   355k|		}
  953|  45.8k|		*_t = fT;
  954|  45.8k|		return (fT < 0.)? 0 : 1;
  955|  45.8k|	}
  956|   120k|}
  957|       |
  958|       |int Mesh::GetIntersectionWithRay (vec3 vOrig, vec3 vDirection, float *_t, vec3 vIntersection, vec3 vNormal)
  959|  14.0k|{
  960|       |	/*
  961|       |	// test the bbox
  962|       |	bool bGotBBox = GetIntersectionBboxWithRay (vOrig, vDirection);
  963|       |	if (bGotBBox == false)
  964|       |		return 0;
  965|       |	*/
  966|       |
  967|  14.0k|	if (1 && !m_pOctree)
  968|      1|	{
  969|      1|		m_pOctree = new Octree ();
  970|      1|		m_pOctree->BuildForTriangles (m_pVertices, m_nVertices,
  971|      1|									  100, // maxTriangles
  972|      1|									  5,  // maxDepth
  973|      1|								      GetTriangles (), m_nFaces);
  974|      1|	}
  975|       |
  976|  14.0k|	if (m_pOctree)
  977|  14.0k|	{
  978|  14.0k|		return GetIntersectionWithRayInOctree (vOrig, vDirection, _t, vIntersection, vNormal, m_pOctree);
  979|  14.0k|	}
  980|      0|	else // test alls the triangles
  981|      0|	{
  982|      0|		float fTCurrent, fT = -1.;
  983|      0|		Triangle *pTri = new Triangle ();
  984|      0|		for (unsigned int i=0; i<m_nFaces; i++)
  985|      0|		{
  986|      0|			float vIntersectionCurrent[3], vNormalCurrent[3];
  987|       |
  988|      0|			unsigned int vi1, vi2, vi3;
  989|      0|			vi1 = 3*m_pFaces[i]->GetVertex (0);
  990|      0|			vi2 = 3*m_pFaces[i]->GetVertex (1);
  991|      0|			vi3 = 3*m_pFaces[i]->GetVertex (2);
  992|      0|			pTri->Init (m_pVertices[vi1], m_pVertices[vi1+1], m_pVertices[vi1+2],
  993|      0|						m_pVertices[vi2], m_pVertices[vi2+1], m_pVertices[vi2+2],
  994|      0|						m_pVertices[vi3], m_pVertices[vi3+1], m_pVertices[vi3+2]);
  995|      0|			if (pTri->GetIntersectionWithRay (vOrig, vDirection, &fTCurrent, vIntersectionCurrent, vNormalCurrent))
  996|      0|			{
  997|      0|				if (fT < 0. || fTCurrent < fT)
  998|      0|				{
  999|      0|					fT = fTCurrent;
 1000|      0|					vec3_copy (vIntersection, vIntersectionCurrent);
 1001|      0|					vec3_copy (vNormal, vNormalCurrent);
 1002|      0|				}
 1003|      0|			}
 1004|      0|		}
 1005|      0|		delete pTri;
 1006|      0|		*_t = fT;
 1007|      0|		return (fT < 0.)? 0 : 1;
 1008|      0|	}
 1009|  14.0k|}
 1010|       |
 1011|       |int Mesh::GetIntersectionWithSegment (vec3 vStart, vec3 vEnd, float *_t, vec3 i, vec3 n)
 1012|      0|{
 1013|      0|	return 0;
 1014|      0|}
 1015|       |
 1016|       |void* Mesh::GetMaterial (void)
 1017|  7.81k|{
 1018|  7.81k|	if (m_nMaterials == 0)
 1019|      1|	{
 1020|       |		// add a default material
 1021|      1|		MaterialColorExt *pMaterial;
 1022|      1|		pMaterial = new MaterialColorExt();
 1023|      1|		pMaterial->Init_From_Library (MaterialColorExt::EMERALD);
 1024|      1|		unsigned int id = Material_Add (pMaterial);
 1025|      1|		ApplyMaterial (id);
 1026|      1|	}
 1027|  7.81k|	return GetMaterial (0);
 1028|  7.81k|}
 1029|       |

/workspaces/cg/src/cgmesh/mesh.h:
    1|       |#ifndef __MESH_H__
    2|       |#define __MESH_H__
    3|       |
    4|       |#include <stdlib.h>
    5|       |#include <stdio.h>
    6|       |#include <string.h>
    7|       |#include <vector>
    8|       |
    9|       |#include "../cgmath/cgmath.h"
   10|       |#include "material.h"
   11|       |#include "tensor.h"
   12|       |#include "bounding_box.h"
   13|       |
   14|       |class Octree;
   15|       |
   16|       |class Face
   17|       |{
   18|       |public:
   19|       |	Face ();
   20|       |	Face (const Face &f); // constructor of copy
   21|       |	~Face ();
   22|       |
   23|       |	void Init (void);
   24|       |	int SetNVertices (unsigned int n);
   25|      0|	int GetNVertices (void) { return m_nVertices; };
   26|       |
   27|       |	// vertices
   28|  1.98k|	inline int GetVertex (unsigned int i) { if (i>=m_nVertices) return -1; return m_pVertices[i]; };
   29|  7.17k|	inline int SetVertex (unsigned int i, unsigned int vi) { if (i>=m_nVertices) return -1; m_pVertices[i] = vi; return 1; };
   30|       |
   31|       |	// tex coord
   32|       |	inline int ActivateTextureCoordinatesIndices ()
   33|      0|		{
   34|      0|			if (m_pTextureCoordinatesIndices)
   35|      0|				delete m_pTextureCoordinatesIndices;
   36|      0|			m_pTextureCoordinatesIndices = new unsigned int[2*m_nVertices];
   37|      0|			return 1;
   38|      0|		}
   39|       |
   40|       |	inline int ActivateTextureCoordinates ()
   41|      0|		{
   42|      0|			if (m_pTextureCoordinates)
   43|      0|				delete m_pTextureCoordinates;
   44|      0|			m_pTextureCoordinates = new float[2*m_nVertices];
   45|       |
   46|      0|			return 1;
   47|      0|		}
   48|       |
   49|       |	inline bool InitTexCoord()
   50|      0|	{
   51|      0|		if (!m_pTextureCoordinatesIndices)
   52|      0|			return false;
   53|      0|		for (int i = 0; i < m_nVertices; i++)
   54|      0|			m_pTextureCoordinatesIndices[i] = GetVertex(i);
   55|      0|		return true;
   56|      0|	}
   57|       |
   58|       |	inline int SetTexCoord (unsigned int i, unsigned int ti)
   59|      0|		{
   60|      0|			if (i>=m_nVertices)
   61|      0|				return -1;
   62|      0|			m_pTextureCoordinatesIndices[i] = ti;
   63|      0|			return 1;
   64|      0|		};
   65|       |	
   66|       |	inline int SetTexCoord (unsigned int i, float u, float v)
   67|      0|		{
   68|      0|			if (i>=m_nVertices)
   69|      0|				return -1;
   70|      0|			m_pTextureCoordinates[2*i]   = u;
   71|      0|			m_pTextureCoordinates[2*i+1] = v;
   72|      0|			return 1;
   73|      0|		};
   74|       |
   75|       |	void SetTriangle (unsigned int a, unsigned int b, unsigned int c);
   76|       |	void SetQuad (unsigned int a, unsigned int b, unsigned int c, unsigned int d);
   77|       |
   78|       |	inline void Flip (void)
   79|    662|		{
   80|  1.32k|			for (unsigned int i=0; i<m_nVertices/2; i++)
   81|    662|			{
   82|    662|				unsigned int j = m_pVertices[i];
   83|    662|				m_pVertices[i] = m_pVertices[m_nVertices-1-i];
   84|    662|				m_pVertices[m_nVertices-1-i] = j;
   85|    662|			}
   86|    662|		}
   87|       |
   88|       |	// material
   89|      0|	inline int GetMaterialId (void) { return m_iMaterialId; };
   90|      0|	inline void SetMaterialId (unsigned int mi) { m_iMaterialId = mi; };
   91|       |
   92|       |	void dump (void);
   93|       |
   94|       |public:
   95|       |	unsigned int m_nVertices;
   96|       |	unsigned int *m_pVertices;
   97|       |	bool m_bUseTextureCoordinates;
   98|       |	unsigned int *m_pTextureCoordinatesIndices;
   99|       |	float *m_pTextureCoordinates;
  100|       |	unsigned int m_iMaterialId;
  101|       |};
  102|       |
  103|       |//
  104|       |// class Mesh
  105|       |//
  106|       |typedef int (*funcptr_v)(float x, float y, float z);
  107|       |class Mesh : public Geometry
  108|       |{
  109|       |public:
  110|       |	Mesh ();
  111|       |	Mesh (unsigned int nVertices, unsigned int nFaces);
  112|       |	Mesh (Mesh &m);
  113|       |	~Mesh();
  114|       |
  115|       |	void Dump();
  116|       |
  117|       |	// from class Geometry
  118|       |	bool GetIntersectionBboxWithRay (vec3 o, vec3 d);
  119|       |	int GetIntersectionWithRayInOctree (vec3 o, vec3 d, float *_t, vec3 i, vec3 n, Octree *pOctree);
  120|       |	virtual int GetIntersectionWithRay (vec3 o, vec3 d, float *_t, vec3 i, vec3 n);
  121|       |	virtual int GetIntersectionWithSegment (vec3 vStart, vec3 vEnd, float *_t, vec3 i, vec3 n);
  122|       |	virtual void* GetMaterial (void);
  123|       |
  124|       |private:
  125|       |	void DeleteFaces (void);
  126|       |
  127|       |	// Init
  128|       |protected:
  129|       |	void InitVertices (unsigned int nVertices);
  130|       |	void InitFaces (unsigned int nFaces);
  131|       |	void InitTensors (void);
  132|       |public:
  133|       |	void Init (void);
  134|       |	void Init (unsigned int nVertices, unsigned int nFaces);
  135|       |	void InitVertexColors (float r = 0., float g = 0., float b = 0.);
  136|       |	void InitVertexColorsFromCurvatures (Tensor::eCurvature curvature);
  137|       |	void InitVertexColorsFromArray (float *array, char *defined = NULL);
  138|       |
  139|       |	// Getters / Setters
  140|       |	unsigned int* GetTriangles (void);
  141|      0|	inline int GetVertex (unsigned int i, float v[3]) {
  142|      0|		if (i>=m_nVertices) return -1;
  143|      0|		i*=3;
  144|      0|		v[0] = m_pVertices[i];
  145|      0|		v[1] = m_pVertices[i+1];
  146|      0|		v[2] = m_pVertices[i+2];
  147|      0|		return 0;
  148|      0|	};
  149|      0|	inline int GetFaceVertex (unsigned int fi, unsigned int vi) { return m_pFaces[fi]->GetVertex (vi); };
  150|       |
  151|      0|	Face *GetFace (unsigned int fi) { return m_pFaces[fi]; };
  152|      0|	inline int GetFaceNVertices (unsigned int fi) { return m_pFaces[fi]->GetNVertices (); };
  153|      0|	inline int GetFaceMaterialId (unsigned int fi) { return m_pFaces[fi]->GetMaterialId (); };
  154|      0|	inline void SetFaceMaterialId (unsigned int fi, unsigned int mi) { m_pFaces[fi]->SetMaterialId (mi); };
  155|       |	void GetFaceBarycenter (unsigned int fi, vec3 bar)
  156|      0|		{
  157|      0|			Face *f=m_pFaces[fi];
  158|      0|			if (f->m_nVertices == 3)
  159|      0|			{
  160|      0|				unsigned int a = f->m_pVertices[0];
  161|      0|				unsigned int b = f->m_pVertices[1];
  162|      0|				unsigned int c = f->m_pVertices[2];
  163|      0|				vec3_init (bar,
  164|      0|					   (m_pVertices[3*a] + m_pVertices[3*b] + m_pVertices[3*c]) / 3.,
  165|      0|					   (m_pVertices[3*a+1] + m_pVertices[3*b+1] + m_pVertices[3*c+1]) / 3.,
  166|      0|					   (m_pVertices[3*a+2] + m_pVertices[3*b+2] + m_pVertices[3*c+2]) / 3. );
  167|      0|			}
  168|      0|		};
  169|       |
  170|       |	int SetVertices (unsigned int nVertices, float *pVertices);
  171|       |	int SetFaces (unsigned int nFaces, unsigned int nVerticesPerFace,
  172|       |		      unsigned int *pFaces, unsigned int *pTextureCoordinates=NULL);
  173|       |	//int SetTextureCoordinates (unsigned int nTextureCoordinates, float *pTextureCoordinates);
  174|       |
  175|       |	int SetVertex (unsigned int i, float x, float y, float z);
  176|       |	int SetFace (unsigned int i,
  177|       |		     unsigned int a, unsigned int b, unsigned int c);
  178|       |	int SetFace (unsigned int i,
  179|       |		     unsigned int a, unsigned int b, unsigned int c, unsigned int d);
  180|       |
  181|       |	Tensor* GetTensor (unsigned int index);
  182|       |
  183|       |	// Treatments on vertices
  184|       |//	bool ColorizeVerticesDensity_Traverse (Octree &o, void *data);
  185|       |	int ColorizeVerticesDensity (float k);
  186|       |
  187|       |	void FlipFaces (void)
  188|      1|		{
  189|    663|			for (unsigned int i=0; i<m_nFaces; i++)
  190|    662|				m_pFaces[i]->Flip();
  191|      1|		}
  192|       |
  193|       |	// edit
  194|       |	int DeleteVertices (funcptr_v func);
  195|       |
  196|       |	// noise
  197|       |	void add_gaussian_noise (float variance);
  198|       |
  199|       |	void GetTopologicIssues(std::vector<unsigned int>& nonManifoldBorders, std::vector<unsigned int>& borders) const;
  200|       |
  201|       |	// IO
  202|       |private:
  203|       |	int import_mtl (char *filename, char *path);
  204|       |	int import_obj (char *filename);
  205|       |	int import_objnm (char *filename);
  206|       |	int export_obj (char *filename);
  207|       |	int import_3ds (char *filename);
  208|       |	int export_3ds (char *filename);
  209|       |	int import_asc (char*filename);
  210|       |	int export_asc (char*filename);
  211|       |	int import_pset (char *filename);
  212|       |	int export_pset (char *filename);
  213|       |	int export_dae (char *filename);
  214|       |	int export_cpp (char *filename);
  215|       |	int export_gts (char *filename);
  216|       |	int import_ifs (char *filename);
  217|       |	int import_lwo (char *filename);
  218|       |	int import_off (char *filename);
  219|       |	int export_off (char *filename);
  220|       |	int import_pgm (char *filename);
  221|       |	int import_pts (char *filename);
  222|       |	int export_pts (char *filename);
  223|       |	int import_ply (char *filename);
  224|       |	int export_ply (char *filename);
  225|       |	int import_stl (char *filename);
  226|       |	int export_stl (char *filename);
  227|       |	int import_u3d (char *filename);
  228|       |	int export_u3d (char *filename);
  229|       |public:
  230|       |	int load (char *filename);
  231|       |	int save (char *filename);
  232|       |
  233|       |	// bbox
  234|       |	int computebbox (void);
  235|       |	const BoundingBox& bbox() const;
  236|       |	float bbox_diagonal_length (void) const;
  237|       |	float GetLargestLength(void) const;
  238|       |
  239|       |	// area
  240|       |	float GetFaceArea (unsigned int fi);
  241|       |	float GetArea (void);
  242|       |	float* GetAreas (void);
  243|       |	float* GetCumulativeAreas (void);
  244|       |
  245|       |	//
  246|       |	// normals
  247|       |	//
  248|       |	void ComputeNormals (void);
  249|       |	
  250|       |	//
  251|       |	// stats
  252|       |	//
  253|       |	int stats_vertices_in_faces (int *verticesinfaces, int n);
  254|       |
  255|       |	unsigned int GetNVertices() const;
  256|       |	unsigned int GetNFaces() const;
  257|       |	bool IsTriangleMesh() const;
  258|       |
  259|       |	// triangulation
  260|       |	void triangulate_regular_heightfield (unsigned int width, unsigned int height);
  261|       |
  262|       |	//
  263|       |	// Materials
  264|       |	//
  265|       |	Material* GetMaterial (unsigned int id)
  266|  7.81k|		{
  267|  7.81k|			if (id < m_nMaterials)
  268|  7.81k|				return m_pMaterials[id];
  269|      0|			return NULL;
  270|  7.81k|		}
  271|       |	int GetMaterialId (char *material_name)
  272|      0|		{
  273|      0|			for (unsigned int i=0; i<m_nMaterials; i++)
  274|      0|				if (strcmp (m_pMaterials[i]->GetName(), material_name) == 0)
  275|      0|					return i;
  276|      0|			return -1;
  277|      0|		}
  278|       |	void SetMaterial (unsigned int id, Material *pMaterial)
  279|      0|	{
  280|      0|		if (m_pMaterials == NULL)
  281|      0|		{
  282|      0|			m_pMaterials = new Material*[id+1];
  283|      0|			m_nMaterials = id+1;
  284|      0|		}
  285|      0|		else if (id > m_nMaterials)
  286|      0|		{
  287|      0|			delete m_pMaterials;
  288|      0|			m_pMaterials = new Material*[id+1];
  289|      0|			m_nMaterials = id+1;
  290|      0|		}
  291|      0|		m_pMaterials[id] = pMaterial;
  292|      0|	};
  293|       |
  294|       |	unsigned int Material_Add (Material *pMaterial)
  295|      1|	{
  296|      1|		Material **pMaterials = new Material*[m_nMaterials+1];
  297|      1|		if (pMaterials == NULL)
  298|      0|			return 0;
  299|       |		
  300|      1|		for (unsigned int i=0; i<m_nMaterials; i++)
  301|      0|			pMaterials[i] = m_pMaterials[i];
  302|      1|		pMaterials[m_nMaterials] = pMaterial;
  303|      1|		delete[] m_pMaterials;
  304|      1|		m_pMaterials = pMaterials;
  305|      1|		m_nMaterials++;
  306|      1|		return m_nMaterials-1;
  307|      1|	};
  308|       |
  309|       |	void ApplyMaterial (unsigned int id)
  310|      1|	{
  311|      1|		if (id > m_nMaterials)
  312|      0|			return;
  313|    663|		for (unsigned int i=0; i<m_nFaces; i++)
  314|    662|			m_pFaces[i]->m_iMaterialId = id;
  315|      1|	}
  316|       |
  317|       |	//
  318|       |	// Transformations
  319|       |	//
  320|       |	void centerize (void);
  321|       |	void scale (float s);
  322|       |	void scale_xyz (float sx, float sy, float sz);
  323|       |	void translate (float tx, float ty, float tz);
  324|       |	void transform (float mrot[9]);
  325|       |	void transform (mat3 m);
  326|       |	void transform4 (mat4 m);
  327|       |
  328|       |	//
  329|       |	int Append (Mesh *m);
  330|       |
  331|       |public:
  332|       |	std::string m_name;
  333|       |	unsigned int m_nVertices;
  334|       |	unsigned int m_nFaces;
  335|       |	float *m_pVertices;
  336|       |	float *m_pVertexNormals;
  337|       |	float *m_pVertexColors;
  338|       |	Face **m_pFaces;
  339|       |	float *m_pFaceNormals;
  340|       |	unsigned int m_nTextureCoordinates;
  341|       |	float *m_pTextureCoordinates;
  342|       |	unsigned int m_nMaterials;
  343|       |	Material **m_pMaterials;
  344|       |	Tensor **m_pTensors;
  345|       |
  346|       |	BoundingBox m_bbox;
  347|       |
  348|       |	Octree *m_pOctree;
  349|       |};
  350|       |
  351|       |#endif // __MESH_H__

/workspaces/cg/src/cgmesh/mesh_half_edge.cpp:
    1|       |#include <stdlib.h>
    2|       |#include <math.h>
    3|       |#include <assert.h>
    4|       |
    5|       |#include "mesh_half_edge.h"
    6|       |
    7|       |static int is_visited (Che_edge *edge, Che_edge **array, int n)
    8|      0|{
    9|      0|	for (int i=0; i<n; i++)
   10|      0|		if (array[i] == edge)
   11|      0|			return 1;
   12|      0|		return 0;
   13|      0|}
   14|       |
   15|       |/**
   16|       |* Check the topology around the vertices.
   17|       |*
   18|       |* Fill the array m_topology_ok with 1 if the vertex has a correct topology, 0 otherwise.
   19|       |*/
   20|       |void
   21|       |Mesh_half_edge::check_topology (void)
   22|      1|{
   23|      1|	m_topology_ok = (char*)malloc(m_nVertices*sizeof(char));
   24|      1|	for (int i=0; i<m_nVertices; i++)
   25|      0|	{
   26|      0|		m_topology_ok[i] = 1;
   27|       |		
   28|      0|		Che_edge **visited_edges = NULL;
   29|      0|		int n_visited_edges = 0;
   30|       |		
   31|      0|		Che_edge *e = m_edges_vertex[i];
   32|      0|		Che_edge *e_walk = e;
   33|      0|		if (!e) // isolated vertex
   34|      0|		{
   35|      0|			m_topology_ok[i] = 0;
   36|      0|			continue;
   37|      0|		}
   38|      0|		do
   39|      0|		{
   40|      0|			if (is_visited (e_walk, visited_edges, n_visited_edges))
   41|      0|			{
   42|      0|				printf ("not correct topology on vertex %d\n", i);
   43|      0|				m_topology_ok[i] = 0;
   44|      0|				break;
   45|      0|			}
   46|      0|			visited_edges = (Che_edge**)realloc(visited_edges, (n_visited_edges+1)*sizeof(Che_edge*));
   47|      0|			visited_edges[n_visited_edges] = e_walk;
   48|      0|			n_visited_edges++;
   49|      0|			e_walk = e_walk->m_he_next->m_he_next->m_pair;
   50|      0|		} while (e_walk && e_walk != e);
   51|      0|		free (visited_edges);
   52|      0|    }
   53|      1|}
   54|       |
   55|       |/**
   56|       |* Check the border.
   57|       |*
   58|       |* Fill the array border with 1 if the vertex belongs to the border, 0 otherwise.
   59|       |*/
   60|       |void
   61|       |Mesh_half_edge::check_border (void)
   62|      1|{
   63|      1|	if (!m_topology_ok) check_topology ();
   64|      1|	m_border = (char*)malloc(m_nVertices*sizeof(char));
   65|      1|	for (int i=0; i<m_nVertices; i++)
   66|      0|	{
   67|      0|		if (!m_topology_ok[i])
   68|      0|			m_border[i] = 1;
   69|      0|		else
   70|      0|		{
   71|      0|			Che_edge *loc_e_walk = m_edges_vertex[i];
   72|      0|			if (!loc_e_walk)
   73|      0|				m_border[i] = 1;
   74|      0|			else
   75|      0|			{
   76|      0|				do {
   77|      0|					loc_e_walk = loc_e_walk->m_he_next->m_he_next->m_pair;
   78|      0|				} while (loc_e_walk && loc_e_walk != m_edges_vertex[i]);
   79|      0|				if (!loc_e_walk)
   80|      0|					m_border[i] = 1;
   81|      0|				else
   82|      0|					m_border[i] = 0;
   83|      0|			}
   84|      0|		}
   85|      0|	}
   86|      1|}
   87|       |
   88|       |/**
   89|       |* Constructor.
   90|       |*/
   91|       |Mesh_half_edge::Mesh_half_edge (int par_nv, float *par_v, int par_nf, unsigned int *par_f)
   92|      0|{
   93|      0|	SetVertices (par_nv, par_v);
   94|      0|	SetFaces (par_nf, 3, par_f);
   95|       |
   96|      0|	m_topology_ok = NULL;
   97|      0|	m_border = NULL;
   98|       |
   99|      0|	Che_mesh::create_half_edge (m_nVertices, m_nFaces, GetTriangles());
  100|      0|	check_border ();
  101|      0|}
  102|       |
  103|       |Mesh_half_edge::Mesh_half_edge (Mesh *pMesh)
  104|      0|{
  105|      0|	if (!pMesh)
  106|      0|		return;
  107|       |
  108|      0|	SetVertices (pMesh->m_nVertices, pMesh->m_pVertices);
  109|      0|	SetFaces (pMesh->m_nFaces, 3, pMesh->GetTriangles());
  110|       |
  111|      0|	m_topology_ok = NULL;
  112|      0|	m_border = NULL;
  113|       |
  114|      0|	Che_mesh::create_half_edge (m_nVertices, m_nFaces, GetTriangles());
  115|      0|	check_border ();
  116|      0|}
  117|       |
  118|       |/**
  119|       |* Constructor.
  120|       |*/
  121|       |Mesh_half_edge::Mesh_half_edge ()
  122|      1|: Mesh ()
  123|      1|{
  124|      1|	m_topology_ok = NULL;
  125|      1|	m_border = NULL;
  126|       |
  127|      1|	Che_mesh::create_half_edge (m_nVertices, m_nFaces, GetTriangles());
  128|      1|	check_border ();
  129|      1|}
  130|       |
  131|       |Mesh_half_edge::Mesh_half_edge (char *par_filename)
  132|      0|{
  133|      0|	load (par_filename);
  134|       |
  135|      0|	m_topology_ok = NULL;
  136|      0|	m_border = NULL;
  137|       |
  138|      0|	Che_mesh::create_half_edge (m_nVertices, m_nFaces, GetTriangles());
  139|      0|	check_topology ();
  140|      0|	check_border ();
  141|      0|}
  142|       |
  143|       |void Mesh_half_edge::create_half_edge (void)
  144|      0|{
  145|      0|	m_topology_ok = NULL;
  146|      0|	m_border = NULL;
  147|       |
  148|      0|	Che_mesh::create_half_edge (m_nVertices, m_nFaces, GetTriangles());
  149|      0|	check_topology ();
  150|      0|	check_border ();
  151|      0|}
  152|       |
  153|       |// export statistics in html format
  154|       |void Mesh_half_edge::export_statistics (char *filename)
  155|      0|{
  156|      0|	FILE *ptr = fopen (filename, "w");
  157|      0|	if (!ptr)
  158|      0|		return;
  159|       |
  160|      0|	fprintf (ptr, "<html>\n");
  161|      0|	fprintf (ptr, "<head><title></title></head>\n");
  162|      0|	fprintf (ptr, "<body>\n");
  163|      0|	fprintf (ptr, "<p>number of vertices : %d\n", m_nVertices);
  164|      0|	fprintf (ptr, "<p>number of faces : %d\n", m_nFaces);
  165|       |
  166|       |
  167|      0|	computebbox ();
  168|      0|	float min[3], max[3];
  169|      0|	m_bbox.GetMinMax(min, max);
  170|      0|	fprintf (ptr, "<p>bbox :\n");
  171|      0|	fprintf (ptr, "<br> x : %f -> %f\n", min[0], max[0]);
  172|      0|	fprintf (ptr, "<br> y : %f -> %f\n", min[1], max[1]);
  173|      0|	fprintf (ptr, "<br> z : %f -> %f\n", min[2], max[2]);
  174|      0|	fprintf (ptr, "<br>diagonal length : %f\n", bbox_diagonal_length ());
  175|       |
  176|      0|	fprintf (ptr, "<p>center : (%.3f , %.3f , %.3f)\n", (max[0]+min[0])/2., (max[1]+min[1])/2., (max[2]+min[2])/2.);
  177|      0|	fprintf (ptr, "<p>dimensions : %.3f x %.3f x %.3f\n", max[0]-min[0], max[1]-min[1], max[2]-min[2]);
  178|       |
  179|       |	//
  180|      0|	int nverticesinfaces = 13;
  181|      0|	int *verticesinfaces = (int*)malloc(nverticesinfaces*sizeof(int));
  182|      0|	stats_vertices_in_faces (verticesinfaces, nverticesinfaces);
  183|      0|	printf ("vertices in faces : ");
  184|      0|	for (int i=3; i<nverticesinfaces; i++)
  185|      0|	{
  186|      0|		fprintf (ptr, "%d", i);
  187|      0|		if (i==nverticesinfaces-1)
  188|      0|			fprintf (ptr, "+");
  189|      0|		fprintf (ptr, "/%d ", verticesinfaces[i]);
  190|      0|	}
  191|      0|	fprintf (ptr, "<br>");
  192|       |
  193|       |	// materials
  194|      0|	fprintf (ptr, "<p>Materials : %d", m_nMaterials);
  195|      0|	for (int i=0; i<m_nMaterials; i++)
  196|      0|	{
  197|      0|		Material *pMaterial = (Material*)m_pMaterials[i];
  198|      0|		fprintf (ptr, "<br>material %d : %s", i, pMaterial->GetName());
  199|      0|	}
  200|       |
  201|       |
  202|      0|	fprintf (ptr, "</body>\n");
  203|      0|	fprintf (ptr, "</html>\n");
  204|       |
  205|      0|	fclose (ptr);
  206|      0|}
  207|       |
  208|       |
  209|       |Che_edge *Mesh_half_edge::get_edge (unsigned int v1, unsigned int v2)
  210|      0|{
  211|      0|	if (!is_manifold (v1))
  212|      0|		return NULL;
  213|       |
  214|      0|	Che_edge *he = m_edges_vertex[v1];
  215|      0|	Che_edge *he_walk = he;
  216|      0|	int bFound = 0;
  217|      0|	do
  218|      0|	{
  219|      0|		if (he_walk == NULL)
  220|      0|			break;
  221|      0|		if (he_walk->m_v_end == v2)
  222|      0|		{
  223|      0|			bFound = 1;
  224|      0|			break;
  225|      0|		}
  226|       |		
  227|      0|		he_walk = he_walk->m_he_next->m_he_next->m_pair;
  228|      0|	} while (he_walk != he);
  229|       |	
  230|      0|	return (bFound)? he_walk : NULL;
  231|      0|}
  232|       |
  233|       |/**
  234|       |* Destructor.
  235|       |*/
  236|       |Mesh_half_edge::~Mesh_half_edge ()
  237|      0|{
  238|      0|}
  239|       |
  240|       |////////////////////////////////////////////////////////////////////////////////
  241|       |//
  242|       |// methods inherited from Che_mesh
  243|       |//
  244|       |void Mesh_half_edge::edge_flip (Che_edge *par_edge)
  245|      0|{
  246|      0|	if (par_edge->m_pair == NULL)
  247|      0|		return;
  248|       |
  249|       |	// update the faces
  250|      0|	unsigned int f1 = par_edge->m_face;
  251|      0|	unsigned int f1_v1 = par_edge->m_v_begin;
  252|      0|	unsigned int f1_v2 = par_edge->m_v_end;
  253|      0|	unsigned int f1_v3 = par_edge->m_he_next->m_v_end;
  254|       |
  255|      0|	unsigned int f2 = par_edge->m_pair->m_face;
  256|      0|	unsigned int f2_v1 = par_edge->m_pair->m_v_begin;
  257|      0|	unsigned int f2_v2 = par_edge->m_pair->m_v_end;
  258|      0|	unsigned int f2_v3 = par_edge->m_pair->m_he_next->m_v_end;
  259|       |
  260|      0|	m_pFaces[f1]->SetVertex (0, f2_v3);
  261|      0|	m_pFaces[f1]->SetVertex (1, f1_v3);
  262|      0|	m_pFaces[f1]->SetVertex (2, f1_v1);
  263|       |
  264|      0|	m_pFaces[f2]->SetVertex (0, f1_v3);
  265|      0|	m_pFaces[f2]->SetVertex (1, f2_v3);
  266|      0|	m_pFaces[f2]->SetVertex (2, f1_v2);
  267|       |
  268|       |	// update the half edge mesh
  269|      0|	Che_mesh::edge_flip (par_edge);
  270|      0|}
  271|       |
  272|       |void Mesh_half_edge::edge_split (Che_edge *par_edge)
  273|      0|{
  274|      0|}
  275|       |
  276|       |void Mesh_half_edge::edge_contract (Che_edge *edge)
  277|      0|{
  278|      0|	if (edge->m_pair == NULL)
  279|      0|		return;
  280|       |
  281|       |	// update the position of the vertex
  282|      0|	int iv1 = edge->m_v_begin;
  283|      0|	int iv2 = edge->m_v_end;
  284|       |
  285|      0|	m_pVertices[3*iv1]   = (m_pVertices[3*iv1] + m_pVertices[3*iv2])*0.5;
  286|      0|	m_pVertices[3*iv1+1] = (m_pVertices[3*iv1+1] + m_pVertices[3*iv2+1])*0.5;
  287|      0|	m_pVertices[3*iv1+2] = (m_pVertices[3*iv1+2] + m_pVertices[3*iv2+2])*0.5;
  288|       |
  289|       |	// move all the vertices iv2 into iv1
  290|      0|	Che_edge *he = m_edges_vertex[iv2];
  291|      0|	Che_edge *he_walk = he;
  292|      0|	do
  293|      0|	{
  294|      0|		int f_walk = he_walk->m_face;
  295|      0|		for (int j=0; j<m_pFaces[f_walk]->m_nVertices; j++)
  296|      0|		{
  297|      0|			if (m_pFaces[f_walk]->m_pVertices[j] == iv2)
  298|      0|				m_pFaces[f_walk]->m_pVertices[j] = iv1;
  299|      0|		}
  300|      0|		he_walk = he_walk->m_he_next->m_he_next->m_pair;
  301|      0|	} while (he_walk != he);
  302|       |
  303|       |	// delete the faces
  304|      0|	int f1 = edge->m_face;
  305|      0|	int f2 = edge->m_pair->m_face;
  306|       |
  307|      0|	delete m_pFaces[f1];
  308|      0|	m_pFaces[f1] = NULL;
  309|      0|	delete m_pFaces[f2];
  310|      0|	m_pFaces[f2] = NULL;
  311|       |
  312|       |	// update the half edge mesh
  313|      0|	Che_mesh::edge_contract (edge);
  314|      0|}
  315|       |
  316|       |//
  317|       |////////////////////////////////////////////////////////////////////////////////
  318|       |
  319|       |
  320|       |/**
  321|       | * Return the length of an edge.
  322|       | *
  323|       | * \param par_edge : an edge.
  324|       | *
  325|       | * \return the length of the edge.
  326|       | */
  327|       |float Mesh_half_edge::edge_length (Che_edge *par_edge)
  328|      0|{
  329|      0|	if (par_edge == NULL)
  330|      0|		return -1.0;
  331|       |
  332|      0|	int iv1 = par_edge->m_v_begin;
  333|      0|	int iv2 = par_edge->m_v_end;
  334|      0|	vec3 loc_v1, loc_v2, loc_v1v2;
  335|      0|	vec3_init (loc_v1, m_pVertices[3*iv1], m_pVertices[3*iv1+1], m_pVertices[3*iv1+2]);
  336|      0|	vec3_init (loc_v2, m_pVertices[3*iv2], m_pVertices[3*iv2+1], m_pVertices[3*iv2+2]);
  337|      0|	vec3_subtraction (loc_v1v2, loc_v2, loc_v1);
  338|      0|	return vec3_length (loc_v1v2);
  339|      0|}
  340|       |
  341|       |/**
  342|       |*
  343|       |* Get the average edges length.
  344|       |*
  345|       |*/
  346|       |float Mesh_half_edge::get_average_edges_length (void)
  347|      0|{
  348|      0|	int loc_i;
  349|      0|	float loc_length = 0.0;
  350|      0|	for (loc_i=0; loc_i<m_ne; loc_i++)
  351|      0|	{
  352|      0|		Che_edge *loc_e_walk = m_edges[loc_i];
  353|      0|		Vector3d loc_v1 (m_pVertices[3*loc_e_walk->m_v_begin], m_pVertices[3*loc_e_walk->m_v_begin+1], m_pVertices[3*loc_e_walk->m_v_begin+2]);
  354|      0|		Vector3d loc_v2 (m_pVertices[3*loc_e_walk->m_v_end], m_pVertices[3*loc_e_walk->m_v_end+1], m_pVertices[3*loc_e_walk->m_v_end+2]);
  355|      0|		loc_v1 = loc_v2 - loc_v1;
  356|      0|		loc_length += loc_v1.getLength ();
  357|      0|	}
  358|      0|	return loc_length / m_ne;
  359|      0|}
  360|       |
  361|       |/**
  362|       |*
  363|       |* Get the length of the shortest edge.
  364|       |*
  365|       |*/
  366|       |float
  367|       |Mesh_half_edge::get_shortest_edge_length (void)
  368|      0|{
  369|      0|	int loc_i;
  370|      0|	float loc_length = 0.0, loc_length_walk;
  371|      0|	Vector3d loc_v1 (m_pVertices[3*m_edges[0]->m_v_begin], m_pVertices[3*m_edges[0]->m_v_begin+1], m_pVertices[3*m_edges[0]->m_v_begin+2]);
  372|      0|	Vector3d loc_v2 (m_pVertices[3*m_edges[0]->m_v_end], m_pVertices[3*m_edges[0]->m_v_end+1], m_pVertices[3*m_edges[0]->m_v_end+2]);
  373|      0|	loc_v1 = loc_v2 - loc_v1;
  374|      0|	loc_length += loc_v1.getLength ();
  375|       |	
  376|      0|	for (loc_i=0; loc_i<m_ne; loc_i++)
  377|      0|	{
  378|      0|		Che_edge *loc_e_walk = m_edges[loc_i];
  379|      0|		loc_v1.Set (m_pVertices[3*loc_e_walk->m_v_begin], m_pVertices[3*loc_e_walk->m_v_begin+1], m_pVertices[3*loc_e_walk->m_v_begin+2]);
  380|      0|		loc_v2.Set (m_pVertices[3*loc_e_walk->m_v_end], m_pVertices[3*loc_e_walk->m_v_end+1], m_pVertices[3*loc_e_walk->m_v_end+2]);
  381|      0|		loc_v1 = loc_v2 - loc_v1;
  382|      0|		loc_length_walk = loc_v1.getLength ();
  383|      0|		loc_length = (loc_length_walk < loc_length)? loc_length_walk : loc_length;
  384|      0|	}
  385|      0|	return loc_length;
  386|      0|}
  387|       |
  388|       |/**
  389|       |*
  390|       |* Get the number of neighbours of a vertex.
  391|       |*
  392|       |*/
  393|       |int Mesh_half_edge::get_n_neighbours (int par_ivertex)
  394|      0|{
  395|      0|	if (!m_topology_ok[par_ivertex] || m_border[par_ivertex]) return -1;
  396|      0|	int loc_n_neighbours = 0;
  397|      0|	Che_edge *loc_e = m_edges_vertex[par_ivertex];
  398|      0|	Che_edge *loc_e_walk = loc_e;
  399|      0|	do
  400|      0|	{
  401|      0|		loc_n_neighbours++;
  402|      0|		loc_e_walk = loc_e_walk->m_he_next->m_he_next->m_pair;
  403|      0|	} while (loc_e_walk && loc_e_walk != loc_e);
  404|      0|	return loc_n_neighbours;
  405|      0|}
  406|       |
  407|       |// "Discrete differential-geometry operators for triangulated 2-manifolds"
  408|       |// M Meyer, M Desbrun, P Schrder, AH Barr
  409|       |// Visualization and mathematics III, 35-57
  410|       |// http://www.multires.caltech.edu/pubs/diffGeoOps.pdf
  411|       |//
  412|       |//                      u * v
  413|       |// cot(u,v) = ---------------------------
  414|       |//             ||u||^2*||v||^2 - (u*v)^2
  415|       |//
  416|       |static double cotan (vec3 v1, vec3 v2)
  417|      0|{
  418|      0|	double v1dotv2 = vec3_dot_product (v1, v2);
  419|      0|	double denom = sqrt (vec3_dot_product(v1,v1)*vec3_dot_product(v2,v2) - v1dotv2*v1dotv2);
  420|       |
  421|      0|	return (denom == 0.0)? 0.0 : v1dotv2/denom;
  422|      0|}
  423|       |
  424|       |//                * v1
  425|       |//               / \
  426|       |//              /   \
  427|       |//             /     \
  428|       |//            /       \
  429|       |//           /         \
  430|       |//          /  -edge->  \
  431|       |// v_begin *-------------* v_end
  432|       |//          \           /
  433|       |//           \         /
  434|       |//            \       /
  435|       |//             \     /
  436|       |//              \   /
  437|       |//               \ /
  438|       |//                * v2
  439|       |double Mesh_half_edge::cotangent_weight_formula(Che_edge *edge)
  440|      0|{
  441|      0|	double cotangents = 0.;
  442|      0|	vec3 v_begin, v_end, v1, v2, tmp1, tmp2;
  443|       |
  444|      0|	assert (edge && edge->m_pair);
  445|       |
  446|      0|	GetVertex(edge->m_v_begin, v_begin);
  447|      0|	GetVertex(edge->m_v_end, v_end);
  448|      0|	GetVertex(edge->m_he_next->m_v_end, v1);
  449|      0|	GetVertex(edge->m_pair->m_he_next->m_v_end, v2);
  450|       |
  451|      0|	vec3_subtraction (tmp1, v_end, v1);
  452|      0|	vec3_subtraction (tmp2, v_begin, v1);
  453|      0|	cotangents += cotan(tmp1, tmp2);
  454|       |
  455|      0|	vec3_subtraction (tmp1, v_end, v2);
  456|      0|	vec3_subtraction (tmp2, v_begin, v2);
  457|      0|	cotangents += cotan(tmp1, tmp2);
  458|       |
  459|      0|	return .5*cotangents;
  460|      0|}
  461|       |
  462|       |
  463|       |/*
  464|       |*
  465|       |* Dump information about the mesh.
  466|       |*
  467|       |*/
  468|       |void Mesh_half_edge::dump (void)
  469|      0|{
  470|      0|	printf ("%d edges :\n", m_ne);
  471|      0|	for (int i=0; i<m_ne; i++)
  472|      0|		if (m_edges[i])
  473|      0|			m_edges[i]->dump ();
  474|       |
  475|      0|	check_topology ();
  476|      0|	for (int i=0; i<m_nVertices; i++)
  477|      0|		printf ("topology on vertex %d : %d\n", i, m_topology_ok[i]);
  478|       |
  479|      0|}

/workspaces/cg/src/cgmesh/mesh_half_edge.h:
    1|       |#ifndef __MESH_HALF_EDGE_H__
    2|       |#define __MESH_HALF_EDGE_H__
    3|       |
    4|       |#include "mesh.h"
    5|       |#include "half_edge.h"
    6|       |
    7|       |/**
    8|       |* class Mesh_half_edge.
    9|       |*/
   10|       |class Mesh_half_edge : public Mesh, public Che_mesh
   11|       |{
   12|       |	friend class MeshAlgoTensorEvaluator;
   13|       |
   14|       |	friend class MeshAlgoSmoothingLaplacian;
   15|       |	friend class MeshAlgoSmoothingTaubin;
   16|       |
   17|       |	friend class MeshAlgoSubdivisionLoop;
   18|       |	friend class MeshAlgoSubdivisionKarbacher;
   19|       |
   20|       |	friend class SnakeList;
   21|       |	friend class Cregions_vertices;
   22|       |	friend class Cregions_faces;
   23|       |	friend class Cmesh_orientation_pca;
   24|       |	friend class Cset_lines;
   25|       |	
   26|       |	friend class Citerator_half_edge_vertex;
   27|       |	
   28|       |public:
   29|       |	Mesh_half_edge ();//!<  Constructor
   30|       |	Mesh_half_edge (int par_nv, float *par_v, int par_nf, unsigned int *par_f);
   31|       |	Mesh_half_edge (Mesh *pMesh);
   32|       |	Mesh_half_edge (char *par_filename);//!<  Constructor
   33|       |	~Mesh_half_edge ();//!< Destructor
   34|       |
   35|       |	void create_half_edge (void);
   36|       |	Che_edge *get_edge (unsigned int v1, unsigned int v2);
   37|       |
   38|      0|	inline int is_manifold (int i) { check_topology (); return m_topology_ok[i]; };
   39|       |
   40|       |	void export_statistics (char *filename); // export statistics in html format
   41|       |
   42|       |	////////////////////////////////////////////////////////////////////////////////
   43|       |	//
   44|       |	// methods inherited from Che_mesh
   45|       |	//
   46|       |	void edge_flip     (Che_edge *par_edge);
   47|       |	void edge_split    (Che_edge *e);
   48|       |	void edge_contract (Che_edge *e);
   49|       |	//
   50|       |	////////////////////////////////////////////////////////////////////////////////
   51|       |
   52|       |	// Simplification
   53|       |	void simplify (void);
   54|       |
   55|       |	// Dijkstra
   56|       |public:
   57|       |	void dijkstra_shortest_path (int par_source, int par_target, int *par_n, int **par_path);
   58|       |	
   59|       |	// find the local maximal in a neighborough
   60|       |	void search_maximal (float *par_fdata, float par_angle_max);
   61|       |	
   62|       |	// misc
   63|       |	float edge_length (Che_edge *edge);
   64|       |	float get_average_edges_length (void); //<! Get the average edges length.
   65|       |	float get_shortest_edge_length (void); //<! Get the shortest edge length.
   66|       |	int   get_n_neighbours (int par_ivertex); //<! Get the number of neighbours around vertex identified by par_ivertex.
   67|       |	double cotangent_weight_formula(Che_edge *edge);
   68|       |
   69|       |	void dump (void);
   70|       |	
   71|       |private:
   72|       |	// topology
   73|       |	void check_topology (void);
   74|       |	char *m_topology_ok;
   75|       |	
   76|       |	// border
   77|       |	void check_border (void); // check_topology should be called before
   78|       |	char *m_border;
   79|       |};
   80|       |
   81|       |#endif // __MESH_HALF_EDGE_H__

/workspaces/cg/src/cgmesh/mesh_io.cpp:
    1|       |#include <stdio.h>
    2|       |#include <string.h>
    3|       |#include <ctype.h>
    4|       |
    5|       |#ifndef WIN32
    6|       |#include <libgen.h>
    7|       |#endif
    8|       |
    9|       |#include "mesh.h"
   10|       |#include "mesh_io_3ds.h"
   11|       |#include "../cgmath/cgmath.h"
   12|       |#include "endianness.h"
   13|       |
   14|       |int Mesh::load (char *filename)
   15|      2|{
   16|      2|	int res = -1;
   17|      2|	if (!filename)
   18|      0|		return res;
   19|       |
   20|       |	/*if (strcmp (filename+(strlen(filename)-4), ".out") == 0)
   21|       |		LoadBundleOut (0);
   22|       |		else*/
   23|      2|	if (strcmp (filename+(strlen(filename)-4), ".asc") == 0)
   24|      0|	  res = import_asc (filename);
   25|      2|	else if (strcmp (filename+(strlen(filename)-5), ".npts") == 0 ||
   26|      2|		 strcmp (filename+(strlen(filename)-5), ".pset") == 0)
   27|      0|		res = import_pset (filename);
   28|      2|	else if (strcmp (filename+(strlen(filename)-4), ".obj") == 0)
   29|      0|		res = import_obj (filename);
   30|      2|	else if (strcmp(filename + (strlen(filename) - 4), ".stl") == 0)
   31|      2|		res = import_stl(filename);
   32|      0|	else if (strcmp (filename+(strlen(filename)-4), ".3ds") == 0)
   33|      0|		res = import_3ds (filename);
   34|      0|	else if (strcmp (filename+(strlen(filename)-4), ".ifs") == 0)
   35|      0|		res = import_ifs (filename);
   36|      0|	else if (strcmp (filename+(strlen(filename)-4), ".lwo") == 0)
   37|      0|		res = import_lwo (filename);
   38|      0|	else if (strcmp (filename+(strlen(filename)-4), ".off") == 0)
   39|      0|		res = import_off (filename);
   40|      0|	else if (strcmp (filename+(strlen(filename)-4), ".pgm") == 0)
   41|      0|		res = import_pgm (filename);
   42|      0|	else if (strcmp (filename+(strlen(filename)-4), ".pts") == 0)
   43|      0|		res = import_pts (filename);
   44|      0|	else if (strcmp (filename+(strlen(filename)-4), ".ply") == 0)
   45|      0|		res = import_ply (filename);
   46|      0|	else if (strcmp (filename+(strlen(filename)-4), ".u3d") == 0)
   47|      0|		res = import_u3d (filename);
   48|       |
   49|       |	// check coherency
   50|      2|	if (m_nTextureCoordinates == 0)
   51|      2|	{
   52|       |		// desactivate texture coordinates if they are not provided
   53|  1.32k|		for (unsigned int iFace = 0; iFace < m_nFaces; iFace++)
   54|  1.32k|		{
   55|  1.32k|			auto& face = m_pFaces[iFace];
   56|  1.32k|			face->m_bUseTextureCoordinates = false;
   57|  1.32k|		}
   58|      2|	}
   59|       |
   60|      2|	return res;
   61|      2|}
   62|       |
   63|       |int Mesh::save (char *filename)
   64|      0|{
   65|      0|	if (!filename)
   66|      0|		return -1;
   67|       |
   68|      0|	if (strcmp (filename+(strlen(filename)-4), ".asc") == 0)
   69|      0|	  return export_asc (filename);
   70|      0|	else if (strcmp (filename+(strlen(filename)-5), ".npts") == 0 ||
   71|      0|		 strcmp (filename+(strlen(filename)-5), ".pset") == 0)
   72|      0|	  return export_pset (filename);
   73|      0|	else if (strcmp (filename+(strlen(filename)-4), ".obj") == 0)
   74|      0|	  return export_obj (filename);
   75|      0|	else if (strcmp (filename+(strlen(filename)-4), ".dae") == 0)
   76|      0|	  return export_dae (filename);
   77|      0|	else if (strcmp (filename+(strlen(filename)-4), ".cpp") == 0)
   78|      0|	  return export_cpp (filename);
   79|      0|	else if (strcmp (filename+(strlen(filename)-4), ".gts") == 0)
   80|      0|	  return export_gts (filename);
   81|      0|	else if (strcmp (filename+(strlen(filename)-4), ".off") == 0)
   82|      0|	  return export_off (filename);
   83|      0|	else if (strcmp (filename+(strlen(filename)-4), ".pts") == 0)
   84|      0|	  return export_pts (filename);
   85|      0|	else if (strcmp(filename + (strlen(filename) - 4), ".ply") == 0)
   86|      0|		return export_ply(filename);
   87|      0|	else if (strcmp(filename + (strlen(filename) - 4), ".stl") == 0)
   88|      0|		return export_stl(filename);
   89|       |
   90|      0|	return -1;
   91|      0|}
   92|       |
   93|       |//
   94|       |// OBJ
   95|       |//
   96|      0|#define BUFFER_SIZE 4096
   97|       |
   98|       |int Mesh::import_mtl (char *filename, char *path)
   99|      0|{
  100|      0|	FILE *ptr = NULL;
  101|      0|	char filename_full[BUFFER_SIZE];
  102|      0|	if (path)
  103|      0|	{
  104|      0|		sprintf (filename_full, "%s/%s", path, filename);
  105|      0|		ptr = fopen (filename_full, "r");
  106|      0|	}
  107|      0|	else
  108|      0|		ptr = fopen (filename, "r");
  109|      0|	if (!ptr)
  110|      0|		return -1;
  111|       |
  112|      0|	char line[BUFFER_SIZE];
  113|      0|	char prefix[BUFFER_SIZE];
  114|      0|	char name[BUFFER_SIZE];
  115|      0|	unsigned int line_count = 0;
  116|      0|	float r, g, b, a;
  117|      0|	unsigned int dummy;
  118|      0|	unsigned int mi = MATERIAL_NONE;
  119|      0|	MaterialColorExt *mat = NULL;
  120|       |
  121|      0|	while (fgets(line, sizeof(line), ptr) != NULL)
  122|      0|	{
  123|      0|		line_count++;
  124|       |
  125|      0|		if (line[0] == 0 || line[0] == '#') // skip empty lines and comments
  126|      0|			continue;
  127|       |
  128|      0|		if (sscanf(line, " newmtl %s", name) == 1) // new material
  129|      0|		{
  130|      0|			mat = new MaterialColorExt ();
  131|      0|			mi = Material_Add(mat);
  132|      0|			mat->m_pName = strdup(name);
  133|      0|		}
  134|      0|		else if (sscanf(line, " Kd %f %f %f", &r, &g, &b) == 3 && mat) mat->SetDiffuse (r, g, b, 1.);
  135|      0|		else if (sscanf(line, " Ka %f %f %f", &r, &g, &b) == 3 && mat) mat->SetAmbient (r, g, b, 1.);
  136|      0|		else if (sscanf(line, " Ks %f %f %f", &r, &g, &b) == 3 && mat) mat->SetSpecular (r, g, b, 1.);
  137|      0|		else if (sscanf(line, " Ke %f %f %f", &r, &g, &b) == 3 && mat) mat->SetEmission (r, g, b, 1.);
  138|      0|		else if (sscanf(line, " Tf %f %f %f", &r, &g, &b) == 3 && mat) {} // transmissive
  139|      0|		else if (sscanf(line, " d %f", &a) == 1) {} // ...
  140|      0|		else if (sscanf(line, " Tr %f", &a) == 1) {} // ...
  141|      0|		else if (sscanf(line, " Ns %f Ni %f", &r, &g) == 2) {} // ...
  142|      0|		else if (sscanf(line, " Ns %f", &r) == 1) {} // ...
  143|      0|		else if (sscanf(line, " Ni %f", &r) == 1) {} // ...
  144|      0|		else if (sscanf(line, " illum %d", &dummy) == 1) {} // ...
  145|      0|		else if (sscanf(line, " map_Kd %s", name) == 1) { // diffuse texture
  146|      0|			MaterialTexture *tex = new MaterialTexture (name, path);
  147|      0|			tex->SetName (mat->GetName());
  148|      0|			printf ("%d %d\n", tex->GetImage()->m_iWidth, tex->GetImage()->m_iHeight);
  149|      0|			delete mat;
  150|      0|			mat = NULL;
  151|      0|			SetMaterial (mi, tex);
  152|      0|		}
  153|      0|		else if (strcmp(line, "map_Ka ") == 0) {} // ambient texture
  154|      0|		else if (strcmp(line, "map_Ks ") == 0) {} // specular texture
  155|      0|		else if (strcmp(line, "map_bump ") == 0) {} // bumpmap
  156|      0|		else if (strcmp(line, "bump ") == 0) {} // bumpmap
  157|      0|		else
  158|      0|			printf("MTL parse error line %d: '%s'", line_count, line);
  159|      0|	}
  160|       |
  161|      0|	fclose (ptr);
  162|       |
  163|      0|	return 0;
  164|      0|}
  165|       |
  166|       |int Mesh::import_obj (char *filename)
  167|      0|{
  168|      0|	if (filename == NULL)
  169|      0|		return NULL;
  170|       |
  171|      0|	char buffer[BUFFER_SIZE];
  172|      0|	char prefix[BUFFER_SIZE];
  173|       |
  174|      0|	FILE *file = fopen (filename, "r");
  175|      0|	if (file == NULL)
  176|      0|	{
  177|      0|		printf ("Unable to open %s", filename);
  178|      0|		return -1;
  179|      0|	}
  180|       |	
  181|      0|	unsigned int nPoints=0;
  182|      0|	unsigned int nTexCoords=0;
  183|      0|	unsigned int nFaces=0;
  184|      0|	char mtlfile[BUFFER_SIZE];
  185|      0|	mtlfile[0] = '\0';
  186|      0|	while (fgets (buffer, BUFFER_SIZE, file))
  187|      0|	{
  188|      0|		if (sscanf(buffer, "%s", prefix) != -1)
  189|      0|		{
  190|      0|			if (strcmp(prefix, "mtllib") == 0)
  191|      0|				sscanf(buffer, "%s %s", prefix, mtlfile);
  192|      0|			else if (strcmp(prefix, "v") == 0)
  193|      0|				nPoints++;
  194|      0|			else if (strcmp(prefix, "vt") == 0)
  195|      0|				nTexCoords++;
  196|      0|			else if (strcmp(prefix, "f") == 0)
  197|      0|				nFaces++;
  198|      0|		}
  199|      0|	}
  200|       |	//printf ("%d %d %d\n", nPoints, nTexCoords, nFaces);
  201|      0|	rewind (file);
  202|      0|	Init (nPoints, nFaces);
  203|      0|#ifndef WIN32
  204|      0|	if (strlen (mtlfile) != 0)
  205|      0|	{
  206|      0|		import_mtl (mtlfile, dirname(filename)); // todo : find equivalent for windows
  207|      0|	}
  208|      0|#endif
  209|      0|	if (nTexCoords)
  210|      0|	{
  211|      0|		m_nTextureCoordinates = nTexCoords;
  212|      0|		m_pTextureCoordinates = new float[2*nTexCoords];
  213|      0|	}
  214|      0|	int ipoint = 0, itexcoord = 0, iface = 0;
  215|      0|	int usemtl = -1;
  216|      0|	while (fgets (buffer, BUFFER_SIZE, file))
  217|      0|	{
  218|      0|		if (sscanf(buffer, "%s", prefix) == -1)
  219|      0|			continue;
  220|      0|		if (strcmp (prefix, "usemtl") == 0)
  221|      0|		{
  222|      0|			char mtl_name[BUFFER_SIZE];
  223|      0|			sscanf (buffer, "%s %s", prefix, mtl_name);
  224|      0|			usemtl = GetMaterialId (mtl_name);
  225|      0|		}
  226|      0|		else if (strcmp (prefix, "v") == 0)
  227|      0|		{
  228|      0|			sscanf (buffer, "%s %f %f %f", prefix,
  229|      0|				&m_pVertices[3*ipoint],
  230|      0|				&m_pVertices[3*ipoint+1],
  231|      0|				&m_pVertices[3*ipoint+2]);
  232|      0|			ipoint++;
  233|      0|		}
  234|      0|		else if (strcmp (prefix, "vt") == 0)
  235|      0|		{
  236|      0|			sscanf (buffer, "%s %f %f", prefix,
  237|      0|				&m_pTextureCoordinates[2*itexcoord],
  238|      0|				&m_pTextureCoordinates[2*itexcoord+1]);
  239|      0|			itexcoord++;
  240|      0|		}
  241|      0|		else if (strcmp (prefix, "f") == 0)
  242|      0|		{
  243|       |			// get the number of indices
  244|      0|			unsigned int fvn = 0;
  245|      0|			char *s = buffer + sizeof("f ") - 1;
  246|      0|			while (*s != 0) {
  247|      0|				while (*s && isspace(*s))
  248|      0|					s++;
  249|      0|				while (*s && !isspace(*s))
  250|      0|					s++;
  251|      0|				while (*s && isspace(*s))
  252|      0|					s++;
  253|      0|				fvn++;
  254|      0|			}
  255|      0|			Face *pFace = m_pFaces[iface];
  256|      0|			if (!pFace)
  257|      0|				pFace = new Face ();
  258|       |
  259|      0|			if (fvn != 3)
  260|      0|				pFace->SetNVertices (fvn);
  261|       |			
  262|       |			// parse the indices
  263|      0|			fvn = 0;
  264|      0|			s = buffer + sizeof("f ") - 1;
  265|      0|			while (*s != 0) {
  266|      0|				int i0, i1, i2;
  267|      0|				int h0, h1, h2;
  268|       |				
  269|      0|				h0 = h1 = h2 = 0;
  270|      0|				i0 = i1 = i2 = 0;
  271|       |
  272|      0|				if (sscanf(s, "%d/%d/%d", &i0, &i1, &i2) == 3)
  273|      0|					h0 = h1 = h2 = 1;
  274|      0|				else if (sscanf(s, "%d/%d", &i0, &i1) == 2)
  275|      0|					h0 = h1 = 1;
  276|      0|				else if (sscanf(s, "%d//%d", &i0, &i2) == 2)
  277|      0|					h0 = h2 = 1;
  278|      0|				else if (sscanf(s, "/%d/%d", &i1, &i2) == 2)
  279|      0|					h1 = h2 = 1;
  280|      0|				else if (sscanf(s, "%d", &i0) == 1)
  281|      0|					h0 = 1;
  282|      0|				else if (sscanf(s, "/%d", &i1) == 1)
  283|      0|					h1 = 1;
  284|      0|				else if (sscanf(s, "//%d", &i2) == 1)
  285|      0|					h2 = 1;
  286|       |		
  287|      0|				while (*s && isspace(*s))
  288|      0|					s++;
  289|      0|				while (*s && !isspace(*s))
  290|      0|					s++;
  291|      0|				while (*s && isspace(*s))
  292|      0|					s++;
  293|       |
  294|      0|				if (!h0)
  295|      0|					continue;
  296|       |
  297|      0|				if (i0 < 0)
  298|      0|					i0 = m_nVertices + i0;
  299|      0|				else
  300|      0|					i0--;
  301|       |				
  302|      0|				if (i0 < 0 || (unsigned int) i0 >= m_nVertices) {
  303|      0|					printf ("invalid vertex index %d (vn=%d)\n", i0, m_nVertices);
  304|      0|					continue;
  305|      0|				}
  306|       |
  307|      0|				pFace->SetVertex (fvn, i0);
  308|       |
  309|      0|				if (h1)
  310|      0|				{
  311|      0|					if (i1 < 0)
  312|      0|						i1 = m_nTextureCoordinates + i1;
  313|      0|					else
  314|      0|						i1--;
  315|      0|					pFace->m_bUseTextureCoordinates = true;
  316|      0|					pFace->ActivateTextureCoordinatesIndices();
  317|      0|					pFace->ActivateTextureCoordinates();
  318|      0|					pFace->SetTexCoord (fvn, i1);
  319|      0|				}
  320|      0|				fvn++;
  321|      0|			}
  322|       |
  323|       |			// material
  324|      0|			if (usemtl != -1)
  325|      0|				pFace->m_iMaterialId = usemtl;
  326|       |
  327|      0|			m_pFaces[iface] = pFace;
  328|      0|			iface++;
  329|      0|		}
  330|      0|	}
  331|      0|	fclose (file);
  332|       |
  333|      0|	return 0;
  334|      0|}
  335|       |
  336|       |//
  337|       |//
  338|       |//
  339|       |int Mesh::export_obj (char *filename)
  340|      0|{
  341|      0|	FILE *fp;
  342|      0|	unsigned int i;
  343|       |
  344|      0|	fp = fopen(filename,"w");
  345|      0|	if (fp == NULL)
  346|      0|		return -1;
  347|       |
  348|       |	// some comments
  349|      0|	fprintf (fp, "#\n");
  350|      0|	fprintf (fp, "# number of vertices : %d\n", m_nVertices);
  351|      0|	fprintf (fp, "# number of faces    : %d\n", m_nFaces);
  352|      0|	fprintf (fp, "#\n");
  353|      0|	fprintf (fp, "\n");
  354|       |
  355|       |	// materials
  356|      0|	char *filematname = NULL;
  357|      0|	if (m_nMaterials > 0)
  358|      0|	{
  359|      0|		filematname = strdup (filename);
  360|      0|		sprintf (filematname+strlen (filematname)-3, "%s", "mtl");
  361|       |
  362|      0|		char *s = strrchr(filematname, '/');
  363|      0|		fprintf (fp, "mtllib %s\n\n", (s != NULL)? &s[1]:filematname);
  364|      0|	}
  365|       |
  366|       |	//
  367|       |	// vertices
  368|       |	//
  369|      0|	for (i = 0; i < m_nVertices; i++)
  370|      0|		fprintf (fp, "v %f %f %f\n",
  371|      0|			 m_pVertices[3*i], m_pVertices[3*i+1], m_pVertices[3*i+2]);
  372|      0|	if (0 && m_pVertexNormals)
  373|      0|	{
  374|      0|		for (i=0; i<m_nVertices; i++)
  375|      0|		{
  376|      0|			fprintf (fp, "vn %f %f %f\n",
  377|      0|				 m_pVertexNormals[3*i],
  378|      0|				 m_pVertexNormals[3*i+1],
  379|      0|				 m_pVertexNormals[3*i+2]);
  380|      0|		}
  381|      0|	}
  382|       |	
  383|      0|	if (m_pTextureCoordinates)
  384|      0|	{
  385|      0|		for (i=0; i<m_nTextureCoordinates; i++)
  386|      0|			fprintf (fp, "vt %f %f\n", m_pTextureCoordinates[2*i], m_pTextureCoordinates[2*i+1]);
  387|      0|	}
  388|       |
  389|       |	//
  390|       |	// faces
  391|       |	//
  392|      0|	unsigned int i_current_material = MATERIAL_NONE;
  393|      0|	for (i = 0; i <m_nFaces; i++)
  394|      0|	{
  395|      0|		if (!m_pFaces[i])
  396|      0|			continue;
  397|       |		
  398|      0|		if (m_pFaces[i]->GetMaterialId () != MATERIAL_NONE &&
  399|      0|		    m_pFaces[i]->GetMaterialId () != i_current_material)
  400|      0|		{
  401|      0|			fprintf (fp, "usemtl %s\n", m_pMaterials[m_pFaces[i]->GetMaterialId ()]->GetName());
  402|      0|			i_current_material = m_pFaces[i]->GetMaterialId ();
  403|      0|		}
  404|       |
  405|      0|		if (0 && m_pFaces[i]->m_pTextureCoordinatesIndices)//m_pFaces[i]->m_bUseTextureCoordinates)
  406|      0|		{
  407|      0|			for (unsigned int j=0; j<m_pFaces[i]->m_nVertices; j++)
  408|      0|			{
  409|       |				//fprintf (fp, "vt %f %f\n",
  410|       |				//	 m_pTextureCoordinates[2*m_pFaces[i]->m_pTextureCoordinates[j]],
  411|       |				//	 m_pTextureCoordinates[2*m_pFaces[i]->m_pTextureCoordinates[j]+1]);
  412|      0|				fprintf (fp, "vt %f %f\n",
  413|      0|					 m_pFaces[i]->m_pTextureCoordinates[2*j],
  414|      0|					 m_pFaces[i]->m_pTextureCoordinates[2*j+1]);
  415|      0|			}
  416|      0|		}
  417|       |
  418|      0|		fprintf (fp, "f ");
  419|      0|		for (unsigned int j=0; j<m_pFaces[i]->m_nVertices; j++)
  420|      0|		{
  421|       |			// vertex
  422|      0|			fprintf (fp, "%d", 1+m_pFaces[i]->m_pVertices[j]);
  423|       |
  424|       |			// texture coordinates
  425|      0|			if (m_pFaces[i]->m_bUseTextureCoordinates && m_pFaces[i]->m_pTextureCoordinatesIndices)
  426|      0|				fprintf (fp, "/%d", 1+m_pFaces[i]->m_pTextureCoordinatesIndices[j]);//m_pFaces[i]->m_nVertices);
  427|       |
  428|       |			// normal
  429|      0|			if (0 && m_pVertexNormals)
  430|      0|			{
  431|      0|				if (!m_pFaces[i]->m_bUseTextureCoordinates)
  432|      0|					fprintf (fp, "/");
  433|      0|				fprintf (fp, "/%d\n", m_pFaces[i]->m_pVertices[j]);
  434|      0|			}
  435|       |			
  436|      0|			fprintf (fp, " ");
  437|      0|		}
  438|      0|		fprintf (fp, "\n");
  439|      0|	}
  440|       |	
  441|      0|	fclose (fp);
  442|       |
  443|       |	//
  444|       |	// materials
  445|       |	//
  446|      0|	if (m_nMaterials > 0)
  447|      0|	{
  448|      0|		fp = fopen(filematname,"w");
  449|      0|		if (fp == NULL)
  450|      0|			return -1;
  451|       |		
  452|      0|		fprintf (fp, "\n");
  453|      0|		fprintf (fp, "# Wavefront material file\n");
  454|      0|		fprintf (fp, "\n");
  455|       |
  456|      0|		for (unsigned int i=0; i<m_nMaterials; i++)
  457|      0|		{
  458|      0|			Material *pMaterial = m_pMaterials[i];
  459|      0|			if (!pMaterial)
  460|      0|				continue;
  461|      0|			switch (pMaterial->GetType ())
  462|      0|			{
  463|      0|			case MATERIAL_COLOR:
  464|      0|			{
  465|      0|				MaterialColor *pMaterialColor = dynamic_cast<MaterialColor*> (pMaterial);
  466|      0|				fprintf (fp, "newmtl material_%d\n", i);
  467|      0|				fprintf (fp, "Ka 0.200000 0.200000 0.200000\n");
  468|      0|				fprintf (fp, "Kd %f %f %f\n",
  469|      0|					 pMaterialColor->m_r/255., pMaterialColor->m_g/255., pMaterialColor->m_b/255.);
  470|      0|				fprintf (fp, "Ks 1.000000 1.000000 1.000000\n");
  471|      0|				fprintf (fp, "Tr 1.000000\n");
  472|      0|				fprintf (fp, "illum 2\n");
  473|      0|				fprintf (fp, "Ns 0.000000\n");
  474|      0|				fprintf (fp, "\n");
  475|      0|			}
  476|      0|			break;
  477|      0|			case MATERIAL_TEXTURE:
  478|      0|			{
  479|      0|				MaterialTexture *pMaterialTexture = dynamic_cast<MaterialTexture*> (pMaterial);
  480|      0|				fprintf (fp, "newmtl %s\n", pMaterialTexture->GetName ());
  481|      0|				fprintf (fp, "Ka 0.000000 0.000000 0.000000\n");
  482|      0|				fprintf (fp, "Kd 0.000000 0.000000 0.000000\n");
  483|      0|				fprintf (fp, "Ks 1.000000 1.000000 1.000000\n");
  484|      0|				fprintf (fp, "Tr 1.000000\n");
  485|      0|				fprintf (fp, "illum 2\n");
  486|      0|				fprintf (fp, "Ns 0.000000\n");
  487|      0|				fprintf (fp, "map_Kd %s\n", pMaterialTexture->GetFilename());
  488|      0|				fprintf (fp, "\n");
  489|      0|			}
  490|      0|			break;
  491|      0|			default:
  492|      0|				break;
  493|      0|			}
  494|      0|		}
  495|       |		
  496|      0|		fclose (fp);
  497|       |
  498|      0|		free (filematname);
  499|      0|	}
  500|       |
  501|      0|	return 0;
  502|      0|}
  503|       |
  504|       |//
  505|       |// ASC
  506|       |//
  507|       |int Mesh::import_asc (char *filename)
  508|      0|{
  509|      0|	if (filename == NULL)
  510|      0|		return -1;
  511|       |
  512|      0|	FILE *file = fopen (filename, "r");
  513|      0|	if (file == NULL)
  514|      0|	{
  515|      0|		printf ("[3DViewer] Unable to open %s", filename);
  516|      0|		return -1;
  517|      0|	}
  518|       |	
  519|      0|	float vx, vy, vz, nx, ny, nz;
  520|      0|	int r, g, b;
  521|      0|	unsigned int nPoints=0;
  522|      0|	while (!feof (file))
  523|      0|	{
  524|      0|		fscanf (file, "%f %f %f %d %d %d %f %f %f\n", &vx, &vy, &vz, &r, &g, &b, &nx, &ny, &nz);
  525|      0|		nPoints++;
  526|      0|	}
  527|       |	//nPoints--;
  528|      0|	rewind (file);
  529|      0|	Init (nPoints, 0);
  530|      0|	InitVertexColors ();
  531|      0|	unsigned int i=0;
  532|      0|	while (!feof (file))
  533|      0|	{
  534|      0|		fscanf (file, "%f %f %f %d %d %d %f %f %f\n", &vx, &vy, &vz, &r, &g, &b, &nx, &ny, &nz);
  535|      0|		m_pVertices[3*i+0] = vx;
  536|      0|		m_pVertices[3*i+1] = vy;
  537|      0|		m_pVertices[3*i+2] = vz;
  538|      0|		m_pVertexColors[3*i+0]	= r/255.;
  539|      0|		m_pVertexColors[3*i+1]	= g/255.;
  540|      0|		m_pVertexColors[3*i+2]	= b/255.;
  541|      0|		m_pVertexNormals[3*i+0] = nx;
  542|      0|		m_pVertexNormals[3*i+1] = ny;
  543|      0|		m_pVertexNormals[3*i+2] = nz;
  544|      0|		i++;
  545|      0|	}
  546|      0|	fclose (file);
  547|       |//	triangulate_regular_heightfield (640, 480);
  548|      0|	return 0;
  549|      0|}
  550|       |
  551|       |int Mesh::export_asc (char *filename)
  552|      0|{
  553|      0|	FILE *ptr = fopen (filename, "w");
  554|      0|	printf ("ASC : %d\n", m_nVertices);
  555|      0|	unsigned char r=0, g=0, b=0;
  556|      0|	if (m_pVertexColors)
  557|      0|	{
  558|      0|		for (unsigned int i=0; i<m_nVertices; i++)
  559|      0|		{
  560|      0|			r = (unsigned char)(255.*m_pVertexColors[3*i+0]);
  561|      0|			g = (unsigned char)(255.*m_pVertexColors[3*i+1]);
  562|      0|			b = (unsigned char)(255.*m_pVertexColors[3*i+2]);
  563|      0|			fprintf (ptr, "%f %f %f %d %d %d %f %f %f\n",
  564|      0|				 m_pVertices[3*i+0], m_pVertices[3*i+1], m_pVertices[3*i+2],
  565|      0|				 r, g, b,
  566|      0|				 m_pVertexNormals[3*i+0], m_pVertexNormals[3*i+1], m_pVertexNormals[3*i+2]
  567|      0|				);
  568|      0|		}
  569|      0|	}
  570|      0|	else
  571|      0|	{
  572|      0|		for (unsigned int i=0; i<m_nVertices; i++)
  573|      0|		{
  574|      0|			fprintf (ptr, "%f %f %f %d %d %d %f %f %f\n",
  575|      0|				 m_pVertices[3*i+0], m_pVertices[3*i+1], m_pVertices[3*i+2],
  576|      0|				 r, g, b,
  577|      0|				 m_pVertexNormals[3*i+0], m_pVertexNormals[3*i+1], m_pVertexNormals[3*i+2]
  578|      0|				);
  579|      0|		}
  580|      0|	}
  581|       |
  582|      0|	fclose (ptr);
  583|       |
  584|      0|	return 0;
  585|      0|}
  586|       |
  587|       |//
  588|       |// PSET
  589|       |//
  590|       |int Mesh::import_pset (char *filename)
  591|      0|{
  592|      0|	if (filename == NULL)
  593|      0|		return -1;
  594|       |
  595|      0|	FILE *file = fopen (filename, "r");
  596|      0|	if (file == NULL)
  597|      0|	{
  598|      0|		printf ("[3DViewer] Unable to open %s", filename);
  599|      0|		return -1;
  600|      0|	}
  601|       |	
  602|      0|	float vx, vy, vz, nx, ny, nz;
  603|      0|	unsigned int nPoints=0;
  604|      0|	while (!feof (file))
  605|      0|	{
  606|      0|		fscanf (file, "%f %f %f %f %f %f\n", &vx, &vy, &vz, &nx, &ny, &nz);
  607|      0|		nPoints++;
  608|      0|	}
  609|       |//	nPoints--;
  610|      0|	rewind (file);
  611|      0|	printf ("%d points\n", nPoints);
  612|      0|	Init (nPoints, 0);
  613|      0|	unsigned int i=0;
  614|      0|	while (!feof (file))
  615|      0|	{
  616|      0|		fscanf (file, "%f %f %f %f %f %f\n",
  617|      0|			&m_pVertices[i],
  618|      0|			&m_pVertices[i+1],
  619|      0|			&m_pVertices[i+2],
  620|      0|			&m_pVertexNormals[i],
  621|      0|			&m_pVertexNormals[i+1],
  622|      0|			&m_pVertexNormals[i+2]);
  623|      0|		i+=3;
  624|      0|	}
  625|      0|	fclose (file);
  626|       |
  627|      0|	return 0;
  628|      0|}
  629|       |
  630|       |int Mesh::export_pset (char *filename)
  631|      0|{
  632|      0|	FILE *ptr = fopen (filename, "w");
  633|       |	
  634|      0|	for (unsigned int i=0; i<m_nVertices; i++)
  635|      0|	{
  636|      0|		fprintf (ptr, "%f %f %f %f %f %f\n",
  637|      0|			 m_pVertices[3*i+0], m_pVertices[3*i+1], m_pVertices[3*i+2],
  638|      0|			 m_pVertexNormals[3*i+0], m_pVertexNormals[3*i+1], m_pVertexNormals[3*i+2]
  639|      0|			 );
  640|      0|	}
  641|       |
  642|      0|	fclose (ptr);
  643|       |
  644|      0|	return 0;
  645|      0|}
  646|       |
  647|       |
  648|       |
  649|       |//
  650|       |// DAE
  651|       |//
  652|       |int Mesh::export_dae (char *filename)
  653|      0|{
  654|      0|	FILE *ptr = fopen (filename, "w");
  655|       |
  656|       |	// header
  657|      0|	char *header = (char*)
  658|      0|		"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
  659|      0|		"<COLLADA xmlns=\"http://www.collada.org/2005/11/COLLADASchema\" version=\"1.4.1\">\n"
  660|      0|		"  <asset>\n"
  661|      0|		"    <contributor>\n"
  662|      0|		"      <author>Author</author>\n"
  663|      0|		"      <authoring_tool>Authoring Tool</authoring_tool>\n"
  664|      0|		"      <comments>Comments</comments>\n"
  665|      0|		"    </contributor>\n"
  666|      0|		"    <created></created>\n"
  667|      0|		"    <modified></modified>\n"
  668|      0|		"    <unit meter=\"0.01\" name=\"centimeter\"/>\n"
  669|      0|		"    <up_axis>Z_UP</up_axis>\n"
  670|      0|		"  </asset>\n";
  671|      0|	fprintf (ptr, "%s", header);
  672|       |
  673|       |	// effects
  674|      0|	fprintf (ptr, "   <library_effects>\n");
  675|      0|	fprintf (ptr, "      <effect id=\"mat0_fx\" name=\"mat0_fx\">\n");
  676|      0|	fprintf (ptr, "         <profile_COMMON>\n");
  677|      0|	fprintf (ptr, "           <newparam sid=\"test_jpg-surface\">\n");
  678|      0|	fprintf (ptr, "               <surface type=\"2D\">\n");
  679|      0|	fprintf (ptr, "                  <init_from>test_jpg-img</init_from>\n");
  680|      0|	fprintf (ptr, "               </surface>\n");
  681|      0|	fprintf (ptr, "            </newparam>\n");
  682|      0|	fprintf (ptr, "            <newparam sid=\"test_jpg-sampler\">\n");
  683|      0|	fprintf (ptr, "               <sampler2D>\n");
  684|      0|	fprintf (ptr, "                  <source>test_jpg-surface</source>\n");
  685|      0|	fprintf (ptr, "               </sampler2D>\n");
  686|      0|	fprintf (ptr, "            </newparam>\n");
  687|      0|	fprintf (ptr, "            <technique sid=\"COMMON\">\n");
  688|      0|	fprintf (ptr, "               <phong>\n");
  689|      0|	fprintf (ptr, "                  <emission><color>0.000000 0.000000 0.000000 1</color></emission>\n");
  690|      0|	fprintf (ptr, "                  <ambient><color>0.000000 0.000000 0.000000 1</color></ambient>\n");
  691|      0|	fprintf (ptr, "                  <diffuse><texture texture=\"test_jpg-sampler\" texcoord=\"CHANNEL1\"/></diffuse>\n");
  692|      0|	fprintf (ptr, "                  <specular><color>0.330000 0.330000 0.330000 1</color></specular>\n");
  693|      0|	fprintf (ptr, "                  <shininess><float>20.000000</float></shininess>\n");
  694|      0|	fprintf (ptr, "                  <reflectivity><float>0.100000</float></reflectivity>\n");
  695|      0|	fprintf (ptr, "                  <transparent><color>1 1 1 1</color></transparent>\n");
  696|      0|	fprintf (ptr, "                  <transparency><float>0.000000</float></transparency>\n");
  697|      0|	fprintf (ptr, "               </phong>\n");
  698|      0|	fprintf (ptr, "            </technique>\n");
  699|      0|	fprintf (ptr, "         </profile_COMMON>\n");
  700|      0|	fprintf (ptr, "      </effect>\n");
  701|      0|	fprintf (ptr, "   </library_effects>\n");
  702|       |
  703|       |	// library images
  704|      0|	fprintf (ptr, "  <library_images>\n");
  705|      0|	fprintf (ptr, "   <image id=\"test_jpg-img\" name=\"test_jpg-img\">\n");
  706|      0|	fprintf (ptr, "      <init_from>./test.jpg</init_from>\n");
  707|      0|	fprintf (ptr, "    </image>\n");
  708|      0|	fprintf (ptr, "  </library_images>\n");
  709|       |
  710|       |	// library materials
  711|      0|	fprintf (ptr, "   <library_materials>\n");
  712|      0|	fprintf (ptr, "      <material id=\"mat0\" name=\"mat0\">\n");
  713|      0|	fprintf (ptr, "         <instance_effect url=\"#mat0_fx\"/>\n");
  714|      0|	fprintf (ptr, "      </material>\n");
  715|      0|	fprintf (ptr, "   </library_materials>\n");
  716|       |
  717|       |	// library geometries
  718|      0|	fprintf (ptr, "  <library_geometries>\n");
  719|      0|	fprintf (ptr, "    <geometry id=\"GEO01-mesh\" name=\"GEO01\">\n");
  720|      0|	fprintf (ptr, "      <mesh>\n");
  721|      0|	fprintf (ptr, "        <source id=\"GEO01-Position\">\n");
  722|      0|	fprintf (ptr, "          <float_array id=\"GEO01-Position-array\" count=\"%d\">", 3*m_nVertices);
  723|      0|	for (int i=0; i<3*m_nVertices; i++)
  724|      0|		fprintf (ptr, "%f ", m_pVertices[i]);
  725|      0|	fprintf (ptr, "</float_array>\n");
  726|      0|	fprintf (ptr, "          <technique_common>\n\n");
  727|      0|	fprintf (ptr, "            <accessor source=\"#GEO01-Position-array\" count=\"%d\" stride=\"3\">\n", m_nVertices);
  728|      0|	fprintf (ptr, "              <param name=\"X\" type=\"float\"/>\n");
  729|      0|	fprintf (ptr, "              <param name=\"Y\" type=\"float\"/>\n");
  730|      0|	fprintf (ptr, "              <param name=\"Z\" type=\"float\"/>\n");
  731|      0|	fprintf (ptr, "            </accessor>\n");
  732|      0|	fprintf (ptr, "          </technique_common>\n");
  733|      0|	fprintf (ptr, "        </source>\n");
  734|      0|	fprintf (ptr, "        <source id=\"GEO01-UV\">\n");
  735|      0|	fprintf (ptr, "          <float_array id=\"GEO01-UV-array\" count=\"%d\">", 2*m_nTextureCoordinates);
  736|      0|	for (int i=0; i<2*m_nTextureCoordinates; i++)
  737|      0|		fprintf (ptr, "%f ", m_pTextureCoordinates[i]);
  738|      0|	fprintf (ptr, "</float_array>\n");
  739|      0|	fprintf (ptr, "          <technique_common>\n");
  740|      0|	fprintf (ptr, "            <accessor source=\"#GEO01-UV-array\" count=\"%d\" stride=\"2\">\n", m_nTextureCoordinates);
  741|      0|	fprintf (ptr, "              <param name=\"S\" type=\"float\"/>\n");
  742|      0|	fprintf (ptr, "              <param name=\"T\" type=\"float\"/>\n");
  743|      0|	fprintf (ptr, "            </accessor>\n");
  744|      0|	fprintf (ptr, "          </technique_common>\n");
  745|      0|	fprintf (ptr, "        </source>\n");
  746|      0|	fprintf (ptr, "        <vertices id=\"GEO01-Vertex\">\n");
  747|      0|	fprintf (ptr, "          <input semantic=\"POSITION\" source=\"#GEO01-Position\"/>\n");
  748|      0|	fprintf (ptr, "        </vertices>\n");
  749|      0|	fprintf (ptr, "        <triangles material=\"mat0\" count=\"%d\">\n", m_nFaces);
  750|      0|	fprintf (ptr, "          <input offset=\"0\" semantic=\"VERTEX\" source=\"#GEO01-Vertex\"/>\n");
  751|      0|	fprintf (ptr, "          <input offset=\"1\" semantic=\"TEXCOORD\" source=\"#GEO01-UV\"/>\n");
  752|      0|	fprintf (ptr, "          <p>");
  753|      0|	for (int i=0; i<m_nFaces; i++)
  754|      0|		for (int j=0; j<m_pFaces[i]->m_nVertices; j++)
  755|      0|			fprintf (ptr, "%d %d ", m_pFaces[i]->m_pVertices[j], m_pFaces[i]->m_pTextureCoordinatesIndices[j]);
  756|      0|	fprintf (ptr, "</p>\n");
  757|      0|	fprintf (ptr, "        </triangles>\n");
  758|      0|	fprintf (ptr, "      </mesh>\n");
  759|      0|	fprintf (ptr, "    </geometry>\n");
  760|      0|	fprintf (ptr, "  </library_geometries>\n");
  761|       |
  762|       |	// library visaul scenes
  763|      0|	fprintf (ptr, "  <library_visual_scenes>\n");
  764|      0|	fprintf (ptr, "    <visual_scene id=\"Scene\" name=\"Scene\">\n");
  765|      0|	fprintf (ptr, "     <node id=\"GEO01-node\" name=\"GEO01\" type=\"NODE\">\n");
  766|      0|	fprintf (ptr, "        <instance_geometry url=\"#GEO01-mesh\">\n");
  767|      0|	fprintf (ptr, "			<bind_material>\n");
  768|      0|	fprintf (ptr, "		                <technique_common>\n");
  769|      0|	fprintf (ptr, "                                 <instance_material symbol=\"mat0\" target=\"#mat0\">\n");
  770|      0|	fprintf (ptr, "                                          <bind_vertex_input input_semantic=\"TEXCOORD\" input_set=\"1\" semantic=\"CHANNEL1\"/>\n");
  771|      0|	fprintf (ptr, "                                 </instance_material>\n");
  772|      0|	fprintf (ptr, "                          </technique_common>\n");
  773|      0|	fprintf (ptr, "                 </bind_material>\n");
  774|      0|	fprintf (ptr, "        </instance_geometry>\n");
  775|      0|	fprintf (ptr, "      </node>\n");
  776|      0|	fprintf (ptr, "    </visual_scene>\n");
  777|      0|	fprintf (ptr, "  </library_visual_scenes>\n");
  778|      0|	fprintf (ptr, "  <scene>\n");
  779|      0|	fprintf (ptr, "    <instance_visual_scene url=\"#Scene\"/>\n");
  780|      0|	fprintf (ptr, "  </scene>\n");
  781|      0|	fprintf (ptr, "</COLLADA>\n");
  782|       |	
  783|      0|	fclose (ptr);
  784|       |
  785|      0|	return 0;
  786|      0|}
  787|       |
  788|       |//
  789|       |// cpp
  790|       |//
  791|       |int Mesh::export_cpp  (char *filename)
  792|      0|{
  793|      0|	int i;
  794|      0|  FILE *ptr = fopen (filename, "w");
  795|      0|  if (!ptr)
  796|      0|    {
  797|      0|      printf ("unable to open %s\n", filename);
  798|      0|      return false;
  799|      0|    }
  800|      0|  char *modelname = strdup (filename);
  801|      0|  for (i=strlen (modelname); modelname[i]!='.' && i>0; i--);
  802|      0|  if (i!=0 && modelname[i-1]!='/') modelname[i] = '\0';
  803|      0|  for (i=strlen (modelname); modelname[i]!='/' && i>=0; i--);
  804|      0|  if (i!=-1) modelname = &modelname[i+1];
  805|      0|  if (strlen(modelname)==0)
  806|      0|    {
  807|      0|      printf ("unable to extract name of the file\n");
  808|      0|      return false;
  809|      0|    }
  810|       |
  811|      0|  fprintf (ptr, "/* model coming from %s */\n\n", filename);
  812|       |
  813|       |  /* n_vertices & n_faces */
  814|      0|  int n_vertices = m_nVertices;
  815|      0|  int n_faces    = m_nFaces;
  816|      0|  fprintf (ptr, "static int %s_n_vertices = %d;\n", modelname, n_vertices);
  817|      0|  fprintf (ptr, "static int %s_n_faces = %d;\n\n", modelname, n_faces);
  818|       |  
  819|       |  /* vertices */
  820|      0|  float x, y, z;
  821|      0|  fprintf (ptr, "static float %s_vertices[] = {", modelname);
  822|      0|  x = m_pVertices[0];
  823|      0|  y = m_pVertices[1];
  824|      0|  z = m_pVertices[2];
  825|      0|  fprintf (ptr, "%f, %f, %f,\n", x, y, z);
  826|      0|  for (i=1; i<n_vertices-1; i++)
  827|      0|    {
  828|      0|  x = m_pVertices[3*i];
  829|      0|  y = m_pVertices[3*i+1];
  830|      0|  z = m_pVertices[3*i+2];
  831|      0|      fprintf (ptr, "\t\t%f, %f, %f,\n", x, y, z);
  832|      0|    }
  833|      0|  x = m_pVertices[3*i];
  834|      0|  y = m_pVertices[3*i+1];
  835|      0|  z = m_pVertices[3*i+2];
  836|      0|  fprintf (ptr, "\t\t%f, %f, %f};\n\n", x, y, z);
  837|       |
  838|       |  /* faces */
  839|      0|  int a, b, c;
  840|      0|  fprintf (ptr, "static int %s_faces[] = {", modelname);
  841|      0|  a = m_pFaces[0]->GetVertex(0);
  842|      0|  b = m_pFaces[0]->GetVertex(1);
  843|      0|  c = m_pFaces[0]->GetVertex(2);
  844|      0|  fprintf (ptr, "%d, %d, %d,\n", a, b, c);
  845|      0|  for (i=1; i<n_faces-1; i++)
  846|      0|    {
  847|      0|  a = m_pFaces[i]->GetVertex(0);
  848|      0|  b = m_pFaces[i]->GetVertex(1);
  849|      0|  c = m_pFaces[i]->GetVertex(2);
  850|      0|      fprintf (ptr, "\t\t%d, %d, %d,\n", a, b , c);
  851|      0|    }
  852|      0|  a = m_pFaces[i]->GetVertex(0);
  853|      0|  b = m_pFaces[i]->GetVertex(1);
  854|      0|  c = m_pFaces[i]->GetVertex(2);
  855|      0|  fprintf (ptr, "\t\t%d, %d, %d};\n\n", a, b, c);
  856|       |
  857|       |  /* vertices normales */
  858|      0|  fprintf (ptr, "static float %s_vertices_normales[] = {", modelname);
  859|      0|  float *vertices_normales = m_pVertexNormals;
  860|      0|  fprintf (ptr, "%f, %f, %f,\n", vertices_normales[0], vertices_normales[1], vertices_normales[2]);
  861|      0|  for (i=1; i<n_vertices-1; i++)
  862|      0|    fprintf (ptr, "\t\t%f, %f, %f,\n",
  863|      0|	     vertices_normales[3*i], vertices_normales[3*i+1], vertices_normales[3*i+2]);
  864|      0|  fprintf (ptr, "\t\t%f, %f, %f};\n\n",
  865|      0|	   vertices_normales[3*i], vertices_normales[3*i+1], vertices_normales[3*i+2]);
  866|       |
  867|      0|  fclose (ptr);
  868|       |
  869|      0|  return 0;
  870|      0|}
  871|       |
  872|       |//
  873|       |// GTS
  874|       |//
  875|       |int Mesh::export_gts  (char *filename)
  876|      0|{
  877|      0|  int i;
  878|      0|  FILE *ptr = fopen (filename, "w");
  879|       |  
  880|      0|  fprintf (ptr, "%d %d %d\n", m_nVertices, 3*m_nFaces, m_nFaces);
  881|       |  
  882|       |  // vertices
  883|      0|  for (i=0; i<m_nVertices; i++)
  884|      0|    fprintf (ptr, "%f %f %f\n", m_pVertices[3*i], m_pVertices[3*i+1], m_pVertices[3*i+2]);
  885|       |
  886|       |  // edges
  887|      0|  for (i=0; i<m_nFaces; i++)
  888|      0|    {
  889|      0|	    int a = m_pFaces[i]->GetVertex (0);
  890|      0|	    int b = m_pFaces[i]->GetVertex (1);
  891|      0|	    int c = m_pFaces[i]->GetVertex (2);
  892|      0|      fprintf (ptr, "%d %d\n", 1+a, 1+b);
  893|      0|      fprintf (ptr, "%d %d\n", 1+b, 1+c);
  894|      0|      fprintf (ptr, "%d %d\n", 1+c, 1+a);
  895|      0|    }
  896|       |
  897|       |  // faces
  898|      0|  for (i=0; i<m_nFaces; i++)
  899|      0|    fprintf (ptr, "%d %d %d\n", 3*i+1, 3*i+2, 3*i+3);
  900|       |
  901|      0|  fclose (ptr);
  902|       |
  903|      0|  return 0;
  904|      0|}
  905|       |
  906|       |//
  907|       |// IFS
  908|       |//
  909|       |int Mesh::import_ifs (char *filename)
  910|      0|{
  911|      0|	FILE *ptr = fopen (filename, "rb");
  912|      0|	if (ptr == NULL)
  913|      0|	{
  914|      0|		printf ("unable to open %s\n", filename);
  915|      0|		return false;
  916|      0|	}
  917|       |	
  918|      0|	int length;
  919|      0|	char *buffer[256];
  920|       |	
  921|       |	// magic number "IFS"
  922|      0|	fread (&length, sizeof(unsigned int), 1, ptr);
  923|      0|	fread (buffer, sizeof(char), length, ptr);
  924|       |	
  925|       |	// version "1.0"
  926|      0|	float version;
  927|      0|	fread (&version, sizeof(float), 1, ptr);
  928|      0|	if (version != 1.0)
  929|      0|	{
  930|      0|		printf ("Bad Version: %f\n", version);
  931|      0|		return false;
  932|      0|	}
  933|       |  
  934|       |  // modelname
  935|      0|  fread (&length, sizeof(unsigned int), 1, ptr);
  936|      0|  fread (buffer, sizeof(char), length, ptr);
  937|       |  
  938|       |  // vertexheader "VERTICES"
  939|      0|  fread (&length, sizeof(unsigned int), 1, ptr);
  940|      0|  fread (buffer, sizeof(char), length, ptr);
  941|       |  
  942|       |  // vertices
  943|      0|  fread (&m_nVertices, sizeof(unsigned int), 1, ptr);
  944|      0|  InitVertices (m_nVertices);
  945|      0|  fread (m_pVertices, sizeof(float), 3*m_nVertices, ptr);
  946|       |  
  947|       |  // triangleheader "FACES"
  948|      0|  fread (&length, sizeof(unsigned int), 1, ptr);
  949|      0|  fread (buffer, sizeof(char), length, ptr);
  950|       |  
  951|       |  // faces
  952|      0|  fread (&m_nFaces, sizeof(unsigned int), 1, ptr);
  953|      0|  InitFaces (m_nFaces);
  954|      0|  int *f = (int*)malloc(3*m_nFaces*sizeof(int));
  955|      0|  fread (f, sizeof(float), 3*m_nFaces, ptr);
  956|      0|  for (int i=0; i<m_nFaces; i++)
  957|      0|  {
  958|      0|	  Face *pFace = new Face ();
  959|      0|	  pFace->SetTriangle (f[3*i], f[3*i+1], f[3*i+2]);
  960|      0|	  m_pFaces[i] = pFace;
  961|      0|  }
  962|       |  
  963|      0|  fclose (ptr);
  964|       |
  965|      0|  return 0;
  966|      0|}
  967|       |
  968|       |//
  969|       |// import lwo
  970|       |//
  971|       |int Mesh::import_lwo  (char *filename)
  972|      0|{
  973|      0|  FILE *ptr = fopen (filename, "rb");
  974|      0|  if (!ptr)
  975|      0|    {
  976|      0|      printf ("unable to open %s\n", filename);
  977|      0|      return false;
  978|      0|    }
  979|       |
  980|      0|  char TagId[5];
  981|      0|  memset (TagId, 0, 5*sizeof(char));
  982|      0|  unsigned long TagSizeU4;
  983|      0|  unsigned short TagSizeU2;
  984|      0|  char TagName[256];
  985|       |
  986|       |
  987|       |  // FORM
  988|      0|  fread (TagId, sizeof(unsigned char), 4, ptr);
  989|      0|  if (strcmp ("FORM", TagId))
  990|      0|  {
  991|      0|	  return false;
  992|      0|  }
  993|      0|  fread (&TagSizeU4, sizeof(unsigned long), 1, ptr);
  994|      0|  swap_endian_4 (&TagSizeU4);
  995|       |
  996|       |  // LWO2
  997|      0|  fread (TagId, sizeof(unsigned char), 4, ptr);
  998|      0|  if (strcmp ("LWO2", TagId))
  999|      0|  {
 1000|      0|	  return false;
 1001|      0|  }
 1002|       |
 1003|       |  // TAGS
 1004|      0|  fread (TagId, sizeof(unsigned char), 4, ptr);
 1005|      0|  if (strcmp ("TAGS", TagId))
 1006|      0|  {
 1007|      0|	  return false;
 1008|      0|  }
 1009|      0|  fread (&TagSizeU4, sizeof(unsigned long), 1, ptr);
 1010|      0|  swap_endian_4 (&TagSizeU4);
 1011|       |
 1012|      0|  fread (TagName, TagSizeU4*sizeof(char), 1, ptr);
 1013|       |
 1014|       |  // LAYR
 1015|      0|  fread (TagId, sizeof(unsigned char), 4, ptr);
 1016|      0|  if (strcmp ("LAYR", TagId))
 1017|      0|  {
 1018|      0|	  return false;
 1019|      0|  }
 1020|       |
 1021|      0|  fread (&TagSizeU2, sizeof(unsigned short), 1, ptr);
 1022|      0|  swap_endian_2 (&TagSizeU2);
 1023|      0|  fread (&TagSizeU2, sizeof(unsigned short), 1, ptr);
 1024|      0|  swap_endian_2 (&TagSizeU2);
 1025|       |
 1026|       |
 1027|      0|  float pivot[3]={0.0, 0.0, 0.0};
 1028|      0|  fread (pivot, sizeof(float), 3, ptr);
 1029|       |
 1030|      0|  fread (&TagSizeU4, sizeof(unsigned long), 1, ptr);
 1031|      0|  char Name[256];
 1032|      0|  memset (Name, 0, 256);
 1033|      0|  int NameSize=0;
 1034|      0|  do
 1035|      0|  {
 1036|      0|	  fread (&Name[NameSize], sizeof(char), 1, ptr);
 1037|      0|  } while (Name[NameSize++]!='\0');
 1038|      0|  printf ("%s\n", Name);
 1039|       |
 1040|       |  // PNTS
 1041|      0|  fread (TagId, sizeof(unsigned char), 4, ptr);
 1042|      0|  if (strcmp ("PNTS", TagId))
 1043|      0|  {
 1044|      0|	  return false;
 1045|      0|  }
 1046|       |
 1047|      0|  fread (&TagSizeU4, sizeof(unsigned long), 1, ptr);
 1048|      0|  swap_endian_4 (&TagSizeU4);
 1049|      0|  int nVertices = TagSizeU4 / 12;
 1050|       |
 1051|       |
 1052|      0|	for (int i=0; i<nVertices; i++)
 1053|      0|	{
 1054|      0|	  float coord[3]={0.0, 0.0, 0.0};
 1055|      0|	  fread (&coord, 3*sizeof(float), 1, ptr);
 1056|      0|	  printf ("%f %f %f\n", coord[0], coord[1], coord[2]);
 1057|      0|	}
 1058|       |
 1059|       |  // BBOX
 1060|      0|  fread (TagId, sizeof(unsigned char), 4, ptr);
 1061|      0|  if (strcmp ("BBOX", TagId))
 1062|      0|  {
 1063|      0|	  return false;
 1064|      0|  }
 1065|      0|  fread (&TagSizeU4, sizeof(unsigned long), 1, ptr);
 1066|      0|  swap_endian_4 (&TagSizeU4);
 1067|       |
 1068|      0|  float min[3], max[3];
 1069|      0|  fread (&min, sizeof(float), 3, ptr);
 1070|      0|  printf ("min : %f %f %f\n", min[0], min[1], min[2]);
 1071|      0|  fread (&max, sizeof(float), 3, ptr);
 1072|      0|  printf ("max : %f %f %f\n", max[0], max[1], max[2]);
 1073|       |
 1074|       |  // POLS
 1075|      0|  fread (TagId, sizeof(unsigned char), 4, ptr);
 1076|      0|  if (strcmp ("POLS", TagId))
 1077|      0|  {
 1078|      0|	  return false;
 1079|      0|  }
 1080|      0|  fread (&TagSizeU4, sizeof(unsigned long), 1, ptr);
 1081|      0|  swap_endian_4 (&TagSizeU4);
 1082|       |
 1083|       |  // FACE
 1084|      0|  fread (TagId, sizeof(unsigned char), 4, ptr);
 1085|      0|  if (strcmp ("FACE", TagId))
 1086|      0|  {
 1087|      0|	  return false;
 1088|      0|  }
 1089|       |
 1090|      0|  for (int i=0; i<12; i++)
 1091|      0|  {
 1092|      0|	  unsigned short NbrVertices;
 1093|      0|	  unsigned short Index;
 1094|      0|	  fread (&NbrVertices, sizeof(unsigned short), 1, ptr);
 1095|      0|	  swap_endian_2 (&NbrVertices);
 1096|      0|	  printf ("%d : ", NbrVertices);
 1097|      0|	  for (int j=0; j<NbrVertices; j++)
 1098|      0|	  {
 1099|      0|		  fread (&Index, sizeof(unsigned short), 1, ptr);
 1100|      0|		  swap_endian_2 (&Index);
 1101|      0|		  printf ("%d ", Index);
 1102|      0|	  }
 1103|      0|	  printf ("\n");
 1104|      0|  }
 1105|       |
 1106|       |  // PTAG
 1107|      0|  fread (TagId, sizeof(unsigned char), 4, ptr);
 1108|      0|  if (strcmp ("PTAG", TagId))
 1109|      0|  {
 1110|      0|	  return false;
 1111|      0|  }
 1112|      0|  fread (&TagSizeU4, sizeof(unsigned long), 1, ptr);
 1113|      0|  swap_endian_4 (&TagSizeU4);
 1114|       |
 1115|       |
 1116|      0|  fclose (ptr);
 1117|       |
 1118|      0|  return 0;
 1119|      0|}
 1120|       |
 1121|       |//
 1122|       |// OFF
 1123|       |//
 1124|       |/**
 1125|       |*
 1126|       |* Read a mesh from a 'off' file.
 1127|       |* The format is as follows :
 1128|       |* header :
 1129|       |* OFF
 1130|       |* nv nf ne
 1131|       |
 1132|       |* body :
 1133|       |* x1 y1 z1
 1134|       |* ...
 1135|       |* xm ym zm
 1136|       |* f1 f2 f3
 1137|       |* ...
 1138|       |* f3n f3n+1 f3n+2
 1139|       |*/
 1140|       |int Mesh::import_off (char *filename)
 1141|      0|{
 1142|      0|  FILE *ptr;
 1143|      0|  char id[3];
 1144|      0|  int i, nSegments;
 1145|       |
 1146|      0|  ptr = fopen (filename,"r");
 1147|      0|  if (!ptr) return false;
 1148|       |  
 1149|       |  // Get header information
 1150|      0|  fgets (id, 4, ptr);
 1151|      0|  DASSERT (id[0]=='O' && id[1]=='F' && id[2]=='F');
 1152|      0|  fscanf (ptr, "%d %d %d", &m_nVertices, &m_nFaces, &nSegments);
 1153|       |  //printf ("%d %d\n", n_vertices, n_faces);
 1154|       |  
 1155|       |  // memory allocation
 1156|      0|  Init (m_nVertices, m_nFaces);
 1157|       | 
 1158|       |  // Get the vertices
 1159|      0|  for (i=0; i<m_nVertices; i++)
 1160|      0|    fscanf (ptr, "%f %f %f", &m_pVertices[3*i], &m_pVertices[3*i+1], &m_pVertices[3*i+2]);
 1161|       |
 1162|       |  // Get the faces
 1163|      0|  for (i=0; i<m_nFaces; i++)
 1164|      0|    {
 1165|       |      //float r_tmp, g_tmp, b_tmp;
 1166|      0|      int n_vertices_in_face; /* should be 3 for a triangular mesh */
 1167|       |
 1168|      0|      fscanf (ptr, "%d", &n_vertices_in_face);
 1169|      0|      if (n_vertices_in_face != 3)
 1170|      0|	{
 1171|      0|	  printf ("illegal file\n");
 1172|      0|	  return false;
 1173|      0|	}
 1174|       |
 1175|       |      /*
 1176|       |      fscanf_s (ptr, "%d %d %d %f %f %f",
 1177|       |	      &f[3*i], &f[3*i+1], &f[3*i+2],
 1178|       |	      &r_tmp, &g_tmp, &b_tmp);
 1179|       |      */
 1180|       |
 1181|      0|      Face *pFace = new Face ();
 1182|      0|      fscanf (ptr, "%d %d %d",
 1183|      0|	      &pFace->m_pVertices[0], &pFace->m_pVertices[1], &pFace->m_pVertices[2]);
 1184|       |
 1185|      0|    }
 1186|      0|  fclose (ptr);
 1187|       |
 1188|      0|  return 0;
 1189|      0|}
 1190|       |
 1191|       |/**
 1192|       |* export into off file
 1193|       |*/
 1194|       |int Mesh::export_off (char *filename)
 1195|      0|{
 1196|      0|  FILE *ptr;
 1197|      0|  int i;
 1198|       |
 1199|      0|  ptr = fopen (filename,"w");
 1200|      0|  if (!ptr) return false;
 1201|       |
 1202|       |  // header
 1203|      0|  fprintf (ptr, "OFF\n");
 1204|      0|  fprintf (ptr, "%d %d %d\n", m_nVertices, m_nFaces);
 1205|       |
 1206|       |  // vertices
 1207|      0|  for (i=0; i<m_nVertices; i++)
 1208|      0|    fprintf (ptr, "%f %f %f\n", m_pVertices[3*i], m_pVertices[3*i+1], m_pVertices[3*i+2]);
 1209|       |
 1210|       |  // faces
 1211|       |  //for (i=0; i<n_faces; i++)
 1212|       |  //  fprintf (ptr, "3 %d %d %d 0.5 0.5 0.5\n",
 1213|       |  //	     f[3*i], f[3*i+1], f[3*i+2]);
 1214|      0|  for (i=0; i<m_nFaces; i++)
 1215|      0|  {
 1216|      0|	  fprintf (ptr, "%d %d %d\n",
 1217|      0|		   m_pFaces[i]->GetVertex (0), m_pFaces[i]->GetVertex (1), m_pFaces[i]->GetVertex (2));
 1218|      0|  }
 1219|       |
 1220|      0|  fclose (ptr);
 1221|       |
 1222|      0|  return 0;
 1223|      0|}
 1224|       |
 1225|       |//
 1226|       |// PGM
 1227|       |//
 1228|       |// static function used by void import_pgm (char *filename)
 1229|       |static void
 1230|       |_pgm_skip_spaces(FILE *file)
 1231|      0|{
 1232|      0|  char c;
 1233|       |  
 1234|      0|  while(1)
 1235|      0|  {
 1236|      0|    c = getc(file);
 1237|       |  
 1238|      0|    if (isspace(c))
 1239|      0|      continue;
 1240|       |
 1241|      0|    if (c == '#')
 1242|      0|    {
 1243|      0|      char buf[256];
 1244|       |
 1245|      0|      fgets(buf, 256, file);
 1246|      0|      continue;
 1247|      0|    }
 1248|       |
 1249|      0|    ungetc(c, file);
 1250|       |
 1251|      0|    break;
 1252|      0|  }
 1253|      0|}
 1254|       |
 1255|       |/**
 1256|       |* Reads a mesh from a 'pgm' file. It creates a 3D surface as a height field.
 1257|       |*/
 1258|       |int Mesh::import_pgm (char *filename)
 1259|      0|{
 1260|      0|  int width, height, levels;
 1261|       |  //int level_walk;
 1262|      0|  unsigned char *data = NULL;
 1263|      0|  char id[2];
 1264|      0|  FILE *ptr;
 1265|      0|  int i,j;
 1266|       |  
 1267|      0|  ptr = fopen (filename,"rb");
 1268|      0|  if (!ptr)
 1269|      0|    {
 1270|      0|      printf ("couldn't open \"%s\"\n", filename);
 1271|      0|      return -1;
 1272|      0|    }
 1273|       |
 1274|       |  /* Get header information */
 1275|      0|  fscanf (ptr, "%c %c", &id[0], &id[1]);
 1276|      0|  if (id[0]!='P' && id[1]!='2' && id[1]!='5')
 1277|      0|    {
 1278|      0|      printf ("\"%s\" is not a valid PGM file\n", filename);
 1279|      0|      return false;
 1280|      0|    }
 1281|      0|  _pgm_skip_spaces (ptr);
 1282|      0|  fscanf (ptr, "%d %d", &width, &height);
 1283|      0|  _pgm_skip_spaces (ptr);
 1284|      0|  fscanf (ptr, "%d", &levels);
 1285|      0|  _pgm_skip_spaces (ptr);
 1286|       |
 1287|       |  /* Create the data */
 1288|      0|  data = (unsigned char*)malloc(width*height*sizeof(unsigned char));
 1289|      0|  DASSERT (data);
 1290|       |
 1291|       |  /* Get the data */
 1292|      0|  if (id[1]=='2') /* ascii mode */
 1293|      0|  {
 1294|      0|    for (j=0; j<height; j++)
 1295|      0|      for (i=0; i<width; i++)
 1296|      0|	  {
 1297|      0|		fscanf (ptr, "%d", &data[j*width+i]);
 1298|      0|	  }
 1299|      0|  }
 1300|      0|  if (id[1]=='5') /* raw mode */
 1301|      0|  {
 1302|      0|	fread (data, sizeof(unsigned char), height*width, ptr);
 1303|      0|  }
 1304|       |
 1305|      0|  fclose (ptr);
 1306|       |
 1307|       |  // equalization
 1308|      0|  int min = 255;
 1309|      0|  int max = 0;
 1310|      0|  for (i=0; i<width*height; i++)
 1311|      0|    {
 1312|      0|      if (data[i] > max) max = data[i];
 1313|      0|      if (data[i] < min) min = data[i];
 1314|      0|    }    
 1315|      0|  for (i=0; i<width*height; i++)
 1316|      0|    data[i] = 255*(data[i]-min)/(max-min);
 1317|       |
 1318|       |  // translation to center
 1319|      0|  float x_trans = (1)? -width/2.0 : 0;
 1320|      0|  float y_trans = (1)? -height/2.0 : 0;
 1321|       |
 1322|       |  // alloc memory
 1323|      0|  m_nVertices = width*height;
 1324|      0|  m_nFaces = 2*(width-1)*(height-1);
 1325|      0|  Init (m_nVertices, m_nFaces);
 1326|       |
 1327|       |  // fill the structure
 1328|      0|  for (j=0; j<height; j++)
 1329|      0|    for (i=0; i<width; i++)
 1330|      0|	{
 1331|      0|	  m_pVertices[3*(j*width+i)]   = (float)i+x_trans;
 1332|      0|	  m_pVertices[3*(j*width+i)+1] = (float)(height-1-j)+y_trans;
 1333|      0|	  m_pVertices[3*(j*width+i)+2] = (float)(255-data[j*width+i]/3.0)-150.0;
 1334|      0|	}
 1335|       |
 1336|      0|  for (j=0; j<height-1; j++)
 1337|      0|    for (i=0; i<width-1; i++)
 1338|      0|	{
 1339|      0|		Face *f1 = new Face ();
 1340|      0|		f1->SetVertex (0, j*width+i);
 1341|      0|		f1->SetVertex (1, (j+1)*width+i);
 1342|      0|		f1->SetVertex (2, j*width+i+1);
 1343|      0|		Face *f2 = new Face ();
 1344|      0|		f2->SetVertex (0, (j+1)*width+i+1);
 1345|      0|		f2->SetVertex (1, j*width+i+1);
 1346|      0|		f2->SetVertex (2, (j+1)*width+i);
 1347|      0|		m_pFaces[2*(j*(width-1)+i)]   = f1;
 1348|      0|		m_pFaces[2*(j*(width-1)+i)+1] = f2;
 1349|      0|	}
 1350|       |
 1351|      0|	return 0;
 1352|      0|}
 1353|       |
 1354|       |//
 1355|       |// PTS
 1356|       |//
 1357|       |int Mesh::import_pts  (char *filename)
 1358|      0|{
 1359|      0|	int i;
 1360|      0|  FILE *ptr = fopen (filename, "r");
 1361|      0|  if (!ptr)
 1362|      0|    {
 1363|      0|      printf ("unable to open %s\n", filename);
 1364|      0|      return -1;
 1365|      0|    }
 1366|       |
 1367|      0|  char *buffer = (char*)malloc(512*sizeof(char));
 1368|      0|  if (buffer == NULL)
 1369|      0|  {
 1370|      0|	  return -1;
 1371|      0|  }
 1372|       |  //
 1373|      0|  m_nVertices = 0;
 1374|      0|  while (1)
 1375|      0|  {
 1376|      0|    fgets (buffer, 512, ptr);
 1377|      0|    if (feof(ptr)) break;
 1378|      0|    m_nVertices++;
 1379|      0|  }
 1380|      0|  Init (m_nVertices, 0);
 1381|      0|  m_pVertexColors = (float*)malloc(3*m_nVertices*sizeof(float));
 1382|      0|  if (m_pVertexColors == NULL)
 1383|      0|  {
 1384|      0|	  free (buffer);
 1385|      0|	  return false;
 1386|      0|  }
 1387|       |
 1388|      0|  rewind (ptr);
 1389|      0|  unsigned int vertex_walk=0;
 1390|      0|  unsigned int r=0, g=0, b=0;
 1391|      0|  while (1)
 1392|      0|  {
 1393|      0|    fgets (buffer, 512, ptr);
 1394|      0|    if (feof(ptr)) break;
 1395|       |
 1396|      0|	sscanf (buffer, "%f %f %f %d %d %d", 
 1397|      0|		&m_pVertices[3*vertex_walk],
 1398|      0|		&m_pVertices[3*vertex_walk+1],
 1399|      0|		&m_pVertices[3*vertex_walk+2],
 1400|      0|		&r, &g, &b);
 1401|      0|	m_pVertexColors[3*vertex_walk]   = (float)r/255.0;
 1402|      0|	m_pVertexColors[3*vertex_walk+1] = (float)g/255.0;
 1403|      0|	m_pVertexColors[3*vertex_walk+2] = (float)b/255.0;
 1404|       |
 1405|      0|	vertex_walk++;
 1406|      0|  }
 1407|      0|  fclose (ptr);
 1408|       |
 1409|      0|  free (buffer);
 1410|       |
 1411|      0|  return 0;
 1412|      0|}
 1413|       |
 1414|       |int Mesh::export_pts  (char *filename)
 1415|      0|{
 1416|      0|  FILE *ptr = fopen (filename, "w");
 1417|      0|  if (!ptr)
 1418|      0|	{
 1419|      0|	  printf ("unable to open %s\n", filename);
 1420|      0|	  return false;
 1421|      0|	}
 1422|       |
 1423|      0|  if (m_pVertices != NULL && m_pVertexColors != NULL)
 1424|      0|  {
 1425|      0|	  for (int i=0; i<m_nVertices; i++)
 1426|      0|	  {
 1427|      0|		  fprintf (ptr, "%f %f %f %d %d %d\n",
 1428|      0|			  m_pVertices[3*i], m_pVertices[3*i+1], m_pVertices[3*i+2],
 1429|      0|			  (int)(m_pVertexColors[3*i]*255.0), (int)(m_pVertexColors[3*i+1]*255.0), (int)(m_pVertexColors[3*i+2]*255.0));
 1430|      0|	  }
 1431|      0|  }
 1432|      0|  else
 1433|      0|  {
 1434|      0|	  return false;
 1435|      0|  }
 1436|       |
 1437|      0|  fclose (ptr);
 1438|       |
 1439|      0|  return true;
 1440|      0|}
 1441|       |
 1442|       |//
 1443|       |// PLY
 1444|       |//
 1445|       |#include "mesh_io_rply.h"
 1446|      0|static int vertex_cb_coords(p_ply_argument argument) {
 1447|      0|    long dim;
 1448|      0|    void *pMesh;
 1449|      0|    ply_get_argument_user_data(argument, &pMesh, &dim);
 1450|      0|    Mesh *mesh = (Mesh*)pMesh;
 1451|       |
 1452|      0|    if (dim == 0) // new vertex
 1453|      0|	    mesh->m_nVertices++;
 1454|       |
 1455|      0|    float coord = ply_get_argument_value(argument);
 1456|      0|    mesh->m_pVertices[3*mesh->m_nVertices+dim] = coord;
 1457|       |
 1458|      0|    return 1;
 1459|      0|}
 1460|       |
 1461|      0|static int vertex_cb_normals(p_ply_argument argument) {
 1462|      0|    long dim;
 1463|      0|    void *pMesh;
 1464|      0|    ply_get_argument_user_data(argument, &pMesh, &dim);
 1465|      0|    Mesh *mesh = (Mesh*)pMesh;
 1466|      0|    float coord = ply_get_argument_value(argument);
 1467|      0|    mesh->m_pVertexNormals[3*mesh->m_nVertices+dim] = coord;
 1468|       |
 1469|      0|    return 1;
 1470|      0|}
 1471|       |
 1472|      0|static int vertex_cb_colors(p_ply_argument argument) {
 1473|      0|    long dim;
 1474|      0|    void *pMesh;
 1475|      0|    ply_get_argument_user_data(argument, &pMesh, &dim);
 1476|      0|    Mesh *mesh = (Mesh*)pMesh;
 1477|      0|    float coord = ply_get_argument_value(argument)/255.;
 1478|      0|    mesh->m_pVertexColors[3*mesh->m_nVertices+dim] = coord;
 1479|       |
 1480|      0|    return 1;
 1481|      0|}
 1482|       |
 1483|      0|static int face_cb(p_ply_argument argument) {
 1484|      0|    void *pMesh;
 1485|      0|    ply_get_argument_user_data(argument, &pMesh, NULL);
 1486|      0|    Mesh *mesh = (Mesh*)pMesh;
 1487|       |
 1488|       |
 1489|      0|   long length, value_index;
 1490|      0|    ply_get_argument_property(argument, NULL, &length, &value_index);
 1491|       |
 1492|      0|    if (value_index == -1) // new face
 1493|      0|    {
 1494|      0|	    mesh->m_nFaces++;
 1495|      0|	    mesh->m_pFaces[mesh->m_nFaces] = new Face ();
 1496|      0|	    mesh->m_pFaces[mesh->m_nFaces]->SetNVertices (ply_get_argument_value(argument));
 1497|      0|    }
 1498|      0|    else
 1499|      0|    {
 1500|      0|	    mesh->m_pFaces[mesh->m_nFaces]->m_pVertices[value_index] = ply_get_argument_value(argument);
 1501|      0|    }
 1502|      0|    return 1;
 1503|      0|}
 1504|       |
 1505|       |int Mesh::import_ply  (char *filename)
 1506|      0|{
 1507|      0|	int i;
 1508|      0|	long nvertices, ntriangles;
 1509|      0|	p_ply ply = ply_open(filename, NULL, 0, NULL);
 1510|      0|	if (!ply)
 1511|      0|	{
 1512|      0|		printf ("unable to open %s\n", filename);
 1513|      0|		return -1;
 1514|      0|	}
 1515|      0|	if (!ply_read_header(ply))
 1516|      0|		return -1;
 1517|       |	
 1518|      0|	nvertices = ply_set_read_cb(ply, "vertex", "x", vertex_cb_coords, this, 0);
 1519|      0|	ply_set_read_cb(ply, "vertex", "y", vertex_cb_coords, this, 1);
 1520|      0|	ply_set_read_cb(ply, "vertex", "z", vertex_cb_coords, this, 2);
 1521|       |	
 1522|      0|	int bNormals = ply_set_read_cb(ply, "vertex", "nx", vertex_cb_normals, this, 0);
 1523|      0|	ply_set_read_cb(ply, "vertex", "ny", vertex_cb_normals, this, 1);
 1524|      0|	ply_set_read_cb(ply, "vertex", "nz", vertex_cb_normals, this, 2);
 1525|       |	
 1526|      0|	int bColors = ply_set_read_cb(ply, "vertex", "diffuse_red", vertex_cb_colors, this, 0);
 1527|      0|	ply_set_read_cb(ply, "vertex", "diffuse_green", vertex_cb_colors, this, 1);
 1528|      0|	ply_set_read_cb(ply, "vertex", "diffuse_blue", vertex_cb_colors, this, 2);
 1529|       |	
 1530|      0|	ntriangles = ply_set_read_cb(ply, "face", "vertex_indices", face_cb, this, 0);
 1531|       |	
 1532|      0|	Init (nvertices, ntriangles);
 1533|      0|	if (bColors)
 1534|      0|		InitVertexColors ();
 1535|       |	
 1536|      0|	m_nVertices = (unsigned int)(-1);
 1537|      0|	m_nFaces = (unsigned int)(-1);
 1538|       |	
 1539|      0|	if (!ply_read(ply))
 1540|      0|		return -1;
 1541|       |	
 1542|      0|	m_nVertices = nvertices;
 1543|      0|	m_nFaces = ntriangles;
 1544|       |	
 1545|      0|	ply_close(ply);
 1546|       |	
 1547|      0|	return 0;
 1548|      0|}
 1549|       |
 1550|       |int Mesh::export_ply  (char *filename)
 1551|      0|{
 1552|      0|    const char *value;
 1553|      0|    p_ply oply = ply_create(filename, PLY_LITTLE_ENDIAN, NULL, 0, NULL);
 1554|      0|    if (!oply)
 1555|      0|	    return -1;
 1556|       |
 1557|      0|    ply_add_element(oply, "vertex", m_nVertices);
 1558|      0|    ply_add_property(oply, "x", PLY_FLOAT, PLY_FLOAT, PLY_FLOAT);
 1559|      0|    ply_add_property(oply, "y", PLY_FLOAT, PLY_FLOAT, PLY_FLOAT);
 1560|      0|    ply_add_property(oply, "z", PLY_FLOAT, PLY_FLOAT, PLY_FLOAT);
 1561|      0|    if (m_pVertexNormals)
 1562|      0|    {
 1563|      0|	    ply_add_property(oply, "nx", PLY_FLOAT, PLY_FLOAT, PLY_FLOAT);
 1564|      0|	    ply_add_property(oply, "ny", PLY_FLOAT, PLY_FLOAT, PLY_FLOAT);
 1565|      0|	    ply_add_property(oply, "nz", PLY_FLOAT, PLY_FLOAT, PLY_FLOAT);
 1566|      0|    }
 1567|       |
 1568|       |    // write output header
 1569|      0|    if (!ply_write_header(oply))
 1570|      0|	    return -1;
 1571|       |
 1572|      0|    for (unsigned int i=0; i<m_nVertices; i++)
 1573|      0|    {
 1574|      0|	    ply_write (oply, m_pVertices[3*i]);
 1575|      0|	    ply_write (oply, m_pVertices[3*i+1]);
 1576|      0|	    ply_write (oply, m_pVertices[3*i+2]);
 1577|      0|	    if (m_pVertexNormals)
 1578|      0|	    {
 1579|      0|		    ply_write (oply, m_pVertexNormals[3*i]);
 1580|      0|		    ply_write (oply, m_pVertexNormals[3*i+1]);
 1581|      0|		    ply_write (oply, m_pVertexNormals[3*i+2]);
 1582|      0|	    }
 1583|      0|    }
 1584|       |
 1585|       |    // clean
 1586|      0|    if (!ply_close(oply))
 1587|      0|	    return -1;
 1588|      0|    return 0;
 1589|      0|}
 1590|       |
 1591|       |
 1592|       |int Mesh::import_stl(char* filename)
 1593|      2|{
 1594|      2|	FILE* ptr = nullptr;
 1595|      2|	ptr = fopen(filename, "rb");
 1596|      2|	if (ptr == nullptr)
 1597|      0|		return 1;
 1598|       |
 1599|      2|	char header[80];
 1600|      2|	fread(header, 80, sizeof(char), ptr);
 1601|       |
 1602|      2|	unsigned int nTriangles = 0;
 1603|      2|	fread((char*)&nTriangles, 4, 1, ptr);
 1604|       |
 1605|      2|	Init(3 * nTriangles, nTriangles);
 1606|       |
 1607|      2|	float coords[12];
 1608|      2|	char attributes[2];
 1609|  1.32k|	for (unsigned int iface = 0; iface < nTriangles; iface++)
 1610|  1.32k|	{
 1611|  1.32k|		fread((char*)coords, sizeof(float), 12, ptr);
 1612|  1.32k|		memcpy(m_pVertices + 9*iface, coords + 3, 9 * sizeof(float));
 1613|       |
 1614|  1.32k|		Face* pFace = m_pFaces[iface];
 1615|  1.32k|		if (!pFace)
 1616|      0|			pFace = new Face();
 1617|  1.32k|		pFace->SetNVertices(3);
 1618|       |
 1619|  5.29k|		for (int j = 0; j < 3; j++)
 1620|  3.97k|			pFace->SetVertex(j, 3*iface+j);
 1621|       |
 1622|  1.32k|		fread(attributes, sizeof(unsigned char), 2, ptr);
 1623|  1.32k|	}
 1624|       |
 1625|      2|	return 0;
 1626|      2|}
 1627|       |/*
 1628|       |int Mesh::import_stl (char *filename)
 1629|       |{
 1630|       |	FILE *ptr = fopen (filename, "rb");
 1631|       |	if (!ptr)
 1632|       |		return -1;
 1633|       |
 1634|       |	char header[81];
 1635|       |	fread (header, sizeof(unsigned char), 80, ptr);
 1636|       |	header[80] = '\0';
 1637|       |	//printf ("%s\n", header);
 1638|       |
 1639|       |	unsigned int nfaces = 0;
 1640|       |	fread (&nfaces, sizeof(unsigned int), 1, ptr);
 1641|       |	printf ("%d faces\n", nfaces);
 1642|       |
 1643|       |	float normal[3];
 1644|       |	float faceinfo[12];
 1645|       |	unsigned char attribute_byte_count[2];
 1646|       |	int n=0;
 1647|       |	FILE *out = fopen ("out.obj", "w");
 1648|       |	int nf = 1000000;
 1649|       |	while (!feof (ptr))
 1650|       |	{
 1651|       |		fread (faceinfo, sizeof(float), 12, ptr);
 1652|       |		fread (attribute_byte_count, sizeof(unsigned char), 2, ptr);
 1653|       |		if (n<nf)
 1654|       |		{
 1655|       |			fprintf (out, "v %f %f %f\n", faceinfo[3], faceinfo[4], faceinfo[5]);
 1656|       |			fprintf (out, "v %f %f %f\n", faceinfo[6], faceinfo[7], faceinfo[8]);
 1657|       |			fprintf (out, "v %f %f %f\n", faceinfo[9], faceinfo[10], faceinfo[11]);
 1658|       |		}
 1659|       |
 1660|       |		n++;
 1661|       |		if (n == nfaces)
 1662|       |			break;
 1663|       |
 1664|       |		printf ("%f %f %f\n", normal[0], normal[1], normal[2]);
 1665|       |		printf ("%f %f %f\n", v1[0], v1[1], v1[2]);
 1666|       |		printf ("%f %f %f\n", v2[0], v2[1], v2[2]);
 1667|       |		printf ("%f %f %f\n", v3[0], v3[1], v3[2]);
 1668|       |
 1669|       |	};
 1670|       |	for (int i=0; i<nf; i++)
 1671|       |		fprintf (out, "f %d %d %d\n", 1+3*i, 1+3*i+1, 1+3*i+2);
 1672|       |	fclose (out);
 1673|       |	printf ("%d / %d\n", n, nfaces);
 1674|       |
 1675|       |	fclose (ptr);
 1676|       |
 1677|       |	return 0;
 1678|       |}
 1679|       |*/
 1680|       |int Mesh::export_stl (char *filename)
 1681|      0|{
 1682|      0|	return -1;
 1683|      0|}
 1684|       |
 1685|       |
 1686|       |int Mesh::import_3ds (char *filename)
 1687|      0|{
 1688|      0|	t3DSModel *p = Load3DSFile(filename, NULL);
 1689|      0|	Free3DSModel(p);
 1690|      0|	return 0;
 1691|      0|}
 1692|       |
 1693|       |int Mesh::export_3ds (char *filename)
 1694|      0|{
 1695|      0|	t3DSModel *p = Allocate3DSModel();
 1696|      0|	Write3DSFile(p, filename, NULL);
 1697|      0|	Free3DSModel(p);
 1698|      0|	return 0;
 1699|      0|}
 1700|       |

/workspaces/cg/src/cgmesh/mesh_io_3ds.cpp:
    1|       |#include <stdio.h>
    2|       |#include <assert.h>
    3|       |#include <stdlib.h>
    4|       |#include <string.h>
    5|       |#include "mesh_io_3ds.h"
    6|       |
    7|       |bool trace_unknown_chunks = true;
    8|       |
    9|       |// Global
   10|       |int gBuffer[50000] = {0};	// This is used to read past unwanted data
   11|       |
   12|       |// The file pointer
   13|       |FILE *g_File3DSPointer = NULL;
   14|       |
   15|       |// Error description if an error occurs during the parsing of the file
   16|       |char *errorDesc = NULL;
   17|       |
   18|       |//*****************************************************************************
   19|       |// Allocate memory for a 3D model
   20|       |// @return t3DSModel* - A pointer to the newly allocated model, NULL otherwise
   21|       |//*****************************************************************************
   22|       |t3DSModel *Allocate3DSModel()
   23|      1|{
   24|      1|	t3DSModel *pModel = new t3DSModel();
   25|      1|	if (pModel == NULL)
   26|      0|		return NULL;
   27|       |
   28|      1|	memset (pModel, 0, sizeof(t3DSModel));
   29|       |
   30|      1|return pModel;
   31|      1|}
   32|       |
   33|       |//*****************************************************************************
   34|       |// Free any previously allocated 3D model
   35|       |// @param pModel - The model to deallocate
   36|       |// @return HRESULT - S_OK, an error code otherwise
   37|       |//*****************************************************************************
   38|       |int Free3DSModel(t3DSModel *pModel)
   39|      1|{
   40|      1|int hr = 0;
   41|       |
   42|      1|	if (pModel == NULL)
   43|      0|		return 0;
   44|       |
   45|       |	// When we are done, we need to free all the model data
   46|       |	// We do this by walking through all the objects and freeing their information
   47|       |
   48|       |	// Go through all the objects in the scene
   49|      5|	for(int i = 0; i < pModel->numOfObjects; i++)
   50|      4|	{
   51|       |		// Free the faces, normals, vertices, and texture coordinates.
   52|      4|		delete [] pModel->pObject[i].pFaces;
   53|      4|		delete [] pModel->pObject[i].pNormals;
   54|      4|		delete [] pModel->pObject[i].pVerts;
   55|      4|		delete [] pModel->pObject[i].pTexVerts;
   56|      4|	}
   57|       |	// Go through all the animations in the scene
   58|      1|	for(int i = 0; i < pModel->numOfAnimations; i++)
   59|      0|	{
   60|      0|		t3DSAnimation animation = pModel->pAnimations[i];
   61|      0|		for (int j=0; j<animation.nTracks; j++)
   62|      0|		{
   63|      0|			switch (animation.trackType[j])
   64|      0|			{
   65|      0|				case CHK3DS_B_POS_TRACK_TAG:
   66|      0|					{
   67|      0|						t3DSPositionTrack* positionTrack = (t3DSPositionTrack*)animation.track[j];
   68|      0|						delete positionTrack->position;
   69|      0|						delete positionTrack;
   70|      0|					}
   71|      0|					break;
   72|      0|				case CHK3DS_B_ROT_TRACK_TAG:
   73|      0|					{
   74|      0|						t3DSRotationTrack* rotationTrack = (t3DSRotationTrack*)animation.track[j];
   75|      0|						delete rotationTrack->angle;
   76|      0|						delete rotationTrack->axis;
   77|      0|						delete rotationTrack;
   78|      0|					}
   79|      0|					break;
   80|      0|				case CHK3DS_B_SCL_TRACK_TA:
   81|      0|					{
   82|      0|						t3DSScaleTrack* scaleTrack = (t3DSScaleTrack*)animation.track[j];
   83|      0|						delete scaleTrack->size;
   84|      0|						delete scaleTrack;
   85|      0|					}
   86|      0|					break;
   87|      0|				default:
   88|      0|					break;
   89|      0|			}
   90|      0|		}
   91|      0|	}
   92|       |
   93|      1|return hr;
   94|      1|}
   95|       |
   96|       |//*****************************************************************************
   97|       |// Load a 3DS file into the 3D Model Structure
   98|       |// @param szFile - The path to the file to open
   99|       |// @param ExtraParameters - Some extra parameters
  100|       |// @return t3DSModel* - A structure that decsribe our 3D model
  101|       |//*****************************************************************************
  102|       |t3DSModel *Load3DSFile (char *szFile, void *ExtraParameters)
  103|      1|{
  104|      1|t3DSChunk currentChunk;
  105|       |
  106|      1|	if (szFile == NULL)
  107|      0|	{
  108|      0|		printf("no file!", szFile);
  109|      0|		return NULL;
  110|      0|	}
  111|       |
  112|      1|	memset( &currentChunk, 0, sizeof(t3DSChunk));
  113|       |
  114|       |	// Open the 3DS file
  115|      1|	g_File3DSPointer = fopen(szFile, "rb");
  116|       |
  117|       |	// Make sure we have a valid file pointer (we found the file)
  118|      1|	if(!g_File3DSPointer) 
  119|      0|	{
  120|      0|		printf("Unable to find the file: %s!", szFile);
  121|      0|		return NULL;
  122|      0|	}
  123|       |
  124|       |	// Once we have the file open, we need to read the very first data chunk
  125|       |	// to see if it's a 3DS file.  That way we don't read an invalid file.
  126|       |	// If it is a 3DS file, then the first chunk ID will be equal to PRIMARY (some hex num)
  127|       |
  128|       |	// Read the first chuck of the file to see if it's a 3DS file
  129|      1|	ReadChunk_3DS(&currentChunk);
  130|       |
  131|       |	// Make sure this is a 3DS file
  132|      1|	if (currentChunk.ID != CHK3DS_4_M3DMAGIC)
  133|      0|	{
  134|      0|		printf("Unable to load PRIMARY chuck from file: %s!", szFile);
  135|      0|		return NULL;
  136|      0|	}
  137|       |
  138|       |	// Now we actually start reading in the data.  ProcessNextChunk() is recursive
  139|       |
  140|       |	//Create a 3D Model object
  141|      1|	t3DSModel *pModel = Allocate3DSModel();
  142|      1|	if (pModel == NULL)
  143|      0|		return NULL;
  144|       |
  145|       |	// Begin loading objects, by calling this recursive function
  146|      1|	ProcessNextChunk_3DS(pModel, &currentChunk);
  147|       |
  148|       |
  149|       |	// Clean up after everything
  150|      1|	CleanUp_3DS();
  151|       |
  152|       |	//Copy the path
  153|      1|	strcpy(pModel->strPathToModel,szFile);
  154|       |
  155|       |	//Don't forget to Create a new GR3D Object, fill it and return
  156|       |
  157|      1|return pModel;
  158|      1|}
  159|       |
  160|       |
  161|       |///////////////////////////////// CLEAN UP \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
  162|       |/////
  163|       |/////	This function cleans up our allocated memory and closes the file
  164|       |/////
  165|       |///////////////////////////////// CLEAN UP \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
  166|       |
  167|       |void CleanUp_3DS()
  168|      1|{
  169|      1|	if (g_File3DSPointer)
  170|      1|	{
  171|      1|		fclose(g_File3DSPointer);					// Close the current file pointer
  172|      1|		g_File3DSPointer = NULL;
  173|      1|	}
  174|      1|}
  175|       |
  176|       |/*** Reading functions ***/
  177|       |static void ReadRGBColorFloat (FLOAT32 color[3], t3DSChunk *currentChunk)
  178|      0|{
  179|      0|	currentChunk->bytesRead += fread(color, 1, 3*sizeof(FLOAT32), g_File3DSPointer);
  180|      0|}
  181|       |
  182|       |static void ReadVector (FLOAT32 vector[3], t3DSChunk *currentChunk)
  183|     16|{
  184|     16|	currentChunk->bytesRead += fread(vector, 1, 3*sizeof(FLOAT32), g_File3DSPointer);
  185|     16|}
  186|       |
  187|       |static void ReadFloat32 (FLOAT32 *res, t3DSChunk *currentChunk)
  188|      1|{
  189|      1|	currentChunk->bytesRead += fread(res, 1, sizeof(FLOAT32), g_File3DSPointer);
  190|      1|}
  191|       |
  192|       |static void ReadINT16 (INT16 *res, t3DSChunk *currentChunk)
  193|      0|{
  194|      0|	currentChunk->bytesRead += fread(res, 1, sizeof(INT16), g_File3DSPointer);
  195|      0|}
  196|       |
  197|       |static void ReadBYTE (BYTE *res, t3DSChunk *currentChunk)
  198|      0|{
  199|      0|	currentChunk->bytesRead += fread(res, 1, sizeof(BYTE), g_File3DSPointer);
  200|      0|}
  201|       |
  202|       |static void ReadINT32 (INT32 *res, t3DSChunk *currentChunk)
  203|      2|{
  204|      2|	currentChunk->bytesRead += fread(res, 1, sizeof(INT32), g_File3DSPointer);
  205|      2|}
  206|       |
  207|       |static void ReadUINT32 (UINT32 *res, t3DSChunk *currentChunk)
  208|      0|{
  209|      0|	currentChunk->bytesRead += fread(res, 1, sizeof(UINT32), g_File3DSPointer);
  210|      0|}
  211|       |
  212|       |
  213|       |///////////////////////////////// PROCESS NEXT CHUNK\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
  214|       |/////
  215|       |/////	This function reads the main sections of the .3DS file, then dives deeper with recursion
  216|       |/////
  217|       |///////////////////////////////// PROCESS NEXT CHUNK\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
  218|       |
  219|       |void ProcessNextChunk_3DS(t3DSModel *pModel, t3DSChunk *pPreviousChunk)
  220|      2|{
  221|      2|	t3DSChunk currentChunk; // The current chunk to load
  222|      2|	memset( &currentChunk, 0, sizeof(t3DSChunk));
  223|       |
  224|     13|	while (pPreviousChunk->bytesRead < pPreviousChunk->length)
  225|     11|	{
  226|       |		// Read next Chunk
  227|     11|		ReadChunk_3DS(&currentChunk);
  228|       |
  229|       |		// Check the chunk ID
  230|     11|		switch (currentChunk.ID)
  231|     11|		{
  232|       |			/*
  233|       |				If the file was made in 3D Studio Max, this chunk has an int that 
  234|       |				holds the file version.  Since there might be new additions to the 3DS file
  235|       |				format in 4.0, we give a warning to that problem.
  236|       |				However, if the file wasn't made by 3D Studio Max, we don't 100% what the
  237|       |				version length will be so we'll simply ignore the value
  238|       |			*/
  239|      1|			case CHK3DS_0_M3D_VERSION:	// version of the file
  240|      1|			{
  241|      1|				ReadINT32 (&pModel->fileVersion, &currentChunk);
  242|       |
  243|       |				// If the file version is over 3, give a warning that there could be a problem
  244|      1|				if (pModel->fileVersion > 0x03)
  245|      0|				{
  246|      0|					printf ("This 3DS file is over version 3 so it may load incorrectly\n");
  247|      0|				}
  248|      1|			}
  249|      1|			break;
  250|       |
  251|       |			// version of the mesh
  252|      1|			case CHK3DS_3_MESH_VERSION:
  253|      1|			{
  254|      1|				ReadINT32 (&pModel->meshVersion, &currentChunk);
  255|      1|			}
  256|      1|			break;
  257|       |
  258|       |			// This chunk holds the version of the mesh.  It is also the head of the MATERIAL
  259|       |			// and OBJECT chunks.  From here on we start reading in the material and object info.
  260|      1|			case CHK3DS_3_MDATA:	// This holds the version of the mesh
  261|      1|			{
  262|       |				// Go to the next chunk, which is the object has a texture, it should be MATERIAL, then OBJECT.
  263|      1|				ProcessNextChunk_3DS(pModel, &currentChunk);
  264|      1|			}
  265|      1|			break;
  266|       |		
  267|       |			// This chunk is the header for the material info chunks
  268|      2|			case CHK3DS_A_MAT_ENTRY:	// This holds the material information
  269|      2|			{
  270|      2|				t3DSMaterialInfo newTexture; // This is used to add to our material list
  271|      2|				memset( &newTexture, 0, sizeof(t3DSMaterialInfo));
  272|       |
  273|      2|				pModel->numOfMaterials++; // Increase the number of materials
  274|      2|				pModel->pMaterials.push_back(newTexture); // Add an empty texture structure to our texture list
  275|      2|				ProcessNextMaterialChunk_3DS(pModel, &currentChunk); // Proceed to the material loading function
  276|      2|			}
  277|      2|			break;
  278|       |
  279|       |			// This holds the name of the object being read
  280|      4|			case CHK3DS_4_NAMED_OBJECT:
  281|      4|			{
  282|       |				// get the name of the object
  283|      4|				char strName[255];
  284|      4|				currentChunk.bytesRead += GetString(strName);
  285|      4|				ProcessNextObjectChunk_3DS(pModel, strName, &currentChunk);
  286|      4|			}
  287|      4|			break;
  288|       |
  289|       |			// key frame information
  290|      1|			case CHK3DS_B_KFDATA:
  291|      1|			{
  292|       |				//ProcessNextKeyFrameChunk_3DS (pModel, &currentChunk);
  293|       |
  294|       |				// Read past this chunk and add the bytes read to the byte counter
  295|      1|				currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
  296|      1|			}
  297|      1|			break;
  298|       |
  299|      1|			case CHK3DS_0_MASTER_SCALE:
  300|      1|			{
  301|      1|				FLOAT32 res;
  302|      1|				ReadFloat32 (&res, &currentChunk);
  303|      1|			}
  304|      1|			break;
  305|       |
  306|       |			//
  307|      0|			default:
  308|      0|			{
  309|      0|				if (trace_unknown_chunks)
  310|      0|				{
  311|      0|					StoreUnknownChunk (pModel, pPreviousChunk->ID, currentChunk.ID);
  312|      0|				}
  313|      0|				currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
  314|      0|			}
  315|      0|			break;
  316|     11|		}
  317|       |
  318|       |		// Add the bytes read from the last chunk to the previous chunk passed in.
  319|     11|		pPreviousChunk->bytesRead += currentChunk.bytesRead;
  320|     11|	}
  321|      2|}
  322|       |
  323|       |//*****************************************************************************
  324|       |//
  325|       |//*****************************************************************************
  326|       |void ProcessNextObjectChunk_3DS(t3DSModel *pModel, char *strName, t3DSChunk *pPreviousChunk)
  327|      4|{
  328|       |	// The current chunk to work with
  329|      4|	t3DSChunk currentChunk;
  330|      4|	memset( &currentChunk, 0, sizeof(t3DSChunk));
  331|       |
  332|       |	// Continue to read these chunks until we read the end of this sub chunk
  333|      8|	while (pPreviousChunk->bytesRead < pPreviousChunk->length)
  334|      4|	{
  335|       |		// Read the next chunk
  336|      4|		ReadChunk_3DS(&currentChunk);
  337|       |
  338|       |		// Check which chunk we just read
  339|      4|		switch (currentChunk.ID)
  340|      4|		{
  341|       |			// a new object
  342|      4|			case CHK3DS_4_N_TRI_OBJECT:
  343|      4|			{
  344|      4|				t3DSObject newObject;
  345|      4|				memset( &newObject, 0, sizeof(t3DSObject));
  346|       |
  347|       |				// Increase the object count
  348|      4|				pModel->numOfObjects++;
  349|       |
  350|       |				// Add a new tObject node to our list of objects
  351|      4|				pModel->pObject.push_back(newObject);
  352|       |
  353|       |				// Initialize the object and all it's data members
  354|      4|				memset(&(pModel->pObject[pModel->numOfObjects - 1]), 0, sizeof(t3DSObject));
  355|       |
  356|       |				// Store it, then add the read bytes to our byte counter.
  357|      4|				memcpy ((void*)pModel->pObject[pModel->numOfObjects - 1].strName, (void*)strName, strlen(strName)+1);
  358|       |
  359|       |				// Now proceed to read in the rest of the object information
  360|      4|				ProcessNextTriMeshChunk_3DS(pModel, &(pModel->pObject[pModel->numOfObjects - 1]), &currentChunk);
  361|      4|			}
  362|      4|			break;
  363|       |
  364|       |			// a new light
  365|      0|			case CHK3DS_4_N_DIRECT_LIGHT:
  366|      0|			{
  367|      0|				t3DSLight newLight;
  368|      0|				memset( &newLight, 0, sizeof(t3DSLight));
  369|       |
  370|       |				// Increase the object count
  371|      0|				pModel->numOfLights++;
  372|       |
  373|       |				// Add a new tObject node to our list of objects
  374|      0|				pModel->pLights.push_back(newLight);
  375|       |
  376|       |				// Initialize the object and all it's data members
  377|      0|				memset(&(pModel->pLights[pModel->numOfLights - 1]), 0, sizeof(t3DSLight));
  378|       |
  379|       |				// Store it, then add the read bytes to our byte counter.
  380|      0|				memcpy ((void*)pModel->pLights[pModel->numOfLights - 1].strName, (void*)strName, strlen(strName)+1);
  381|       |
  382|       |				// Read the position of the light
  383|      0|				ReadVector (pModel->pLights[pModel->numOfLights - 1].position, &currentChunk);
  384|       |
  385|       |				// Now proceed to read in the rest of the object information
  386|      0|				ProcessNextLightChunk_3DS(pModel, &(pModel->pLights[pModel->numOfLights - 1]), &currentChunk);
  387|      0|			}
  388|      0|			break;
  389|       |
  390|       |			// a new camera
  391|      0|			case CHK3DS_4_N_CAMERA:
  392|      0|			{
  393|      0|				t3DSCamera newCamera; // This is used to add to our object list
  394|      0|				memset( &newCamera, 0, sizeof(t3DSCamera));
  395|       |
  396|       |				// Increase the object count
  397|      0|				pModel->numOfCameras++;
  398|       |
  399|       |				// Add a new tObject node to our list of objects
  400|      0|				pModel->pCameras.push_back(newCamera);
  401|       |
  402|       |				// Initialize the object and all it's data members
  403|      0|				memset(&(pModel->pCameras[pModel->numOfCameras - 1]), 0, sizeof(t3DSCamera));
  404|       |
  405|       |				// Store it, then add the read bytes to our byte counter.
  406|      0|				memcpy ((void*)pModel->pCameras[pModel->numOfCameras - 1].strName, (void*)strName, strlen(strName)+1);
  407|       |
  408|       |				// Read the data
  409|      0|				ReadVector (pModel->pCameras[pModel->numOfCameras - 1].position, &currentChunk);
  410|      0|				ReadVector (pModel->pCameras[pModel->numOfCameras - 1].target, &currentChunk);
  411|      0|				ReadFloat32 (&pModel->pCameras[pModel->numOfCameras - 1].bank, &currentChunk);
  412|      0|				ReadFloat32 (&pModel->pCameras[pModel->numOfCameras - 1].lens, &currentChunk);
  413|       |
  414|       |				// Now proceed to read in the rest of the object information
  415|      0|				ProcessNextCameraChunk_3DS(pModel, &(pModel->pCameras[pModel->numOfCameras - 1]), &currentChunk);
  416|      0|			}
  417|      0|			break;
  418|       |
  419|      0|			default:
  420|      0|			{
  421|      0|				if (trace_unknown_chunks)
  422|      0|				{
  423|      0|					StoreUnknownChunk (pModel, pPreviousChunk->ID, currentChunk.ID);
  424|       |					//printf ("0x%04x 0x%04x\n", pPreviousChunk->ID, currentChunk.ID);
  425|      0|				}
  426|       |				// Read past the ignored or unknown chunks
  427|      0|				currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
  428|      0|			}
  429|      0|			break;
  430|      4|		}
  431|       |
  432|       |		// Add the bytes read from the last chunk to the previous chunk passed in.
  433|      4|		pPreviousChunk->bytesRead += currentChunk.bytesRead;
  434|      4|	}
  435|      4|}
  436|       |
  437|       |//*****************************************************************************
  438|       |//
  439|       |//*****************************************************************************
  440|       |void ProcessNextTriMeshChunk_3DS (t3DSModel *pModel, t3DSObject *pObject, t3DSChunk *pPreviousChunk)
  441|      4|{
  442|       |	// The current chunk to work with
  443|      4|	t3DSChunk currentChunk;
  444|      4|	memset( &currentChunk, 0, sizeof(t3DSChunk));
  445|       |
  446|       |	// Continue to read these chunks until we read the end of this sub chunk
  447|     28|	while (pPreviousChunk->bytesRead < pPreviousChunk->length)
  448|     24|	{
  449|       |		// Read the next chunk
  450|     24|		ReadChunk_3DS(&currentChunk);
  451|       |
  452|       |		// Check which chunk we just read
  453|     24|		switch (currentChunk.ID)
  454|     24|		{
  455|       |			// new object
  456|      0|			case CHK3DS_4_N_TRI_OBJECT:
  457|      0|			{
  458|      0|				ProcessNextTriMeshChunk_3DS(pModel, pObject, &currentChunk);
  459|      0|			}
  460|      0|			break;
  461|       |
  462|       |			// vertices
  463|      4|			case CHK3DS_4_POINT_ARRAY:
  464|      4|			{
  465|      4|				ReadVertices_3DS(pObject, &currentChunk);
  466|      4|			}
  467|      4|			break;
  468|       |
  469|       |			// face information
  470|      4|			case CHK3DS_4_FACE_ARRAY:
  471|      4|			{
  472|      4|				ReadVertexIndices_3DS(pObject, &currentChunk);
  473|      4|			}
  474|      4|			break;
  475|       |
  476|       |			// material name
  477|      4|			case CHK3DS_4_MSH_MAT_GROUP:
  478|      4|			{
  479|      4|				t3DSFacesMaterialList newFacesMaterialList;
  480|      4|				memset( &newFacesMaterialList, 0, sizeof(t3DSFacesMaterialList));
  481|       |
  482|       |				// Increase the material count
  483|      4|				pObject->numOfMaterials++;
  484|       |
  485|       |				// Add a new tObject node to our list of objects
  486|      4|				pObject->pFacesMaterialList.push_back(newFacesMaterialList);
  487|       |
  488|       |				// Initialize the structure and all the data members
  489|      4|				memset(&(pObject->pFacesMaterialList[pObject->numOfMaterials - 1]), 0, sizeof(t3DSFacesMaterialList));
  490|       |
  491|      4|				ReadObjectMaterial_3DS(pModel, pObject, &currentChunk);
  492|      4|			}
  493|      4|			break;
  494|       |
  495|       |			// UV texture coordinates for the object
  496|      4|			case CHK3DS_4_TEX_VERTS:
  497|      4|			{
  498|      4|				ReadUVCoordinates_3DS(pObject, &currentChunk);
  499|      4|			}
  500|      4|			break;
  501|       |/*
  502|       |			case CHK3DS_4_SMOOTH_GROUP:
  503|       |			{
  504|       |				INT32 *faceSmoothingGroup = new INT32[pObject->numOfFaces];
  505|       |				currentChunk.bytesRead += fread(faceSmoothingGroup, 1, pObject->numOfFaces*sizeof(INT32), g_File3DSPointer);
  506|       |				delete faceSmoothingGroup;
  507|       |			}
  508|       |			break;
  509|       |*/
  510|      4|			case CHK3DS_4_MESH_MATRIX:
  511|      4|			{
  512|      4|				ReadLocalCoordinateSystem_3DS(pObject, &currentChunk);
  513|       |				//currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
  514|      4|			}
  515|      4|			break;
  516|       |
  517|      0|			case CHK3DS_4_MESH_COLOR:
  518|      0|			{
  519|      0|				assert (false);
  520|      0|				BYTE color;
  521|      0|				ReadBYTE (&color, &currentChunk);
  522|       |				//currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
  523|      0|			}
  524|      0|			break;
  525|       |
  526|      4|			default:
  527|      4|			{
  528|       |				// Read past the ignored or unknown chunks
  529|      4|				if (trace_unknown_chunks)
  530|      4|				{
  531|      4|					StoreUnknownChunk (pModel, pPreviousChunk->ID, currentChunk.ID);
  532|       |					//printf ("0x%04x 0x%04x\n", pPreviousChunk->ID, currentChunk.ID);
  533|      4|				}
  534|      4|				currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
  535|      4|			}
  536|      4|			break;
  537|     24|		}
  538|       |
  539|       |		// Add the bytes read from the last chunk to the previous chunk passed in.
  540|     24|		pPreviousChunk->bytesRead += currentChunk.bytesRead;
  541|     24|	}
  542|      4|}
  543|       |
  544|       |//*****************************************************************************
  545|       |//
  546|       |//*****************************************************************************
  547|       |void ProcessNextLightChunk_3DS (t3DSModel *pModel, t3DSLight *pLight, t3DSChunk *pPreviousChunk)
  548|      0|{
  549|       |	// The current chunk to work with
  550|      0|	t3DSChunk currentChunk;
  551|      0|	memset( &currentChunk, 0, sizeof(t3DSChunk));
  552|       |
  553|       |	// Continue to read these chunks until we read the end of this sub chunk
  554|      0|	while (pPreviousChunk->bytesRead < pPreviousChunk->length)
  555|      0|	{
  556|       |		// Read the next chunk
  557|      0|		ReadChunk_3DS(&currentChunk);
  558|       |
  559|       |		// Check which chunk we just read
  560|      0|		switch (currentChunk.ID)
  561|      0|		{
  562|       |			// Spot Light
  563|      0|			case CHK3DS_4_DL_SPOTLIGHT:
  564|      0|			{
  565|      0|				pLight->isSpotLight = true;
  566|      0|				ReadVector (pLight->spotLight_target, &currentChunk);    // target
  567|      0|				ReadFloat32 (&pLight->spotLight_hotSpot, &currentChunk); // hotSpot
  568|      0|				ReadFloat32 (&pLight->spotLight_fallOff, &currentChunk); // fallOff
  569|      0|			}
  570|      0|			break;
  571|       |
  572|       |			// RGB color (float format)
  573|      0|			case CHK3DS_0_COLOR_F:
  574|      0|			{
  575|      0|				ReadRGBColorFloat (pLight->color, &currentChunk);
  576|      0|			}
  577|      0|			break;
  578|       |
  579|      0|			case CHK3DS_4_DL_ATTENUATE:
  580|      0|				{
  581|      0|					pLight->attenuate;
  582|      0|				}
  583|      0|				break;
  584|       |
  585|      0|			case CHK3DS_4_DL_SHADOWED:
  586|      0|				{
  587|      0|					pLight->isShadowed = TRUE;
  588|      0|				}
  589|      0|				break;
  590|       |
  591|      0|			case CHK3DS_4_DL_LOCAL_SHADOW2:
  592|      0|				{
  593|      0|					ReadFloat32 (&pLight->shadowBias, &currentChunk);
  594|      0|					ReadFloat32 (&pLight->shadowFilter, &currentChunk);
  595|      0|					ReadINT16	(&pLight->shadowSize, &currentChunk);
  596|      0|				}
  597|      0|				break;
  598|       |
  599|      0|			case CHK3DS_4_DL_SPOT_ROLL:
  600|      0|				{
  601|      0|					ReadFloat32 (&pLight->roll, &currentChunk);
  602|      0|				}
  603|      0|				break;
  604|       |
  605|      0|			case CHK3DS_4_DL_RAY_BIAS:
  606|      0|				{
  607|      0|					ReadFloat32 (&pLight->rayBias, &currentChunk);
  608|      0|				}
  609|      0|				break;
  610|       |
  611|       |			//
  612|      0|			case CHK3DS_4_DL_INNER_RANGE:
  613|      0|			{
  614|      0|				ReadFloat32 (&pLight->innerRange, &currentChunk);
  615|      0|			}
  616|      0|			break;
  617|       |
  618|       |			//
  619|      0|			case CHK3DS_4_DL_OUTER_RANGE:
  620|      0|				{
  621|      0|					ReadFloat32 (&pLight->outerRange, &currentChunk);
  622|      0|				}
  623|      0|				break;
  624|       |
  625|       |			//
  626|      0|			case CHK3DS_4_DL_MULTIPLIER:
  627|      0|			{
  628|      0|				ReadFloat32 (&pLight->multiplier, &currentChunk);
  629|      0|			}
  630|      0|			break;
  631|       |
  632|       |/*
  633|       |			case CHK3DS_4_DL_SPOT_OVERSHOOT:
  634|       |			{
  635|       |				currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
  636|       |			}
  637|       |			break;
  638|       |*/
  639|       |
  640|      0|			default:
  641|      0|			{
  642|       |				// Read past the ignored or unknown chunks
  643|      0|				if (trace_unknown_chunks)
  644|      0|				{
  645|      0|					StoreUnknownChunk (pModel, pPreviousChunk->ID, currentChunk.ID);
  646|       |					//printf ("0x%04x 0x%04x\n", pPreviousChunk->ID, currentChunk.ID);
  647|      0|				}
  648|      0|				currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
  649|      0|			}
  650|      0|			break;
  651|      0|		}
  652|       |
  653|       |		// Add the bytes read from the last chunk to the previous chunk passed in.
  654|      0|		pPreviousChunk->bytesRead += currentChunk.bytesRead;
  655|      0|	}
  656|      0|}
  657|       |
  658|       |//*****************************************************************************
  659|       |//
  660|       |//*****************************************************************************
  661|       |void ProcessNextCameraChunk_3DS (t3DSModel *pModel, t3DSCamera *pCamera, t3DSChunk *pPreviousChunk)
  662|      0|{
  663|       |	// The current chunk to work with
  664|      0|	t3DSChunk currentChunk;
  665|      0|	memset( &currentChunk, 0, sizeof(t3DSChunk));
  666|       |
  667|       |	// Continue to read these chunks until we read the end of this sub chunk
  668|      0|	while (pPreviousChunk->bytesRead < pPreviousChunk->length)
  669|      0|	{
  670|       |		// Read the next chunk
  671|      0|		ReadChunk_3DS(&currentChunk);
  672|       |
  673|       |		// Check which chunk we just read
  674|      0|		switch (currentChunk.ID)
  675|      0|		{
  676|       |/*
  677|       |		case CHK3DS_4_CAM_RANGES:
  678|       |			{
  679|       |				FLOAT32 near_range, far_range;
  680|       |				ReadFloat32 (&near_range, &currentChunk);
  681|       |				ReadFloat32 (&far_range, &currentChunk);
  682|       |			}
  683|       |			break;
  684|       |*/
  685|      0|		default:
  686|      0|			{
  687|       |				// Read past the ignored or unknown chunks
  688|      0|				if (trace_unknown_chunks)
  689|      0|				{
  690|      0|					StoreUnknownChunk (pModel, pPreviousChunk->ID, currentChunk.ID);
  691|       |					//printf ("0x%04x 0x%04x\n", pPreviousChunk->ID, currentChunk.ID);
  692|      0|				}
  693|      0|				currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
  694|      0|			}
  695|      0|			break;
  696|      0|		}
  697|       |
  698|       |		// Add the bytes read from the last chunk to the previous chunk passed in.
  699|      0|		pPreviousChunk->bytesRead += currentChunk.bytesRead;
  700|      0|	}
  701|      0|}
  702|       |
  703|       |//*****************************************************************************
  704|       |//
  705|       |//*****************************************************************************
  706|       |void ProcessNextKeyFrameChunk_3DS (t3DSModel* pModel, t3DSChunk *pPreviousChunk)
  707|      0|{
  708|       |	// The current chunk to work with
  709|      0|	t3DSChunk currentChunk;
  710|      0|	memset( &currentChunk, 0, sizeof(t3DSChunk));
  711|       |
  712|       |	// Continue to read these chunks until we read the end of this sub chunk
  713|      0|	while (pPreviousChunk->bytesRead < pPreviousChunk->length)
  714|      0|	{
  715|       |		// Read the next chunk
  716|      0|		ReadChunk_3DS(&currentChunk);
  717|       |
  718|       |		// Check which chunk we just read
  719|      0|		switch (currentChunk.ID)
  720|      0|		{
  721|      0|			case CHK3DS_B_AMBIENT_NODE_TAG:
  722|      0|			{
  723|      0|				currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
  724|      0|			}
  725|      0|			break;
  726|       |
  727|      0|			case CHK3DS_B_OBJECT_NODE_TAG:
  728|      0|			{
  729|       |				// allocation
  730|      0|				t3DSAnimation newAnimation;
  731|      0|				memset( &newAnimation, 0, sizeof(t3DSAnimation));
  732|       |
  733|       |				// insert
  734|      0|				pModel->numOfAnimations++; // Increase the number of animations
  735|      0|				pModel->pAnimations.push_back(newAnimation); // Add an empty animation structure to our animations list
  736|       |
  737|       |				// init
  738|      0|				pModel->pAnimations[pModel->numOfAnimations - 1].objectType = CHK3DS_B_OBJECT_NODE_TAG;
  739|       |
  740|       |				// parse
  741|      0|				ProcessKeyFrameChunk_3DS (pModel, &currentChunk);
  742|       |
  743|       |				//currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
  744|      0|			}
  745|      0|			break;
  746|       |/*
  747|       |			case CHK3DS_B_CAMERA_NODE_TAG:
  748|       |			{
  749|       |				currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
  750|       |			}
  751|       |			break;
  752|       |
  753|       |			case CHK3DS_B_TARGET_NODE_TAG:
  754|       |			{
  755|       |				currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
  756|       |			}
  757|       |			break;
  758|       |
  759|       |			case CHK3DS_B_LIGHT_NODE_TAG:
  760|       |			{
  761|       |				currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
  762|       |			}
  763|       |			break;
  764|       |
  765|       |			case CHK3DS_B_L_TARGET_NODE_TAG:
  766|       |			{
  767|       |				currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
  768|       |			}
  769|       |			break;
  770|       |
  771|       |			case CHK3DS_B_SPOTLIGHT_NODE_TAG:
  772|       |			{
  773|       |				currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
  774|       |			}
  775|       |			break;
  776|       |*/
  777|       |			////
  778|       |
  779|      0|			case CHK3DS_B_KFSEG:
  780|      0|			{
  781|       |				//cout << "CHK3DS_B_KFSEG (08)" << endl;
  782|      0|				INT32 start, end;
  783|      0|				ReadINT32 (&start, &currentChunk);
  784|      0|				ReadINT32 (&end, &currentChunk);
  785|       |				//cout << "   " << start << " - " << end << endl;
  786|       |				//currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
  787|      0|			}
  788|      0|			break;
  789|       |
  790|       |/*
  791|       |			case CHK3DS_B_KFCURTIME:
  792|       |			{
  793|       |				currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
  794|       |			}
  795|       |			break;
  796|       |
  797|       |			case CHK3DS_B_KFHDR:
  798|       |			{
  799|       |				currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
  800|       |			}
  801|       |			break;
  802|       |
  803|       |			case CHK3DS_B_INSTANCE_NAME:
  804|       |			{
  805|       |				currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
  806|       |			}
  807|       |			break;
  808|       |
  809|       |			case CHK3DS_B_PRESCALE:
  810|       |			{
  811|       |				currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
  812|       |			}
  813|       |			break;
  814|       |
  815|       |			case CHK3DS_B_BOUNDBOX:
  816|       |			{
  817|       |				currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
  818|       |			}
  819|       |			break;
  820|       |
  821|       |			case CHK3DS_B_MORPH_SMOOTH:
  822|       |			{
  823|       |				currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
  824|       |			}
  825|       |			break;
  826|       |
  827|       |
  828|       |
  829|       |
  830|       |*/
  831|      0|			default:
  832|      0|			{
  833|       |				// Read past the ignored or unknown chunks
  834|      0|				if (trace_unknown_chunks)
  835|      0|				{
  836|      0|					StoreUnknownChunk (pModel, pPreviousChunk->ID, currentChunk.ID);
  837|       |					//printf ("0x%04x 0x%04x\n", pPreviousChunk->ID, currentChunk.ID);
  838|      0|				}
  839|      0|				currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
  840|      0|			}
  841|      0|			break;
  842|      0|		}
  843|       |
  844|       |		// Add the bytes read from the last chunk to the previous chunk passed in.
  845|      0|		pPreviousChunk->bytesRead += currentChunk.bytesRead;
  846|      0|	}
  847|      0|}
  848|       |
  849|       |//*****************************************************************************
  850|       |//
  851|       |//*****************************************************************************
  852|       |void ProcessKeyFrameChunk_3DS (t3DSModel* pModel, t3DSChunk *pPreviousChunk)
  853|      0|{
  854|       |	// The current chunk to work with
  855|      0|	t3DSChunk currentChunk;
  856|      0|	memset( &currentChunk, 0, sizeof(t3DSChunk));
  857|       |
  858|       |	// Continue to read these chunks until we read the end of this sub chunk
  859|      0|	while (pPreviousChunk->bytesRead < pPreviousChunk->length)
  860|      0|	{
  861|       |		// Read the next chunk
  862|      0|		ReadChunk_3DS(&currentChunk);
  863|       |
  864|       |		// Check which chunk we just read
  865|      0|		switch (currentChunk.ID)
  866|      0|		{
  867|      0|			case CHK3DS_B_NODE_HDR:
  868|      0|			{
  869|      0|				char strName[255] = {0};
  870|      0|				INT16 flag1, flag2, hierarchyFather;
  871|       |
  872|       |				//cout << " (10) CHK3DS_B_NODE_HDR : ";
  873|      0|				currentChunk.bytesRead += GetString (strName);
  874|       |				//cout << strName;
  875|      0|				ReadINT16 (&flag1, &currentChunk);
  876|      0|				ReadINT16 (&flag2, &currentChunk);
  877|      0|				ReadINT16 (&hierarchyFather, &currentChunk);
  878|       |				//cout << "    hierarchyFather : " << hierarchyFather << endl;
  879|       |				
  880|       |				//currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
  881|      0|			}
  882|      0|			break;
  883|       |
  884|      0|			case CHK3DS_B_PIVOT:
  885|      0|			{
  886|      0|				FLOAT32 pivot[3];
  887|      0|				ReadVector (pivot, &currentChunk);
  888|       |				//cout << " (13) CHK3DS_B_PIVOT : pivot : " << pivot[0] << " , " << pivot[1] << " , " << pivot[2] << endl;
  889|      0|			}
  890|      0|			break;
  891|       |
  892|      0|			case CHK3DS_B_POS_TRACK_TAG:
  893|      0|			{
  894|       |				// new position track
  895|      0|				t3DSPositionTrack *newPositionTrack = new t3DSPositionTrack;
  896|       |
  897|       |				// process the header
  898|      0|				ProcessTrackHeader (&newPositionTrack->header, &currentChunk);
  899|       |
  900|       |				// process the data
  901|      0|				newPositionTrack->position = new FLOAT32[3*newPositionTrack->header.numOfKeys];
  902|      0|				for (int i=0; i<newPositionTrack->header.numOfKeys; i++)
  903|      0|				{
  904|      0|					ReadINT32 (&newPositionTrack->header.keyNumber[i], &currentChunk);
  905|      0|					ReadINT16 (&newPositionTrack->header.accelerationDataPresent[i], &currentChunk);
  906|      0|					ReadVector (newPositionTrack->position+3*i, pPreviousChunk);
  907|      0|				}
  908|       |
  909|       |				// insert
  910|      0|				pModel->pAnimations[pModel->numOfAnimations - 1].nTracks++;
  911|      0|				pModel->pAnimations[pModel->numOfAnimations - 1].trackType.push_back(CHK3DS_B_POS_TRACK_TAG);
  912|      0|				pModel->pAnimations[pModel->numOfAnimations - 1].track.push_back(newPositionTrack);
  913|      0|			}
  914|      0|			break;
  915|       |
  916|      0|			case CHK3DS_B_ROT_TRACK_TAG:
  917|      0|			{
  918|       |				// new rotation track
  919|      0|				t3DSRotationTrack *newRotationTrack = new t3DSRotationTrack;
  920|       |
  921|       |				// process the header
  922|      0|				ProcessTrackHeader (&newRotationTrack->header, &currentChunk);
  923|       |
  924|       |				// process the data
  925|      0|				newRotationTrack->angle = new FLOAT32[newRotationTrack->header.numOfKeys];
  926|      0|				newRotationTrack->axis = new FLOAT32[3*newRotationTrack->header.numOfKeys];
  927|      0|				for (int i=0; i<newRotationTrack->header.numOfKeys; i++)
  928|      0|				{
  929|      0|					ReadINT32 (&newRotationTrack->header.keyNumber[i], &currentChunk);
  930|      0|					ReadINT16 (&newRotationTrack->header.accelerationDataPresent[i], &currentChunk);
  931|      0|					ReadFloat32 (&newRotationTrack->angle[i], pPreviousChunk);
  932|      0|					ReadVector (newRotationTrack->axis+3*i, pPreviousChunk);
  933|      0|				}
  934|       |
  935|       |				// insert
  936|      0|				pModel->pAnimations[pModel->numOfAnimations - 1].nTracks++;
  937|      0|				pModel->pAnimations[pModel->numOfAnimations - 1].trackType.push_back(CHK3DS_B_ROT_TRACK_TAG);
  938|      0|				pModel->pAnimations[pModel->numOfAnimations - 1].track.push_back(newRotationTrack);
  939|      0|			}
  940|      0|			break;
  941|       |
  942|      0|			case CHK3DS_B_SCL_TRACK_TA:
  943|      0|			{
  944|       |				// new scale track
  945|      0|				t3DSScaleTrack *newScaleTrack = new t3DSScaleTrack;
  946|       |
  947|       |				// process the header
  948|      0|				ProcessTrackHeader (&newScaleTrack->header, &currentChunk);
  949|       |
  950|       |				// process the data
  951|      0|				newScaleTrack->size = new FLOAT32[3*newScaleTrack->header.numOfKeys];
  952|      0|				for (int i=0; i<newScaleTrack->header.numOfKeys; i++)
  953|      0|				{
  954|      0|					ReadINT32 (&newScaleTrack->header.keyNumber[i], &currentChunk);
  955|      0|					ReadINT16 (&newScaleTrack->header.accelerationDataPresent[i], &currentChunk);
  956|      0|					ReadVector (newScaleTrack->size+3*i, pPreviousChunk);
  957|      0|				}
  958|       |
  959|       |				// insert
  960|      0|				pModel->pAnimations[pModel->numOfAnimations - 1].nTracks++;
  961|      0|				pModel->pAnimations[pModel->numOfAnimations - 1].trackType.push_back(CHK3DS_B_SCL_TRACK_TA);
  962|      0|				pModel->pAnimations[pModel->numOfAnimations - 1].track.push_back(newScaleTrack);
  963|      0|			}
  964|      0|			break;
  965|       |
  966|       |/*
  967|       |			case CHK3DS_B_FOV_TRACK_TAG:
  968|       |			{
  969|       |				currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
  970|       |			}
  971|       |			break;
  972|       |
  973|       |			case CHK3DS_B_ROLL_TRACK_TAG:
  974|       |			{
  975|       |				currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
  976|       |			}
  977|       |			break;
  978|       |
  979|       |			case CHK3DS_B_COL_TRACK_TAG:
  980|       |			{
  981|       |				currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
  982|       |			}
  983|       |			break;
  984|       |
  985|       |			case CHK3DS_B_MORPH_TRACK_TAG:
  986|       |			{
  987|       |				currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
  988|       |			}
  989|       |			break;
  990|       |
  991|       |			case CHK3DS_B_HOT_TRACK_TAG:
  992|       |			{
  993|       |				currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
  994|       |			}
  995|       |			break;
  996|       |
  997|       |			case CHK3DS_B_FALL_TRACK_TAG:
  998|       |			{
  999|       |				currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1000|       |			}
 1001|       |			break;
 1002|       |
 1003|       |			case CHK3DS_B_HIDE_TRACK_TAG:
 1004|       |			{
 1005|       |				currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1006|       |			}
 1007|       |			break;
 1008|       |
 1009|       |			case CHK3DS_B_NODE_ID:
 1010|       |			{
 1011|       |				INT16 hierarchy;
 1012|       |				ReadINT16 (&hierarchy, &currentChunk);
 1013|       |				//currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1014|       |			}
 1015|       |			break;
 1016|       |*/
 1017|      0|			default:
 1018|      0|			{
 1019|       |				// Read past the ignored or unknown chunks
 1020|      0|				if (trace_unknown_chunks)
 1021|      0|				{
 1022|      0|					StoreUnknownChunk (pModel, pPreviousChunk->ID, currentChunk.ID);
 1023|       |					//printf ("0x%04x 0x%04x\n", pPreviousChunk->ID, currentChunk.ID);
 1024|      0|				}
 1025|      0|				currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1026|      0|			}
 1027|      0|			break;
 1028|      0|		}
 1029|       |
 1030|       |		// Add the bytes read from the last chunk to the previous chunk passed in.
 1031|      0|		pPreviousChunk->bytesRead += currentChunk.bytesRead;
 1032|      0|	}
 1033|      0|}
 1034|       |
 1035|       |//*****************************************************************************
 1036|       |//
 1037|       |//*****************************************************************************
 1038|       |void ProcessTrackHeader (t3DSTrackHeader* pTrackHeader, t3DSChunk *pPreviousChunk)
 1039|      0|{
 1040|      0|	ReadINT16 (&pTrackHeader->flag, pPreviousChunk);
 1041|      0|	ReadINT32 (&pTrackHeader->unknown1, pPreviousChunk);
 1042|      0|	ReadINT32 (&pTrackHeader->unknown2, pPreviousChunk);
 1043|      0|	ReadINT32 (&pTrackHeader->numOfKeys, pPreviousChunk);
 1044|      0|	pTrackHeader->keyNumber = new INT32[pTrackHeader->numOfKeys];
 1045|      0|	pTrackHeader->accelerationDataPresent = new INT16[pTrackHeader->numOfKeys];
 1046|      0|}
 1047|       |
 1048|       |//*****************************************************************************
 1049|       |//
 1050|       |//
 1051|       |//
 1052|       |//*****************************************************************************
 1053|       |void ProcessNextMaterialChunk_3DS(t3DSModel *pModel, t3DSChunk *pPreviousChunk)
 1054|      3|{
 1055|       |	// The current chunk to work with
 1056|      3|	t3DSChunk currentChunk;
 1057|      3|	memset( &currentChunk, 0, sizeof(t3DSChunk));
 1058|       |
 1059|       |	// Continue to read these chunks until we read the end of this sub chunk
 1060|     35|	while (pPreviousChunk->bytesRead < pPreviousChunk->length)
 1061|     32|	{
 1062|       |		// Read the next chunk
 1063|     32|		ReadChunk_3DS(&currentChunk);
 1064|       |
 1065|       |		// Check which chunk we just read in
 1066|     32|		switch (currentChunk.ID)
 1067|     32|		{
 1068|       |/*
 1069|       |		case CHK3DS_0_INT_PERCENTAGE:	//
 1070|       |			currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1071|       |			break;
 1072|       |			*/
 1073|       |
 1074|      2|		case CHK3DS_A_MAT_NAME:							// This chunk holds the name of the material
 1075|       |			// Here we read in the material name
 1076|      2|			currentChunk.bytesRead += fread(pModel->pMaterials[pModel->numOfMaterials - 1].strName, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1077|      2|			break;
 1078|       |
 1079|      2|		case CHK3DS_A_MAT_AMBIENT:						// This holds the R G B color of our object
 1080|      2|			ReadColorChunk_3DS((BYTE*)&(pModel->pMaterials[pModel->numOfMaterials - 1]).sMaterial.Ambient, &currentChunk);
 1081|      2|			break;
 1082|       |
 1083|      2|		case CHK3DS_A_MAT_DIFFUSE:						// This holds the R G B color of our object
 1084|      2|			ReadColorChunk_3DS((BYTE*)&(pModel->pMaterials[pModel->numOfMaterials - 1]).sMaterial.Diffuse, &currentChunk);
 1085|      2|			break;
 1086|       |
 1087|      2|		case CHK3DS_A_MAT_SPECULAR:						// This holds the R G B color of our object
 1088|      2|			ReadColorChunk_3DS((BYTE*)&(pModel->pMaterials[pModel->numOfMaterials - 1]).sMaterial.Specular, &currentChunk);
 1089|      2|			break;
 1090|       |
 1091|      2|		case CHK3DS_A_MAT_SHININESS:	//Shininess percentage
 1092|      2|			ReadPercentageChunk_3DS(&(pModel->pMaterials[pModel->numOfMaterials - 1]).sMaterial.Power, &currentChunk);
 1093|      2|			break;
 1094|       |
 1095|      2|		case CHK3DS_A_MAT_SHIN2PCT:	//
 1096|      2|			{
 1097|      2|				FLOAT32 percentage;
 1098|      2|				ReadPercentageChunk_3DS (&percentage, &currentChunk);
 1099|      2|			}
 1100|      2|			break;
 1101|       |/*
 1102|       |		case CHK3DS_A_MAT_SHIN3PCT:	//
 1103|       |			currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1104|       |			break;
 1105|       |*/
 1106|      2|		case CHK3DS_A_MAT_TRANSPARENCY:	//Shininess percentage
 1107|      2|			ReadPercentageChunk_3DS(&(pModel->pMaterials[pModel->numOfMaterials - 1]).fTransparency, &currentChunk);
 1108|      2|			break;
 1109|       |/*
 1110|       |		case CHK3DS_A_MAT_XPFALL:	//
 1111|       |			{
 1112|       |				FLOAT32 percentage;
 1113|       |				ReadPercentageChunk_3DS (&percentage, &currentChunk);
 1114|       |			}
 1115|       |			break;
 1116|       |
 1117|       |		case CHK3DS_A_MAT_REFBLUR:	//
 1118|       |			{
 1119|       |				FLOAT32 percentage;
 1120|       |				ReadPercentageChunk_3DS (&percentage, &currentChunk);
 1121|       |				//cout << percentage << endl;
 1122|       |			}
 1123|       |			break;
 1124|       |
 1125|       |		case CHK3DS_A_MAT_SELF_ILLUM:	//
 1126|       |			currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1127|       |			break;
 1128|       |
 1129|       |		case CHK3DS_A_MAT_TWO_SIDE:	//
 1130|       |			//&(pModel->pMaterials[pModel->numOfMaterials - 1]).f2Sided
 1131|       |			currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1132|       |			break;
 1133|       |
 1134|       |		case CHK3DS_A_MAT_DECAL:	//
 1135|       |			currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1136|       |			break;
 1137|       |
 1138|       |		case CHK3DS_A_MAT_ADDITIVE:	//
 1139|       |			currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1140|       |			break;
 1141|       |
 1142|       |		case CHK3DS_A_MAT_SELF_ILPCT:	//
 1143|       |			{
 1144|       |				ReadPercentageChunk_3DS (&(pModel->pMaterials[pModel->numOfMaterials - 1]).fSelfIllum, &currentChunk);
 1145|       |				//currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1146|       |			}
 1147|       |			break;
 1148|       |
 1149|       |		case CHK3DS_A_MAT_WIRE:	//
 1150|       |			(pModel->pMaterials[pModel->numOfMaterials - 1]).bWire = TRUE;
 1151|       |			break;
 1152|       |
 1153|       |		case CHK3DS_A_MAT_SUPERSMP:	//
 1154|       |			currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1155|       |			break;
 1156|       |
 1157|       |		case CHK3DS_A_MAT_WIRESIZE:	//
 1158|       |			{
 1159|       |				currentChunk.bytesRead += fread(&(pModel->pMaterials[pModel->numOfMaterials - 1]).fWireThickness, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1160|       |			}
 1161|       |			break;
 1162|       |
 1163|       |		case CHK3DS_A_MAT_FACEMAP:	//
 1164|       |			currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1165|       |			break;
 1166|       |
 1167|       |		case CHK3DS_A_MAT_XPFALLIN:	//
 1168|       |			currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1169|       |			break;
 1170|       |
 1171|       |		case CHK3DS_A_MAT_PHONGSOFT:	//
 1172|       |			(pModel->pMaterials[pModel->numOfMaterials - 1]).bSoften = TRUE;
 1173|       |			break;
 1174|       |
 1175|       |		case CHK3DS_A_MAT_WIREABS:	//
 1176|       |			currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1177|       |			break;
 1178|       |
 1179|       |		case CHK3DS_A_MAT_SHADING:	//
 1180|       |			{
 1181|       |				INT16 res;
 1182|       |				ReadINT16 (&res, &currentChunk);
 1183|       |			}
 1184|       |			break;
 1185|       |*/
 1186|      1|		case CHK3DS_A_MAT_TEXMAP:							// This is the header for the texture info
 1187|       |			// Proceed to read in the material information
 1188|      1|			ProcessNextMaterialChunk_3DS(pModel, &currentChunk);
 1189|      1|			break;
 1190|       |
 1191|      1|		case CHK3DS_A_MAT_MAPNAME:						// This stores the file name of the material
 1192|       |		// Here we read in the material's file name
 1193|      1|			currentChunk.bytesRead += fread(pModel->pMaterials[pModel->numOfMaterials - 1].strFile, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1194|      1|			break;
 1195|       |/*
 1196|       |		case CHK3DS_A_MAT_SPECMAP:	//
 1197|       |			currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1198|       |			break;
 1199|       |
 1200|       |		case CHK3DS_A_MAT_OPACMAP:	//
 1201|       |			currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1202|       |			break;
 1203|       |
 1204|       |		case CHK3DS_A_MAT_REFLMAP:	//
 1205|       |			currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1206|       |			break;
 1207|       |
 1208|       |		case CHK3DS_A_MAT_BUMPMAP:	//
 1209|       |			currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1210|       |			break;
 1211|       |
 1212|       |		case CHK3DS_A_MAT_USE_XPFALL:	//
 1213|       |			currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1214|       |			break;
 1215|       |
 1216|       |		case CHK3DS_A_MAT_USE_REFBLUR:	//
 1217|       |			currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1218|       |			break;
 1219|       |
 1220|       |		case CHK3DS_A_MAT_BUMP_PERCENT:	//
 1221|       |			currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1222|       |			break;
 1223|       |
 1224|       |		//New for handling texture coordinates
 1225|       |		case CHK3DS_A_MAT_MAP_TILING :	//intsh    map options
 1226|       |			currentChunk.bytesRead += fread( &pModel->pMaterials[pModel->numOfMaterials - 1].wTiling, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1227|       |			break;
 1228|       |
 1229|       |		case CHK3DS_A_MAT_MAP_TEXBLUR_OLD :
 1230|       |			currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1231|       |			break;
 1232|       |
 1233|       |		case CHK3DS_A_MAT_MAP_TEXBLUR :	//float    map filtering blur ( 7% -> 0.07 )
 1234|       |			currentChunk.bytesRead += fread( &pModel->pMaterials[pModel->numOfMaterials - 1].fTexBlur, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1235|       |			break;
 1236|       |*/
 1237|      0|		case CHK3DS_A_MAT_MAP_USCALE :		//float 1/U scale
 1238|      0|			currentChunk.bytesRead += fread( &pModel->pMaterials[pModel->numOfMaterials - 1].uScale, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1239|      0|			break;
 1240|       |
 1241|      0|		case CHK3DS_A_MAT_MAP_VSCALE :		//float 1/V scale
 1242|      0|			currentChunk.bytesRead += fread( &pModel->pMaterials[pModel->numOfMaterials - 1].vScale, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1243|      0|			break;
 1244|       |
 1245|      0|		case CHK3DS_A_MAT_MAP_UOFFSET :		//float U offset 
 1246|      0|			currentChunk.bytesRead += fread(&pModel->pMaterials[pModel->numOfMaterials - 1].uOffset, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1247|      0|			break;
 1248|       |
 1249|      0|		case CHK3DS_A_MAT_MAP_VOFFSET :		//float V offset
 1250|      0|			currentChunk.bytesRead += fread(&pModel->pMaterials[pModel->numOfMaterials - 1].vOffset, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1251|      0|			break;
 1252|       |/*
 1253|       |		case CHK3DS_A_MAT_MAP_ANG :	//float    map rotation angle
 1254|       |			currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1255|       |			break;
 1256|       |
 1257|       |		case CHK3DS_A_MAT_MAP_COL1 :	//RGB      lum or alpha tint first color (default=00 00 00)
 1258|       |			currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1259|       |			break;
 1260|       |
 1261|       |		case CHK3DS_A_MAT_MAP_COL2 :	//RGB      lum or alpha tint secnd color (default=FF FF FF)
 1262|       |			currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1263|       |			break;
 1264|       |
 1265|       |		case CHK3DS_A_MAT_MAP_RCOL :	//RGB      RGB tint R channel color (default=FF 00 00)
 1266|       |			currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1267|       |			break;
 1268|       |
 1269|       |		case CHK3DS_A_MAT_MAP_GCOL :	//RGB      RGB tint G channel color (default=00 FF 00)
 1270|       |			currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1271|       |			break;
 1272|       |
 1273|       |		case CHK3DS_A_MAT_MAP_BCOL :	//RGB      RGB tint B channel color (default=00 00 FF)
 1274|       |			currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1275|       |			break;
 1276|       |*/
 1277|     16|		default:  
 1278|       |			// Read past the ignored or unknown chunks
 1279|     16|			if (trace_unknown_chunks)
 1280|     16|			{
 1281|     16|				StoreUnknownChunk (pModel, pPreviousChunk->ID, currentChunk.ID);
 1282|       |				//printf ("0x%04x 0x%04x\n", pPreviousChunk->ID, currentChunk.ID);
 1283|     16|			}
 1284|     16|			currentChunk.bytesRead += fread(gBuffer, 1, currentChunk.length - currentChunk.bytesRead, g_File3DSPointer);
 1285|     16|			break;
 1286|     32|		}
 1287|       |
 1288|       |		// Add the bytes read from the last chunk to the previous chunk passed in.
 1289|     32|		pPreviousChunk->bytesRead += currentChunk.bytesRead;
 1290|     32|	}
 1291|      3|}
 1292|       |
 1293|       |//*****************************************************************************
 1294|       |//
 1295|       |//*****************************************************************************
 1296|       |void ReadChunk_3DS(t3DSChunk *pChunk)
 1297|     84|{
 1298|       |	// This reads the chunk ID which is 2 bytes.
 1299|       |	// The chunk ID is like OBJECT or MATERIAL.  It tells what data is
 1300|       |	// able to be read in within the chunks section.  
 1301|     84|	pChunk->bytesRead = fread(&pChunk->ID, 1, 2, g_File3DSPointer);
 1302|       |
 1303|       |	// Then, we read the length of the chunk which is 4 bytes.
 1304|       |	// This is how we know how much to read in, or read past.
 1305|     84|	pChunk->bytesRead += fread(&pChunk->length, 1, 4, g_File3DSPointer);
 1306|     84|}
 1307|       |
 1308|       |//*****************************************************************************
 1309|       |//
 1310|       |//*****************************************************************************
 1311|       |int GetString(char *pBuffer)
 1312|      8|{
 1313|      8|	int index = 0;
 1314|       |
 1315|       |	// Read 1 byte of data which is the first letter of the string
 1316|      8|	fread(pBuffer, 1, 1, g_File3DSPointer);
 1317|       |
 1318|       |	// Loop until we get NULL
 1319|     47|	while (*(pBuffer + index++) != 0) {
 1320|       |
 1321|       |		// Read in a character at a time until we hit NULL.
 1322|     39|		fread(pBuffer + index, 1, 1, g_File3DSPointer);
 1323|     39|	}
 1324|       |
 1325|       |	// Return the string length, which is how many bytes we read in (including the NULL)
 1326|      8|	return strlen(pBuffer) + 1;
 1327|      8|}
 1328|       |
 1329|       |
 1330|       |//*****************************************************************************
 1331|       |//
 1332|       |//*****************************************************************************
 1333|       |void ReadColorChunk_3DS(BYTE *pColor, t3DSChunk *pChunk)
 1334|      6|{
 1335|      6|	t3DSChunk tempChunk;
 1336|      6|	memset( &tempChunk, 0, sizeof(t3DSChunk));
 1337|       |
 1338|       |	// Read the color chunk info
 1339|      6|	ReadChunk_3DS(&tempChunk);
 1340|       |
 1341|       |	// Read in the R G B color (3 bytes - 0 through 255)
 1342|      6|	tempChunk.bytesRead += fread(pColor, 1, tempChunk.length - tempChunk.bytesRead, g_File3DSPointer);
 1343|       |
 1344|       |	// Add the bytes read to our chunk
 1345|      6|	pChunk->bytesRead += tempChunk.bytesRead;
 1346|      6|}
 1347|       |
 1348|       |//*****************************************************************************
 1349|       |//
 1350|       |//*****************************************************************************
 1351|       |void ReadPercentageChunk_3DS(FLOAT32 *pPercentage, t3DSChunk *pChunk)
 1352|      6|{
 1353|      6|	t3DSChunk tempChunk;
 1354|      6|	memset( &tempChunk, 0, sizeof(t3DSChunk));
 1355|       |
 1356|       |	// Read the color chunk info
 1357|      6|	ReadChunk_3DS(&tempChunk);
 1358|       |
 1359|       |	// Read the percentage chunk
 1360|      6|	int wTemp = 0;
 1361|      6|	tempChunk.bytesRead += fread(&wTemp, 1, tempChunk.length - tempChunk.bytesRead, g_File3DSPointer);
 1362|       |
 1363|      6|	*pPercentage = wTemp;
 1364|       |
 1365|       |	// Add the bytes read to our chunk
 1366|      6|	pChunk->bytesRead += tempChunk.bytesRead;
 1367|      6|}
 1368|       |
 1369|       |//*****************************************************************************
 1370|       |//
 1371|       |//*****************************************************************************
 1372|       |void Read3DCoordinates_3DS (FLOAT32 pPosition[3], t3DSChunk *pChunk)
 1373|      0|{
 1374|      0|	pChunk->bytesRead += fread(pPosition, 3, sizeof(FLOAT32), g_File3DSPointer);
 1375|      0|}
 1376|       |
 1377|       |
 1378|       |
 1379|       |//*****************************************************************************
 1380|       |//
 1381|       |//*****************************************************************************
 1382|       |void ReadVertexIndices_3DS(t3DSObject *pObject, t3DSChunk *pPreviousChunk)
 1383|      4|{
 1384|      4|	unsigned short index = 0; // This is used to read in the current face index
 1385|       |
 1386|       |	// Read in the number of faces that are in this object (int)
 1387|      4|	pPreviousChunk->bytesRead += fread(&pObject->numOfFaces, 1, 2, g_File3DSPointer);
 1388|       |
 1389|       |	// Alloc enough memory for the faces and initialize the structure
 1390|      4|	pObject->pFaces = new t3DSFace [pObject->numOfFaces];
 1391|      4|	memset(pObject->pFaces, 0, sizeof(t3DSFace) * pObject->numOfFaces);
 1392|       |
 1393|       |	// Go through all of the faces in this object
 1394|       |	//FILE *ptr = fopen ("toto.obj", "a");
 1395|  1.07k|	for(int i = 0; i < pObject->numOfFaces; i++)
 1396|  1.06k|	{
 1397|       |		// Next, we read in the A then B then C index for the face, but ignore the 4th value.
 1398|       |		// The fourth value is a visibility flag for 3D Studio Max.
 1399|  5.34k|		for(int j = 0; j < 4; j++)
 1400|  4.27k|		{
 1401|       |			// Read the first vertex index for the current face 
 1402|  4.27k|			pPreviousChunk->bytesRead += fread(&index, 1, sizeof(index), g_File3DSPointer);
 1403|       |
 1404|  4.27k|			if(j < 3)
 1405|  3.20k|			{
 1406|       |				// Store the index in our face structure.
 1407|  3.20k|				pObject->pFaces[i].vertIndex[j] = index;
 1408|  3.20k|			}
 1409|  4.27k|		}
 1410|       |
 1411|  1.06k|		pObject->pFaces[i].materialID = -1;
 1412|       |		//fprintf (ptr, "f %d %d %d\n",
 1413|       |		//	1+pObject->pFaces[i].vertIndex[0], 1+pObject->pFaces[i].vertIndex[1], 1+pObject->pFaces[i].vertIndex[2]);
 1414|  1.06k|	}
 1415|       |	//fclose (ptr);
 1416|      4|}
 1417|       |
 1418|       |//*****************************************************************************
 1419|       |//
 1420|       |//*****************************************************************************
 1421|       |void ReadUVCoordinates_3DS(t3DSObject *pObject, t3DSChunk *pPreviousChunk)
 1422|      4|{
 1423|       |	// In order to read in the UV indices for the object, we need to first
 1424|       |	// read in the amount there are, then read them in.
 1425|       |
 1426|       |	// Read in the number of UV coordinates there are (int)
 1427|      4|	pPreviousChunk->bytesRead += fread(&pObject->numTexVertex, 1, 2, g_File3DSPointer);
 1428|       |
 1429|       |	// Allocate memory to hold the UV coordinates
 1430|      4|	pObject->pTexVerts = new VECTOR2f [pObject->numTexVertex];
 1431|       |
 1432|       |	// Read in the texture coodinates (an array 2 float)
 1433|      4|	pPreviousChunk->bytesRead += fread(pObject->pTexVerts, 1, pPreviousChunk->length - pPreviousChunk->bytesRead, g_File3DSPointer);
 1434|      4|}
 1435|       |
 1436|       |
 1437|       |//*****************************************************************************
 1438|       |//
 1439|       |//*****************************************************************************
 1440|       |void ReadVertices_3DS(t3DSObject *pObject, t3DSChunk *pPreviousChunk)
 1441|      4|{
 1442|       |	// Like most chunks, before we read in the actual vertices, we need
 1443|       |	// to find out how many there are to read in.  Once we have that number
 1444|       |	// we then fread() them into our vertice array.
 1445|       |
 1446|       |	// Read in the number of vertices (int)
 1447|      4|	pPreviousChunk->bytesRead += fread(&(pObject->numOfVerts), 1, 2, g_File3DSPointer);
 1448|       |
 1449|       |	// Allocate the memory for the verts and initialize the structure
 1450|      4|	pObject->pVerts = new VECTOR3f [pObject->numOfVerts];
 1451|      4|	memset(pObject->pVerts, 0, sizeof(VECTOR3f) * pObject->numOfVerts);
 1452|       |
 1453|       |	// Read in the array of vertices (an array of 3 floats)
 1454|      4|	pPreviousChunk->bytesRead += fread(pObject->pVerts, 1, pPreviousChunk->length - pPreviousChunk->bytesRead, g_File3DSPointer);
 1455|       |
 1456|       |	// Now we should have all of the vertices read in.  Because 3D Studio Max
 1457|       |	// Models with the Z-Axis pointing up (strange and ugly I know!), we need
 1458|       |	// to flip the y values with the z values in our vertices.  That way it
 1459|       |	// will be normal, with Y pointing up.  If you prefer to work with Z pointing
 1460|       |	// up, then just delete this next loop.  Also, because we swap the Y and Z
 1461|       |	// we need to negate the Z to make it come out correctly.
 1462|       |
 1463|       |	// Go through all of the vertices that we just read and swap the Y and Z values
 1464|       |	//FILE *ptr = fopen ("toto.obj", "w");
 1465|    688|	for(int i = 0; i < pObject->numOfVerts; i++)
 1466|    684|	{
 1467|       |		// Store off the Y value
 1468|    684|		float fTempY = pObject->pVerts[i].fY;
 1469|       |
 1470|       |		// Set the Y value to the Z value
 1471|    684|		pObject->pVerts[i].fY = pObject->pVerts[i].fZ;
 1472|       |
 1473|       |		// Set the Z value to the Y value, 
 1474|       |		// but negative Z because 3D Studio max does the opposite.
 1475|    684|		pObject->pVerts[i].fZ = -fTempY;
 1476|       |//		pObject->pVerts[i].fZ = fTempY;
 1477|       |		//fprintf (ptr, "v %f %f %f\n", pObject->pVerts[i].fX, pObject->pVerts[i].fY, pObject->pVerts[i].fZ);
 1478|    684|	}
 1479|       |	//fclose (ptr);
 1480|      4|}
 1481|       |
 1482|       |
 1483|       |//*****************************************************************************
 1484|       |//
 1485|       |//*****************************************************************************
 1486|       |void ReadObjectMaterial_3DS(t3DSModel *pModel, t3DSObject *pObject, t3DSChunk *pPreviousChunk)
 1487|      4|{
 1488|      4|	char strMaterial[255] = {0};			// This is used to hold the objects material name
 1489|       |
 1490|       |	// A material is either the color or the texture map of the object.
 1491|       |	// It can also hold other information like the brightness, shine, etc... 
 1492|       |
 1493|       |	// material name that is assigned to the current object.
 1494|      4|	pPreviousChunk->bytesRead += GetString(strMaterial);
 1495|       |
 1496|       |	// Now that we have a material name, we need to go through all of the materials
 1497|       |	// and check the name against each material.  When we find a material in our material
 1498|       |	// list that matches this name we just read in, then we assign the materialID
 1499|       |	// of the object to that material index.
 1500|       |
 1501|       |	// Go through all of the textures
 1502|      4|	bool materialIDFound = FALSE;
 1503|      7|	for(int i = 0; i < pModel->numOfMaterials; i++)
 1504|      7|	{
 1505|       |		// If the material we just read in matches the current texture name
 1506|      7|		if(strcmp(strMaterial, pModel->pMaterials[i].strName) == 0)
 1507|      4|		{
 1508|      4|			materialIDFound = TRUE;
 1509|       |			// Set the material ID to the current index 'i' and stop checking
 1510|      4|			pObject->pFacesMaterialList[pObject->numOfMaterials - 1].materialID = i;
 1511|       |
 1512|       |			// Now that we found the material, check if it's a texture map.
 1513|       |			// If the strFile has a string length of 1 and over it's a texture
 1514|      4|			if(strlen(pModel->pMaterials[i].strFile) > 0) 
 1515|      1|			{				
 1516|       |				// Set the object's flag to say it has a texture map to bind.
 1517|      1|				pObject->bHasTexture = TRUE;
 1518|      1|			}	
 1519|      4|			break;
 1520|      4|		}
 1521|       |		/*
 1522|       |		else
 1523|       |		{
 1524|       |			// Here we check first to see if there is a texture already assigned to this object
 1525|       |			if(pObject->bHasTexture != TRUE)
 1526|       |			{
 1527|       |				// Set the ID to -1 to show there is no material for this object
 1528|       |				pObject->materialID = -1;
 1529|       |			}
 1530|       |		}
 1531|       |		*/
 1532|      7|	}
 1533|      4|	if (materialIDFound = FALSE)
 1534|      0|	{
 1535|       |		//problem
 1536|      0|		printf("No material ID found");
 1537|      0|	}
 1538|       |
 1539|       |
 1540|       |	// Read in the number of faces (short int)
 1541|      4|	UINT16 uiNbrFaces;
 1542|      4|	pPreviousChunk->bytesRead += fread(&uiNbrFaces, 1, 2, g_File3DSPointer);
 1543|      4|	pObject->pFacesMaterialList[pObject->numOfMaterials - 1].numOfFaces = uiNbrFaces;
 1544|      4|	pObject->pFacesMaterialList[pObject->numOfMaterials - 1].pFacesMaterialsList = (UINT16*)malloc(uiNbrFaces*sizeof(UINT16));
 1545|       |
 1546|       |	//Loop through all the faces
 1547|  1.07k|	for (UINT16 j=0; j<uiNbrFaces; j++)
 1548|  1.06k|	{
 1549|  1.06k|		UINT16 uiFacesID = 0;
 1550|  1.06k|		pPreviousChunk->bytesRead += fread(&uiFacesID, 1, sizeof(INT16), g_File3DSPointer);
 1551|       |		//pObject->pFaces[uiFacesID].materialID = pObject->materialID;
 1552|  1.06k|		pObject->pFacesMaterialList[pObject->numOfMaterials - 1].pFacesMaterialsList[j] = uiFacesID;
 1553|  1.06k|	}
 1554|      4|}
 1555|       |
 1556|       |//*****************************************************************************
 1557|       |//
 1558|       |//*****************************************************************************
 1559|       |void ReadLocalCoordinateSystem_3DS (t3DSObject *pObject, t3DSChunk *pPreviousChunk)
 1560|      4|{
 1561|      4|	FLOAT32 x1[3], x2[3], x3[3], O[3];
 1562|      4|	ReadVector (x1, pPreviousChunk);
 1563|      4|	ReadVector (x2, pPreviousChunk);
 1564|      4|	ReadVector (x3, pPreviousChunk);
 1565|      4|	ReadVector (O,  pPreviousChunk);
 1566|       |
 1567|      4|	pObject->LocalCoordinateSystem[0][0] = x1[0];	pObject->LocalCoordinateSystem[0][1] = x1[2];	pObject->LocalCoordinateSystem[0][2] = -x1[1];
 1568|      4|	pObject->LocalCoordinateSystem[1][0] = x2[0];	pObject->LocalCoordinateSystem[1][1] = x2[2];	pObject->LocalCoordinateSystem[1][2] = -x2[1];
 1569|      4|	pObject->LocalCoordinateSystem[2][0] = x3[0];	pObject->LocalCoordinateSystem[2][1] = x3[2];	pObject->LocalCoordinateSystem[2][2] = -x3[1];
 1570|      4|	pObject->LocalCoordinateSystem[3][0] = O[0];	pObject->LocalCoordinateSystem[3][1] = O[2];	pObject->LocalCoordinateSystem[3][2] = -O[1];
 1571|      4|}
 1572|       |
 1573|       |//*****************************************************************************
 1574|       |//
 1575|       |//*****************************************************************************
 1576|       |void StoreUnknownChunk (t3DSModel *pModel, UINT16 fatherID, UINT16 chunkID)
 1577|     20|{
 1578|     20|	t3DSUnknownChunk unknownChunk;
 1579|     20|	memset (&unknownChunk, 0, sizeof(t3DSUnknownChunk));
 1580|       |
 1581|       |	// is it already present ?
 1582|     20|	for (int i=0; i<pModel->numOfUnknownChunks;i++)
 1583|      0|	{
 1584|      0|		if (	pModel->pUnknownChunks[i].fatherID	==	fatherID
 1585|      0|			&&	pModel->pUnknownChunks[i].chunkID	==	chunkID		)
 1586|      0|		{
 1587|      0|			return;
 1588|      0|		}
 1589|      0|	}
 1590|       |
 1591|       |	// insert
 1592|       |	//pModel->numOfUnknownChunks++;					// Increase the number of unknown chunks
 1593|       |	//pModel->pUnknownChunks.push_back({ chunkID , fatherID });	// Add a newx animation structure to our animations list
 1594|     20|}
 1595|       |
 1596|       |/**
 1597|       |                     ____________________
 1598|       |                    /                   /
 1599|       |    ,-~~-.___.     |   SAVING PART !!! /
 1600|       |   / |  '     \   _|  ________________/
 1601|       |  (  )        0  /___/           
 1602|       |   \_/-, ,----'		         
 1603|       |      ====           //                    
 1604|       |     /  \-'~;    /~~~(O)
 1605|       |    /  __/~|   /       |    
 1606|       |  =(  _____| (_________|
 1607|       |			-Paul Hickey 
 1608|       |*/
 1609|       |
 1610|       |UINT32 WriteChunkHeader (UINT16 id_header, fpos_t *position)
 1611|      0|{
 1612|      0|	UINT32 chunkSize = sizeof(UINT16) + sizeof(UINT32);
 1613|       |
 1614|      0|	fwrite (&id_header, 1, sizeof(UINT16), g_File3DSPointer);	// write the chunk ID for the object
 1615|      0|	fgetpos (g_File3DSPointer, position);						// get the position
 1616|      0|	fwrite (&chunkSize, 1, sizeof(UINT32), g_File3DSPointer);	// write the size
 1617|       |
 1618|      0|	return chunkSize;
 1619|      0|}
 1620|       |
 1621|       |void WriteChunkFooter (fpos_t position, UINT32 chunkSize)
 1622|      0|{
 1623|      0|	fsetpos (g_File3DSPointer, &position);						// update the size of the current chunk
 1624|      0|	fwrite (&chunkSize, 1, sizeof(UINT32), g_File3DSPointer);	// write the size of the chunk
 1625|      0|	fseek (g_File3DSPointer, 0, SEEK_END);						// go to the end of the file
 1626|      0|}
 1627|       |
 1628|       |UINT32 WriteColorRGBFLOAT32 (FLOAT32 r, FLOAT32 g, FLOAT32 b)
 1629|      0|{
 1630|      0|	UINT16 chunkID		= CHK3DS_0_COLOR_F;
 1631|      0|	UINT32 chunkSize	= sizeof(UINT16) + sizeof(UINT32) + 3*sizeof(FLOAT32);
 1632|       |
 1633|      0|	fwrite (&chunkID, 1, sizeof(UINT16), g_File3DSPointer); // Write the chunk ID for the object
 1634|      0|	fwrite (&chunkSize, 1, sizeof(UINT32), g_File3DSPointer); // Write the size
 1635|       |
 1636|      0|	fwrite (&r, 1, sizeof(FLOAT32), g_File3DSPointer);
 1637|      0|	fwrite (&g, 1, sizeof(FLOAT32), g_File3DSPointer);
 1638|      0|	fwrite (&b, 1, sizeof(FLOAT32), g_File3DSPointer);
 1639|       |
 1640|      0|	return chunkSize;
 1641|      0|}
 1642|       |
 1643|       |UINT32 WriteColorRGB (BYTE r, BYTE g, BYTE b)
 1644|      0|{
 1645|      0|	UINT16 chunkID		= CHK3DS_0_COLOR_24;
 1646|      0|	UINT32 chunkSize	= sizeof(UINT16) + sizeof(UINT32) + 3*sizeof(BYTE);
 1647|       |
 1648|      0|	fwrite (&chunkID, 1, sizeof(UINT16), g_File3DSPointer); // Write the chunk ID for the object
 1649|      0|	fwrite (&chunkSize, 1, sizeof(UINT32), g_File3DSPointer); // Write the size
 1650|       |
 1651|      0|	fwrite (&r, 1, sizeof(BYTE), g_File3DSPointer);
 1652|      0|	fwrite (&g, 1, sizeof(BYTE), g_File3DSPointer);
 1653|      0|	fwrite (&b, 1, sizeof(BYTE), g_File3DSPointer);
 1654|       |
 1655|      0|	return chunkSize;
 1656|      0|}
 1657|       |
 1658|       |UINT32 WriteColorRGBA (BYTE r, BYTE g, BYTE b, BYTE a)
 1659|      0|{
 1660|      0|	UINT16 chunkID		= CHK3DS_0_LIN_COLOR_24;
 1661|      0|	UINT32 chunkSize	= sizeof(UINT16) + sizeof(UINT32) + 4*sizeof(BYTE);
 1662|       |
 1663|      0|	fwrite (&chunkID, 1, sizeof(UINT16), g_File3DSPointer); // Write the chunk ID for the object
 1664|      0|	fwrite (&chunkSize, 1, sizeof(UINT32), g_File3DSPointer); // Write the size
 1665|       |
 1666|      0|	fwrite (&r, 1, sizeof(BYTE), g_File3DSPointer);
 1667|      0|	fwrite (&g, 1, sizeof(BYTE), g_File3DSPointer);
 1668|      0|	fwrite (&b, 1, sizeof(BYTE), g_File3DSPointer);
 1669|      0|	fwrite (&a, 1, sizeof(BYTE), g_File3DSPointer);
 1670|       |
 1671|      0|	return chunkSize;
 1672|      0|}
 1673|       |
 1674|       |UINT32 WriteColorRGBAFLOAT32 (FLOAT32 r, FLOAT32 g, FLOAT32 b, FLOAT32 a)
 1675|      0|{
 1676|      0|	UINT16 chunkID		= CHK3DS_0_LIN_COLOR_F;
 1677|      0|	UINT32 chunkSize	= sizeof(UINT16) + sizeof(UINT32) + 4*sizeof(FLOAT32);
 1678|       |
 1679|      0|	fwrite (&chunkID, 1, sizeof(UINT16), g_File3DSPointer);		// Write the chunk ID for the object
 1680|      0|	fwrite (&chunkSize, 1, sizeof(UINT32), g_File3DSPointer);	// Write the size
 1681|       |
 1682|      0|	fwrite (&r, 1, sizeof(FLOAT32), g_File3DSPointer);
 1683|      0|	fwrite (&g, 1, sizeof(FLOAT32), g_File3DSPointer);
 1684|      0|	fwrite (&b, 1, sizeof(FLOAT32), g_File3DSPointer);
 1685|      0|	fwrite (&a, 1, sizeof(FLOAT32), g_File3DSPointer);
 1686|       |
 1687|      0|	return chunkSize;
 1688|      0|}
 1689|       |
 1690|       |//*****************************************************************************
 1691|       |// Save a 3DS structure into a file
 1692|       |// @param t3DSModel* - An OS independant structure describing the 3D model
 1693|       |// @param szFile - The path to the file to open
 1694|       |// @param ExtraParameters - Some extra parameters
 1695|       |// @return int - 0, an error code otherwise
 1696|       |//*****************************************************************************
 1697|       |int Write3DSFile (t3DSModel *pModel, char *szFile, void *ExtraParameters )
 1698|      0|{
 1699|      0|	int hr = 0;
 1700|       |
 1701|       |	// Check the file to save the 3DS structure :
 1702|       |	// if the given filename is not equal to NULL,
 1703|       |	// we consider the path stored in the 3DS structure
 1704|      0|	if (szFile == NULL)
 1705|      0|	{
 1706|      0|		szFile = pModel->strPathToModel;
 1707|      0|	}
 1708|       |
 1709|       |	// Open the 3DS file
 1710|      0|	g_File3DSPointer = fopen(szFile, "wb");
 1711|       |
 1712|       |	// Make sure we have a valid file pointer (we found the file)
 1713|      0|	char strMessage[255];
 1714|      0|	if(!g_File3DSPointer) 
 1715|      0|	{
 1716|      0|		printf("Unable to find the file: %s!", szFile);
 1717|      0|		return false;
 1718|      0|	}
 1719|       |
 1720|       |	// write the content of CHK3DS_4_M3DMAGIC
 1721|      0|	fpos_t position;
 1722|      0|	UINT32 chunkSize = WriteChunkHeader (CHK3DS_4_M3DMAGIC, &position);
 1723|      0|	chunkSize += WriteEditor (pModel); // write the 3D editor chunk
 1724|      0|	WriteChunkFooter (position, chunkSize);
 1725|      0|	CleanUp_3DS(); // Clean up after everything
 1726|       |
 1727|      0|	return hr;
 1728|      0|}
 1729|       |
 1730|       |//*****************************************************************************
 1731|       |// Write the 3D editor chunk
 1732|       |//*****************************************************************************
 1733|       |UINT32 WriteEditor (t3DSModel *pModel)
 1734|      0|{
 1735|      0|	fpos_t position;
 1736|      0|	UINT32 chunkSize = WriteChunkHeader (CHK3DS_3_MDATA, &position);
 1737|       |
 1738|       |	// Write the content of CHK3DS_3_MDATA
 1739|      0|	chunkSize += WriteMaterials (pModel);	// write the materials
 1740|      0|	chunkSize += WriteObjects (pModel);		// write the objects
 1741|      0|	chunkSize += WriteAnimations (pModel);	// write the animations
 1742|       |
 1743|      0|	WriteChunkFooter (position, chunkSize);
 1744|      0|	return chunkSize;
 1745|      0|}
 1746|       |
 1747|       |//*****************************************************************************
 1748|       |//
 1749|       |// Write the materials in the file
 1750|       |//
 1751|       |//*****************************************************************************
 1752|       |UINT32 WriteMaterials (t3DSModel *pModel)
 1753|      0|{
 1754|      0|	UINT32 chunkSize = 0;
 1755|       |
 1756|       |	// write the material
 1757|      0|	std::vector<t3DSMaterialInfo>::iterator iteratorVectorMaterial;
 1758|      0|	for(iteratorVectorMaterial = pModel->pMaterials.begin();
 1759|      0|		iteratorVectorMaterial != pModel->pMaterials.end();
 1760|      0|		iteratorVectorMaterial++)
 1761|      0|	{
 1762|      0|		t3DSMaterialInfo material = *(iteratorVectorMaterial);
 1763|      0|		chunkSize += WriteMaterial (&material);
 1764|      0|	}
 1765|       |
 1766|      0|	return chunkSize;
 1767|      0|}
 1768|       |
 1769|       |//*****************************************************************************
 1770|       |// Write the materials in the file
 1771|       |//*****************************************************************************
 1772|       |UINT32 WriteMaterial (t3DSMaterialInfo *pMaterial)
 1773|      0|{
 1774|      0|	fpos_t position;
 1775|      0|	UINT32 chunkSize = WriteChunkHeader (CHK3DS_A_MAT_ENTRY, &position);
 1776|       |
 1777|       |	// write the material
 1778|      0|	chunkSize += WriteMaterialName (pMaterial);
 1779|      0|	chunkSize += WriteMaterialAmbientColor (pMaterial);
 1780|      0|	chunkSize += WriteMaterialDiffuseColor (pMaterial);
 1781|      0|	chunkSize += WriteMaterialSpecularColor (pMaterial);
 1782|       |
 1783|      0|	WriteChunkFooter (position, chunkSize);
 1784|      0|	return chunkSize;
 1785|      0|}
 1786|       |
 1787|       |UINT32 WriteMaterialName (t3DSMaterialInfo *pMaterial)
 1788|      0|{
 1789|      0|	fpos_t position;
 1790|      0|	UINT32 chunkSize = WriteChunkHeader (CHK3DS_A_MAT_NAME, &position);
 1791|       |
 1792|       |	// Write the content of CHK3DS_A_MAT_NAME
 1793|      0|	int strLength = (strlen(pMaterial->strName)+1);
 1794|      0|	fwrite (&pMaterial->strName, 1, strLength*sizeof(char), g_File3DSPointer);
 1795|       |
 1796|       |	// update the chunk size
 1797|      0|	chunkSize += strLength;
 1798|       |
 1799|      0|	WriteChunkFooter (position, chunkSize);
 1800|      0|	return chunkSize;
 1801|      0|}
 1802|       |
 1803|       |UINT32 WriteMaterialAmbientColor (t3DSMaterialInfo *pMaterial)
 1804|      0|{
 1805|      0|	fpos_t position;
 1806|      0|	UINT32 chunkSize = WriteChunkHeader (CHK3DS_A_MAT_AMBIENT, &position);
 1807|       |
 1808|       |	// Write the content of CHK3DS_A_MAT_AMBIENT and update the chunk size
 1809|      0|	chunkSize += WriteColorRGB (pMaterial->sMaterial.Ambient.r,
 1810|      0|								pMaterial->sMaterial.Ambient.g,
 1811|      0|								pMaterial->sMaterial.Ambient.b);
 1812|       |
 1813|      0|	WriteChunkFooter (position, chunkSize);
 1814|      0|	return chunkSize;
 1815|      0|}
 1816|       |
 1817|       |UINT32 WriteMaterialDiffuseColor (t3DSMaterialInfo *pMaterial)
 1818|      0|{
 1819|      0|	fpos_t position;
 1820|      0|	UINT32 chunkSize = WriteChunkHeader (CHK3DS_A_MAT_DIFFUSE, &position);
 1821|       |
 1822|       |	// Write the content of CHK3DS_A_MAT_AMBIENT and update the chunk size
 1823|      0|	chunkSize += WriteColorRGB (pMaterial->sMaterial.Diffuse.r,
 1824|      0|								pMaterial->sMaterial.Diffuse.g,
 1825|      0|								pMaterial->sMaterial.Diffuse.b);
 1826|       |
 1827|      0|	WriteChunkFooter (position, chunkSize);
 1828|      0|	return chunkSize;
 1829|      0|}
 1830|       |
 1831|       |UINT32 WriteMaterialSpecularColor (t3DSMaterialInfo *pMaterial)
 1832|      0|{
 1833|      0|	fpos_t position;
 1834|      0|	UINT32 chunkSize = WriteChunkHeader (CHK3DS_A_MAT_SPECULAR, &position);
 1835|       |
 1836|       |	// Write the content of CHK3DS_A_MAT_AMBIENT and update the chunk size
 1837|      0|	chunkSize += WriteColorRGB (pMaterial->sMaterial.Specular.r,
 1838|      0|								pMaterial->sMaterial.Specular.g,
 1839|      0|								pMaterial->sMaterial.Specular.b);
 1840|       |
 1841|      0|	WriteChunkFooter (position, chunkSize);
 1842|      0|	return chunkSize;
 1843|      0|}
 1844|       |
 1845|       |//*****************************************************************************
 1846|       |//
 1847|       |// Write the objects in the file
 1848|       |//
 1849|       |//*****************************************************************************
 1850|       |UINT32 WriteObjects (t3DSModel *pModel)
 1851|      0|{
 1852|      0|	UINT32 chunkSize = 0;
 1853|       |
 1854|       |	// write the lights
 1855|      0|	std::vector<t3DSLight>::iterator iteratorVectorLight;
 1856|      0|	for(iteratorVectorLight = pModel->pLights.begin();
 1857|      0|		iteratorVectorLight != pModel->pLights.end();
 1858|      0|		iteratorVectorLight++)
 1859|      0|	{
 1860|      0|		t3DSLight light = *(iteratorVectorLight);
 1861|      0|		chunkSize += WriteObject (pModel, &light, CHK3DS_4_N_DIRECT_LIGHT);
 1862|      0|	}
 1863|       |
 1864|       |	// write the cameras
 1865|       |
 1866|       |	// write the trimesh
 1867|      0|	std::vector<t3DSObject>::iterator iteratorVectorObject;
 1868|      0|	for(iteratorVectorObject = pModel->pObject.begin();
 1869|      0|		iteratorVectorObject != pModel->pObject.end();
 1870|      0|		iteratorVectorObject++)
 1871|      0|	{
 1872|      0|		t3DSObject object = *(iteratorVectorObject);
 1873|      0|		chunkSize += WriteObject (pModel, &object, CHK3DS_4_N_TRI_OBJECT);
 1874|      0|	}
 1875|      0|	return chunkSize;
 1876|      0|}
 1877|       |
 1878|       |// Write the object in the file
 1879|       |UINT32 WriteObject (t3DSModel *pModel, void *pObject, UINT16 objectType)
 1880|      0|{
 1881|      0|	fpos_t position;
 1882|      0|	UINT32 chunkSize = WriteChunkHeader (CHK3DS_4_NAMED_OBJECT, &position);
 1883|       |
 1884|      0|	UINT32  nextChunkSize = 0;
 1885|      0|	switch (objectType)
 1886|      0|	{
 1887|      0|	case CHK3DS_4_N_DIRECT_LIGHT:
 1888|      0|		{
 1889|      0|			t3DSLight* light = (t3DSLight*)pObject;
 1890|       |
 1891|       |			// Write the content of CHK3DS_4_N_DIRECT_LIGHT
 1892|      0|			int strLength = (strlen(light->strName)+1);
 1893|      0|			fwrite (&light->strName, 1, strLength*sizeof(char), g_File3DSPointer);
 1894|       |
 1895|       |			// update the chunk size
 1896|      0|			chunkSize += strLength;
 1897|       |
 1898|       |			// write the trimesh
 1899|      0|			nextChunkSize = WriteLight (light);
 1900|      0|		}
 1901|      0|		break;
 1902|      0|	case CHK3DS_4_N_TRI_OBJECT: // it's a trimesh
 1903|      0|		{
 1904|      0|			t3DSObject* trimesh = (t3DSObject*)pObject;
 1905|       |
 1906|       |			// Write the content of CHK3DS_4_NAMED_OBJECT
 1907|      0|			int strLength = (strlen(trimesh->strName)+1);
 1908|      0|			fwrite (&trimesh->strName, 1, strLength*sizeof(char), g_File3DSPointer);
 1909|       |
 1910|       |			// update the chunk size
 1911|      0|			chunkSize += strLength;
 1912|       |
 1913|       |			// write the trimesh
 1914|      0|			nextChunkSize = WriteTrimesh (pModel, trimesh);
 1915|      0|		}
 1916|      0|		break;
 1917|       |		
 1918|      0|	default:
 1919|      0|		assert (0);
 1920|      0|		break;
 1921|      0|	}
 1922|       |
 1923|       |	// update the chunk size
 1924|      0|	chunkSize += nextChunkSize;
 1925|       |
 1926|      0|	WriteChunkFooter (position, chunkSize);
 1927|      0|	return chunkSize;
 1928|      0|}
 1929|       |
 1930|       |// Write the lights in the file
 1931|       |UINT32 WriteLight (t3DSLight *pLight)
 1932|      0|{
 1933|      0|	fpos_t position;
 1934|      0|	UINT32 chunkSize = WriteChunkHeader (CHK3DS_4_N_DIRECT_LIGHT, &position);
 1935|       |
 1936|      0|	fwrite (&pLight->position, 1, 3*sizeof(FLOAT32), g_File3DSPointer);
 1937|      0|	chunkSize += 3*sizeof(FLOAT32);
 1938|       |
 1939|      0|	chunkSize += WriteColorRGBFLOAT32 (pLight->color[0], pLight->color[1], pLight->color[2]);
 1940|      0|	if (pLight->isSpotLight) chunkSize += WriteLightSpotLight (pLight);
 1941|       |
 1942|      0|	WriteChunkFooter (position, chunkSize);
 1943|      0|	return chunkSize;
 1944|      0|}
 1945|       |
 1946|       |UINT32 WriteLightSpotLight (t3DSLight *pLight)
 1947|      0|{
 1948|      0|	fpos_t position;
 1949|      0|	UINT32 chunkSize = WriteChunkHeader (CHK3DS_4_DL_SPOTLIGHT, &position);
 1950|       |
 1951|      0|	fwrite (&pLight->spotLight_target, 1, 3*sizeof(FLOAT32), g_File3DSPointer);
 1952|      0|	fwrite (&pLight->spotLight_hotSpot, 1, sizeof(FLOAT32), g_File3DSPointer);
 1953|      0|	fwrite (&pLight->spotLight_fallOff, 1, sizeof(FLOAT32), g_File3DSPointer);
 1954|      0|	chunkSize += 5*sizeof(FLOAT32);
 1955|       |
 1956|       |	// ... go on with :
 1957|       |	// CHK3DS_4_DL_SPOT_RECTANGULAR
 1958|       |	// CHK3DS_4_DL_SPOT_PROJECTOR
 1959|       |	// CHK3DS_4_DL_SPOT_ROLL
 1960|       |
 1961|      0|	WriteChunkFooter (position, chunkSize);
 1962|      0|	return chunkSize;
 1963|      0|}
 1964|       |
 1965|       |// Write the cameras in the file
 1966|       |UINT32 WriteCamera (t3DSCamera *pCamera)
 1967|      0|{
 1968|      0|	return 0;
 1969|      0|}
 1970|       |
 1971|       |// Write the trimeshes in the file
 1972|       |UINT32 WriteTrimesh (t3DSModel *pModel, t3DSObject *pObject)
 1973|      0|{
 1974|      0|	fpos_t position;
 1975|      0|	UINT32 chunkSize = WriteChunkHeader (CHK3DS_4_N_TRI_OBJECT, &position);
 1976|       |
 1977|       |	// write the vertices
 1978|      0|	if (pObject->numOfVerts)
 1979|      0|	{
 1980|      0|		chunkSize += WriteVertices (pObject->numOfVerts, pObject->pVerts);
 1981|      0|	}
 1982|       |
 1983|       |	// write the faces
 1984|      0|	if (pObject->numOfFaces)
 1985|      0|	{
 1986|      0|		chunkSize += WriteFaces (pModel, pObject);
 1987|      0|	}
 1988|       |
 1989|       |	// write the tex coords
 1990|      0|	if (pObject->numTexVertex)
 1991|      0|	{
 1992|      0|		chunkSize += WriteUVCoordinates (pObject->numTexVertex, pObject->pTexVerts);
 1993|      0|	}
 1994|       |
 1995|       |
 1996|       |	/*
 1997|       |		cout << "<br>number of texture coordinates : " << pObject->numTexVertex << endl;
 1998|       |		cout << "<br>texture ID : " << pObject->materialID << endl;
 1999|       |		cout << "<br>has a texture : " << pObject->bHasTexture << endl;
 2000|       |		cout << "<br>Vertices : ";
 2001|       |		cout << "<br>Texture's UV coordinates : ";
 2002|       |		if (pObject->pTexVerts)
 2003|       |		{
 2004|       |			cout << "..." << endl;
 2005|       |			//cout << endl;
 2006|       |			//for (int i=0; i<object->numOfVerts; i++)
 2007|       |			//	cout << "<br> " << pObject->pTexVerts[i].fU << " " << pObject->pTexVerts[i].fV << endl;
 2008|       |		}
 2009|       |		else
 2010|       |		{
 2011|       |			cout << "not present" << endl;
 2012|       |		}
 2013|       |		cout << "<br>Faces : ";
 2014|       |		*/
 2015|       |	
 2016|      0|	WriteChunkFooter (position, chunkSize);
 2017|      0|	return chunkSize;
 2018|      0|}
 2019|       |
 2020|       |/**
 2021|       |* Write the vertices
 2022|       |*/
 2023|       |UINT32 WriteVertices (UINT32 nVertices, VECTOR3f* vertices)
 2024|      0|{
 2025|      0|	fpos_t position;
 2026|      0|	UINT32 chunkSize = WriteChunkHeader (CHK3DS_4_POINT_ARRAY, &position);
 2027|       |
 2028|       |	// Write the content of CHK3DS_4_POINT_ARRAY
 2029|      0|	fwrite (&nVertices, 1, sizeof(UINT16), g_File3DSPointer);
 2030|      0|	chunkSize += sizeof(UINT16);
 2031|       |
 2032|      0|	FLOAT32 fTempY, fTempZ;
 2033|      0|	for(unsigned int i=0; i<nVertices; i++)
 2034|      0|	{
 2035|      0|		fTempY = -vertices[i].fZ;
 2036|      0|		fTempZ =  vertices[i].fY;
 2037|      0|		fwrite (&vertices[i].fX, 1, sizeof(FLOAT32), g_File3DSPointer);
 2038|      0|		fwrite (&fTempY, 1, sizeof(FLOAT32), g_File3DSPointer);
 2039|      0|		fwrite (&fTempZ, 1, sizeof(FLOAT32), g_File3DSPointer);
 2040|      0|	}
 2041|      0|	chunkSize += 3*nVertices*sizeof(FLOAT32);
 2042|       |
 2043|      0|	WriteChunkFooter (position, chunkSize);
 2044|      0|	return chunkSize;
 2045|      0|}
 2046|       |
 2047|       |/**
 2048|       |* Write the faces
 2049|       |*/
 2050|       |UINT32 WriteFaces (t3DSModel *pModel, t3DSObject *pObject)
 2051|      0|{
 2052|      0|	fpos_t position;
 2053|      0|	UINT32 chunkSize = WriteChunkHeader (CHK3DS_4_FACE_ARRAY, &position);
 2054|       |
 2055|       |	// Write the content of CHK3DS_4_POINT_ARRAY
 2056|      0|	UINT32 nFaces = pObject->numOfFaces;
 2057|      0|	t3DSFace* faces = pObject->pFaces;
 2058|       |
 2059|      0|	fwrite (&nFaces, 1, sizeof(UINT16), g_File3DSPointer);
 2060|      0|	chunkSize += sizeof(UINT16);
 2061|       |
 2062|      0|	INT16 faceFlag = 3;
 2063|      0|	for(unsigned int i=0; i<nFaces; i++)
 2064|      0|	{
 2065|      0|		t3DSFace face = faces[i];
 2066|      0|		fwrite (&face.vertIndex[0], 1, sizeof(INT16), g_File3DSPointer);
 2067|      0|		fwrite (&face.vertIndex[1], 1, sizeof(INT16), g_File3DSPointer);
 2068|      0|		fwrite (&face.vertIndex[2], 1, sizeof(INT16), g_File3DSPointer);
 2069|      0|		fwrite (&faceFlag, 1, sizeof(INT16), g_File3DSPointer);
 2070|      0|	}
 2071|      0|	chunkSize += 4*nFaces*sizeof(INT16);
 2072|       |
 2073|       |	// write the materials used by the object
 2074|      0|	if (pObject->numOfMaterials > 0)
 2075|      0|	{
 2076|      0|		for (int i=0; i<pObject->numOfMaterials; i++)
 2077|      0|			chunkSize += WriteFacesMaterialList (pModel, pObject, i);
 2078|      0|	}
 2079|       |
 2080|      0|	WriteChunkFooter (position, chunkSize);
 2081|       |
 2082|      0|	return chunkSize;
 2083|      0|}
 2084|       |
 2085|       |/**
 2086|       |* Write the faces material list
 2087|       |*/
 2088|       |UINT32 WriteFacesMaterialList (t3DSModel *pModel, t3DSObject *pObject, int index)
 2089|      0|{
 2090|      0|	fpos_t position;
 2091|      0|	UINT32 chunkSize = WriteChunkHeader (CHK3DS_4_MSH_MAT_GROUP, &position);
 2092|       |
 2093|       |	// Write the content of CHK3DS_4_MSH_MAT_GROUP
 2094|      0|	UINT16 materialID = pObject->pFacesMaterialList[index].materialID;
 2095|      0|	fwrite (&pModel->pMaterials[materialID].strName, 1, (strlen(pModel->pMaterials[materialID].strName)+1)*sizeof(char), g_File3DSPointer);
 2096|      0|	chunkSize += (strlen(pModel->pMaterials[materialID].strName)+1)*sizeof(char);
 2097|       |
 2098|      0|	fwrite (&pObject->pFacesMaterialList[index].numOfFaces, 1, sizeof(UINT16), g_File3DSPointer);
 2099|      0|	chunkSize += sizeof(UINT16);
 2100|       |
 2101|      0|	UINT16 uiNbrFaces = pObject->pFacesMaterialList[index].numOfFaces;
 2102|      0|	for (UINT16 i=0; i<uiNbrFaces; i++)
 2103|      0|	{
 2104|      0|		fwrite (&pObject->pFacesMaterialList[index].pFacesMaterialsList[i], 1, sizeof(UINT16), g_File3DSPointer);
 2105|      0|	}
 2106|      0|	chunkSize += uiNbrFaces*sizeof(UINT16);
 2107|       |
 2108|      0|	WriteChunkFooter (position, chunkSize);
 2109|      0|	return chunkSize;
 2110|      0|}
 2111|       |
 2112|       |
 2113|       |/**
 2114|       |* Write the UV coordinates
 2115|       |*/
 2116|       |UINT32 WriteUVCoordinates (INT32 numTexVertex, VECTOR2f* pTexVerts)
 2117|      0|{
 2118|      0|	fpos_t position;
 2119|      0|	UINT32 chunkSize = WriteChunkHeader (CHK3DS_4_TEX_VERTS, &position);
 2120|       |
 2121|      0|	fwrite (&numTexVertex, 1, sizeof(INT16), g_File3DSPointer);
 2122|      0|	chunkSize += sizeof(INT16);
 2123|       |
 2124|      0|	fwrite (pTexVerts, 1, 2*numTexVertex*sizeof(float), g_File3DSPointer);
 2125|      0|	chunkSize += 2*numTexVertex*sizeof(float);
 2126|       |
 2127|      0|	WriteChunkFooter (position, chunkSize);
 2128|      0|	return chunkSize;
 2129|      0|}
 2130|       |
 2131|       |
 2132|       |// Write the animations in the file
 2133|       |UINT32 WriteAnimations (t3DSModel *pModel)
 2134|      0|{
 2135|      0|	return 0;
 2136|      0|}
 2137|       |
 2138|       |
 2139|       |/*
 2140|       |// *Note* 
 2141|       |//
 2142|       |// Below are some math functions for calculating vertex normals.  We want vertex normals
 2143|       |// because it makes the lighting look really smooth and life like.  You probably already
 2144|       |// have these functions in the rest of your engine, so you can delete these and call
 2145|       |// your own.  I wanted to add them so I could show how to calculate vertex normals.
 2146|       |
 2147|       |//////////////////////////////	Math Functions  ////////////////////////////////*
 2148|       |
 2149|       |// This computes the magnitude of a normal.   (magnitude = sqrt(x^2 + y^2 + z^2)
 2150|       |#define Mag(Normal) (sqrt(Normal.fX*Normal.fX + Normal.fY*Normal.fY + Normal.fZ*Normal.fZ))
 2151|       |
 2152|       |#define Vector(vVector, vPoint1, vPoint2)\
 2153|       |{\
 2154|       |vVector.fX = vPoint1.fX - vPoint2.fX;\
 2155|       |vVector.fY = vPoint1.fY - vPoint2.fY;\
 2156|       |vVector.fZ = vPoint1.fZ - vPoint2.fZ;\
 2157|       |}
 2158|       |
 2159|       |// This adds 2 vectors together and returns the result
 2160|       |#define AddVector(vResult, vVector1, vVector2)\
 2161|       |{\
 2162|       |vResult.fX = vVector2.fX + vVector1.fX;\
 2163|       |vResult.fY = vVector2.fY + vVector1.fY;\
 2164|       |vResult.fZ = vVector2.fZ + vVector1.fZ;\
 2165|       |}
 2166|       |
 2167|       |#define DivideVectorByScaler(vResult, vVector1, Scaler)\
 2168|       |{\
 2169|       |vResult.fX = vVector1.fX / Scaler;\
 2170|       |vResult.fY = vVector1.fY / Scaler;\
 2171|       |vResult.fZ = vVector1.fZ / Scaler;\
 2172|       |}
 2173|       |
 2174|       |// This returns the cross product between 2 vectors
 2175|       |#define Cross(vCross, vVector1, vVector2)\
 2176|       |{\
 2177|       |vCross.fX = ((vVector1.fY * vVector2.fZ) - (vVector1.fZ * vVector2.fY));\
 2178|       |vCross.fY = ((vVector1.fZ * vVector2.fX) - (vVector1.fX * vVector2.fZ));\
 2179|       |vCross.fZ = ((vVector1.fX * vVector2.fY) - (vVector1.fY * vVector2.fX));\
 2180|       |}
 2181|       |
 2182|       |#define Normalize(vNormal)\
 2183|       |{\
 2184|       |double Magnitude;\
 2185|       |Magnitude = Mag(vNormal);\
 2186|       |vNormal.fX /= (float)Magnitude;\
 2187|       |vNormal.fY /= (float)Magnitude;\
 2188|       |vNormal.fZ /= (float)Magnitude;\
 2189|       |}
 2190|       |*/

/workspaces/cg/src/cgmesh/mesh_io_3ds_defines.h:
    1|       |/*****************************************************************************/
    2|       |//
    3|       |// File: Defines_3DS.h
    4|       |//
    5|       |// Desc: All the chunks defined and structures used to handle the 3DS format
    6|       |//
    7|       |/*****************************************************************************/
    8|       |
    9|       |#ifndef _DEFINES_3DS_HEADER_
   10|       |#define _DEFINES_3DS_HEADER_
   11|       |
   12|       |//-----------------------------------------------------------------------------
   13|       |// 0xxxH Group
   14|       |//-------
   15|       |#define	CHK3DS_0_NULL_CHUNK			0x0000 	 
   16|       |#define	CHK3DS_0_CHUNK_UNKNOWN_0	0x0001 	//Unknown chunk float ??? 
   17|      1|#define	CHK3DS_0_M3D_VERSION		0x0002 	//This gives the version of the 3ds file - short version 
   18|       |#define	CHK3DS_0_M3D_KFVERSION		0x0005 	 
   19|      0|#define	CHK3DS_0_COLOR_F			0x0010 	//float red, grn, blu; 
   20|      0|#define	CHK3DS_0_COLOR_24			0x0011	//char red, grn, blu; 
   21|      0|#define	CHK3DS_0_LIN_COLOR_24		0x0012	//char red, grn, blu; 
   22|      0|#define	CHK3DS_0_LIN_COLOR_F		0x0013	//float red, grn, blu; 
   23|       |#define	CHK3DS_0_INT_PERCENTAGE		0x0030	//short percentage; 
   24|       |#define	CHK3DS_0_FLOAT_PERCENTAGE	0x0031	//float percentage; 
   25|      1|#define	CHK3DS_0_MASTER_SCALE		0x0100	//float scale; 
   26|       |#define	CHK3DS_0_CHUNKTYPE			0x0995	//ChunkType 
   27|       |#define	CHK3DS_0_CHUNKUNIQUE		0x0996	//ChunkUnique 
   28|       |#define	CHK3DS_0_NOTCHUNK			0x0997	//NotChunk 
   29|       |#define	CHK3DS_0_CONTAINER			0x0998	//Container 
   30|       |#define	CHK3DS_0_ISCHUNK			0x0999	//IsChunk 
   31|       |#define	CHK3DS_0_SXP_SELFI_MASKDATA	0x0c3c 	 
   32|       |
   33|       |//-----------------------------------------------------------------------------
   34|       |// 1xxx Group
   35|       |//-------
   36|       |#define	CHK3DS_1_BIT_MAP			0x1100 		//cstr filename; 
   37|       |#define	CHK3DS_1_USE_BIT_MAP		0x1101 	 
   38|       |#define	CHK3DS_1_SOLID_BGND			0x1200 		//followed by color_f 
   39|       |#define	CHK3DS_1_USE_SOLID_BGND		0x1201 	 
   40|       |#define	CHK3DS_1_V_GRADIENT			0x1300 		// followed by three color_f: start, mid, endfloat midpoint; 	
   41|       |#define	CHK3DS_1_USE_V_GRADIENT		0x1301 	 	
   42|       |#define	CHK3DS_1_LO_SHADOW_BIAS		0x1400 		//float bias; 	
   43|       |#define	CHK3DS_1_HI_SHADOW_BIAS		0x1410 	 	
   44|       |#define	CHK3DS_1_SHADOW_MAP_SIZE	0x1420 		//short size; 	
   45|       |#define	CHK3DS_1_SHADOW_SAMPLES		0x1430 	 	
   46|       |#define	CHK3DS_1_SHADOW_RANGE		0x1440 	 	
   47|       |#define	CHK3DS_1_SHADOW_FILTER		0x1450 		//float filter; 	
   48|       |#define	CHK3DS_1_RAY_BIAS			0x1460 		//float bias; 	
   49|       |#define	CHK3DS_1_O_CONSTS			0x1500 		//float plane_x, plane_y, plane_z; 	
   50|       |
   51|       |//-----------------------------------------------------------------------------
   52|       |// 2xxx Group
   53|       |//-------
   54|       |#define	CHK3DS_2_AMBIENT_LIGHT		0x2100 	 
   55|       |#define	CHK3DS_2_FOG				0x2200 		// followed by color_f, fog_bgndfloat near_plane, near_density;float far_plane, far_density; 
   56|       |#define	CHK3DS_2_USE_FOG			0x2201 	 
   57|       |#define	CHK3DS_2_FOG_BGND			0x2210 	 
   58|       |#define	CHK3DS_2_DISTANCE_CUE		0x2300 		//followed by dcue_bgndfloat near_plane, near_density;float far_plane, far_density; 
   59|       |#define	CHK3DS_2_USE_DISTANCE_CUE	0x2301 	 
   60|       |#define	CHK3DS_2_LAYER_FOG			0x2302 		//float fog_z_from, fog_z_to;float fog_density;short fog_type; 
   61|       |#define	CHK3DS_2_USE_LAYER_FOG		0x2303 	 
   62|       |#define	CHK3DS_2_DCUE_BGND			0x2310 	 
   63|       |#define	CHK3DS_2_SMAGIC				0x2d2d 	 
   64|       |#define	CHK3DS_2_LMAGIC				0x2d3d 	 
   65|       |
   66|       |//-----------------------------------------------------------------------------
   67|       |// 3xxx Group
   68|       |//-------
   69|       |#define	CHK3DS_3_DEFAULT_VIEW		0x3000 	 
   70|       |#define	CHK3DS_3_VIEW_TOP			0x3010 		//float targe_x, target_y, target_z;float view_width; 
   71|       |#define	CHK3DS_3_VIEW_BOTTOM		0x3020 		//float targe_x, target_y, target_z;float view_width; 
   72|       |#define	CHK3DS_3_VIEW_LEFT			0x3030 		//float targe_x, target_y, target_z;float view_width; 
   73|       |#define	CHK3DS_3_VIEW_RIGHT			0x3040 		//float targe_x, target_y, target_z;float view_width; 
   74|       |#define	CHK3DS_3_VIEW_FRONT			0x3050 		//float targe_x, target_y, target_z;float view_width; 
   75|       |#define	CHK3DS_3_VIEW_BACK			0x3060 		//float targe_x, target_y, target_z;float view_width; 
   76|       |#define	CHK3DS_3_VIEW_USER			0x3070 		//float targe_x, target_y, target_z;float view_width; 
   77|       |#define	CHK3DS_3_VIEW_CAMERA		0x3080 		//cstr camera_name; 
   78|       |#define	CHK3DS_3_VIEW_WINDOW		0x3090 	 
   79|      1|#define	CHK3DS_3_MDATA				0x3d3d 		//Mesh Data Magic Number (.3DS files sub of 4d4d) 
   80|      1|#define	CHK3DS_3_MESH_VERSION		0x3d3e 	 
   81|       |#define	CHK3DS_3_MLIBMAGIC			0x3daa 		//Material Library Magic Number (.MLI files) 
   82|       |#define	CHK3DS_3_PRJMAGIC			0x3dc2 		//3dS Project Magic Number (.PRJ files) 
   83|       |#define	CHK3DS_3_MATMAGIC			0x3dff 		//Material File Magic Number (.MAT files) 
   84|       |
   85|       |//-----------------------------------------------------------------------------
   86|       |// 4xxxH Group
   87|       |//-------
   88|      4|#define	CHK3DS_4_NAMED_OBJECT			0x4000 	//cstr name; 
   89|       |#define	CHK3DS_4_OBJ_HIDDEN				0x4010 	 
   90|       |#define	CHK3DS_4_OBJ_VIS_LOFTER			0x4011 	 
   91|       |#define	CHK3DS_4_OBJ_DOESNT_CAST		0x4012 	 
   92|       |#define	CHK3DS_4_OBJ_MATTE				0x4013 	 
   93|       |#define	CHK3DS_4_OBJ_FAST				0x4014 	 
   94|       |#define	CHK3DS_4_OBJ_PROCEDURAL			0x4015 	 
   95|       |#define	CHK3DS_4_OBJ_FROZEN				0x4016 	 
   96|       |#define	CHK3DS_4_OBJ_DONT_RCVSHADOW		0x4017 	 
   97|      4|#define	CHK3DS_4_N_TRI_OBJECT			0x4100 		//named triangle objectfollowed by point_array, point_flag_array, mesh_matrix,face_array 
   98|      4|#define	CHK3DS_4_POINT_ARRAY			0x4110 		//short npoints;struct {float x, y, z;} points[npoints]; 
   99|       |#define	CHK3DS_4_POINT_FLAG_ARRAY		0x4111 		//short nflags;short flags[nflags]; 
  100|      4|#define	CHK3DS_4_FACE_ARRAY				0x4120 		//may be followed by smooth_groupshort nfaces;struct {short vertex1, vertex2, vertex3;short flags;} facearray[nfaces]; 
  101|      4|#define	CHK3DS_4_MSH_MAT_GROUP			0x4130 		//mesh_material_groupcstr material_name;short nfaces;short facenum[nfaces]; 
  102|       |#define	CHK3DS_4_OLD_MAT_GROUP			0x4131 	 
  103|      4|#define	CHK3DS_4_TEX_VERTS				0x4140 		//short nverts;struct {float x, y;} vertices[nverts]; 
  104|       |#define	CHK3DS_4_SMOOTH_GROUP			0x4150 		//short grouplist[n]; determined by length, seems to be 4 per face 
  105|      4|#define	CHK3DS_4_MESH_MATRIX			0x4160 		//float matrix[4][3]; 
  106|      0|#define	CHK3DS_4_MESH_COLOR				0x4165 		//short color_index; 
  107|       |#define	CHK3DS_4_MESH_TEXTURE_INFO		0x4170 		//short map_type;float x_tiling, y_tiling;float icon_x, icon_y, icon_z;float matrix[4][3];float scaling, plan_icon_w, plan_icon_h, cyl_icon_h; 
  108|       |#define	CHK3DS_4_PROC_NAME				0x4181 	 
  109|       |#define	CHK3DS_4_PROC_DATA				0x4182 	 
  110|       |#define	CHK3DS_4_MSH_BOXMAP				0x4190 	 
  111|       |#define	CHK3DS_4_N_D_L_OLD				0x4400 	 
  112|       |#define	CHK3DS_4_N_CAM_OLD				0x4500 	 
  113|      0|#define	CHK3DS_4_N_DIRECT_LIGHT			0x4600 		//followed by color_ffloat x, y, z; 
  114|      0|#define	CHK3DS_4_DL_SPOTLIGHT			0x4610 		//float target_x, target_y, target_z;float hotspot_ang;float falloff_ang; 
  115|       |#define	CHK3DS_4_DL_OFF					0x4620 	 
  116|      0|#define	CHK3DS_4_DL_ATTENUATE			0x4625 	 
  117|       |#define	CHK3DS_4_DL_RAYSHAD				0x4627 	 
  118|      0|#define	CHK3DS_4_DL_SHADOWED			0x4630 	 
  119|       |#define	CHK3DS_4_DL_LOCAL_SHADOW		0x4640 	 
  120|      0|#define	CHK3DS_4_DL_LOCAL_SHADOW2		0x4641 	 
  121|       |#define	CHK3DS_4_DL_SEE_CONE			0x4650 	 
  122|       |#define	CHK3DS_4_DL_SPOT_RECTANGULAR	0x4651 	 
  123|       |#define	CHK3DS_4_DL_SPOT_OVERSHOOT		0x4652 	 
  124|       |#define	CHK3DS_4_DL_SPOT_PROJECTOR		0x4653 	 
  125|       |#define	CHK3DS_4_DL_EXCLUDE				0x4654 	 
  126|       |#define	CHK3DS_4_DL_RANGE				0x4655 	 
  127|      0|#define	CHK3DS_4_DL_SPOT_ROLL			0x4656 		//float roll_ang; 
  128|       |#define	CHK3DS_4_DL_SPOT_ASPECT			0x4657 	 
  129|      0|#define	CHK3DS_4_DL_RAY_BIAS			0x4658 		//float bias; 
  130|      0|#define	CHK3DS_4_DL_INNER_RANGE			0x4659 		//float range; 
  131|      0|#define	CHK3DS_4_DL_OUTER_RANGE			0x465a 		//float range; 
  132|      0|#define	CHK3DS_4_DL_MULTIPLIER			0x465b 		//float multiple; 
  133|       |#define	CHK3DS_4_N_AMBIENT_LIGHT		0x4680 	 
  134|      0|#define	CHK3DS_4_N_CAMERA				0x4700 		//float camera_x, camera_y, camera_z;float target_x, target_y, target_z;float bank_angle;float focus; 
  135|       |#define	CHK3DS_4_CAM_SEE_CONE			0x4710 	 
  136|       |#define	CHK3DS_4_CAM_RANGES				0x4720 		//float near_range, far_range; 
  137|      1|#define	CHK3DS_4_M3DMAGIC				0x4d4d 		//3DS Magic Number (.3DS file) 
  138|       |#define	CHK3DS_4_HIERARCHY				0x4f00 	 
  139|       |#define	CHK3DS_4_PARENT_OBJECT			0x4f10 	 
  140|       |#define	CHK3DS_4_PIVOT_OBJECT			0x4f20 	 
  141|       |#define	CHK3DS_4_PIVOT_LIMITS			0x4f30 	 
  142|       |#define	CHK3DS_4_PIVOT_ORDER			0x4f40 	 
  143|       |#define	CHK3DS_4_XLATE_RANGE			0x4f50 	 
  144|       |
  145|       |//-----------------------------------------------------------------------------
  146|       |// 5xxx Group
  147|       |//-------
  148|       |#define	CHK3DS_5_POLY_2D				0x5000 	 
  149|       |#define	CHK3DS_5_SHAPE_OK				0x5010 	 
  150|       |#define	CHK3DS_5_SHAPE_NOT_OK			0x5011 	 
  151|       |#define	CHK3DS_5_SHAPE_HOOK				0x5020 	 
  152|       |
  153|       |//-----------------------------------------------------------------------------
  154|       |// 6xxx Group
  155|       |//-------
  156|       |#define	CHK3DS_6_PATH_3D				0x6000 	 
  157|       |#define	CHK3DS_6_PATH_MATRIX			0x6005 	 
  158|       |#define	CHK3DS_6_SHAPE_2D				0x6010 	 
  159|       |#define	CHK3DS_6_M_SCALE				0x6020 	 
  160|       |#define	CHK3DS_6_M_TWIST				0x6030 	 
  161|       |#define	CHK3DS_6_M_TEETER				0x6040 	 
  162|       |#define	CHK3DS_6_M_FIT					0x6050 	 
  163|       |#define	CHK3DS_6_M_BEVEL				0x6060 	 
  164|       |#define	CHK3DS_6_XZ_CURVE				0x6070 	 
  165|       |#define	CHK3DS_6_YZ_CURVE				0x6080 	 
  166|       |#define	CHK3DS_6_INTERPCT				0x6090 	 
  167|       |#define	CHK3DS_6_DEFORM_LIMIT			0x60a0 	 
  168|       |#define	CHK3DS_6_USE_CONTOUR			0x6100 	 
  169|       |#define	CHK3DS_6_USE_TWEEN				0x6110 	 
  170|       |#define	CHK3DS_6_USE_SCALE				0x6120 	 
  171|       |#define	CHK3DS_6_USE_TWIST				0x6130 	 
  172|       |#define	CHK3DS_6_USE_TEETER				0x6140 	 
  173|       |#define	CHK3DS_6_USE_FIT				0x6150 	 
  174|       |#define	CHK3DS_6_USE_BEVEL				0x6160 	 
  175|       |
  176|       |//-----------------------------------------------------------------------------
  177|       |// 7xxx Group
  178|       |//-------
  179|       |#define	CHK3DS_7_VIEWPORT_LAYOUT_OLD	0x7000 	 
  180|       |#define	CHK3DS_7_VIEWPORT_LAYOUT		0x7001 		//followed by viewport_size, viewport_datashort form, top, ready, wstate, swapws, swapport, swapcur; 
  181|       |#define	CHK3DS_7_VIEWPORT_DATA_OLD		0x7010 	 
  182|       |#define	CHK3DS_7_VIEWPORT_DATA			0x7011 		//short flags, axis_lockout;short win_x, win_y, win_w, winh_, win_view;float zoom; float worldcenter_x, worldcenter_y, worldcenter_z;float horiz_ang, vert_ang;cstr camera_name; 
  183|       |#define	CHK3DS_7_VIEWPORT_DATA_3		0x7012 		//short flags, axis_lockout;short win_x, win_y, win_w, winh_, win_view;float zoom; float worldcenter_x, worldcenter_y, worldcenter_z;float horiz_ang, vert_ang;cstr camera_name; 
  184|       |#define	CHK3DS_7_VIEWPORT_SIZE			0x7020 		//short x, y, w, h; 
  185|       |#define	CHK3DS_7_NETWORK_VIEW			0x7030 	 
  186|       |
  187|       |//-----------------------------------------------------------------------------
  188|       |// 8xxx Group
  189|       |//-------
  190|       |#define	CHK3DS_8_XDATA_SECTION			0x8000 	 
  191|       |#define	CHK3DS_8_XDATA_ENTRY			0x8001 	 
  192|       |#define	CHK3DS_8_XDATA_APPNAME			0x8002 	 
  193|       |#define	CHK3DS_8_XDATA_STRING			0x8003 	 
  194|       |#define	CHK3DS_8_XDATA_FLOAT			0x8004 	 
  195|       |#define	CHK3DS_8_XDATA_DOUBLE			0x8005 	 
  196|       |#define	CHK3DS_8_XDATA_SHORT			0x8006 	 
  197|       |#define	CHK3DS_8_XDATA_LONG				0x8007 	 
  198|       |#define	CHK3DS_8_XDATA_VOID				0x8008 	 
  199|       |#define	CHK3DS_8_XDATA_GROUP			0x8009 	 
  200|       |#define	CHK3DS_8_XDATA_RFU6				0x800a 	 
  201|       |#define	CHK3DS_8_XDATA_RFU5				0x800b 	 
  202|       |#define	CHK3DS_8_XDATA_RFU4				0x800c 	 
  203|       |#define	CHK3DS_8_XDATA_RFU3				0x800d 	 
  204|       |#define	CHK3DS_8_XDATA_RFU2				0x800e 	 
  205|       |#define	CHK3DS_8_XDATA_RFU1				0x800f 	 
  206|       |#define	CHK3DS_8_PARENT_NAME			0x80f0 	 
  207|       |
  208|       |//-----------------------------------------------------------------------------
  209|       |// Axxx Group
  210|       |//-------
  211|      2|#define	CHK3DS_A_MAT_NAME				0xa000 		//cstr material_name; 
  212|      2|#define	CHK3DS_A_MAT_AMBIENT			0xa010 		//followed by color chunk 
  213|      2|#define	CHK3DS_A_MAT_DIFFUSE			0xa020 		//followed by color chunk 
  214|      2|#define	CHK3DS_A_MAT_SPECULAR			0xa030 		//followed by color chunk 
  215|      2|#define	CHK3DS_A_MAT_SHININESS			0xa040 		//followed by percentage chunk 
  216|      2|#define	CHK3DS_A_MAT_SHIN2PCT			0xa041 		//followed by percentage chunk 
  217|       |#define	CHK3DS_A_MAT_SHIN3PCT			0xa042 		//followed by percentage chunk 
  218|      2|#define	CHK3DS_A_MAT_TRANSPARENCY		0xa050 		//followed by percentage chunk 
  219|       |#define	CHK3DS_A_MAT_XPFALL				0xa052 		//followed by percentage chunk 
  220|       |#define	CHK3DS_A_MAT_REFBLUR			0xa053 		//followed by percentage chunk 
  221|       |#define	CHK3DS_A_MAT_SELF_ILLUM			0xa080 	
  222|       |#define	CHK3DS_A_MAT_TWO_SIDE			0xa081 	 
  223|       |#define	CHK3DS_A_MAT_DECAL				0xa082 	 
  224|       |#define	CHK3DS_A_MAT_ADDITIVE			0xa083 	 
  225|       |#define	CHK3DS_A_MAT_SELF_ILPCT			0xa084 		//followed by percentage chunk 
  226|       |#define	CHK3DS_A_MAT_WIRE				0xa085 	 
  227|       |#define	CHK3DS_A_MAT_SUPERSMP			0xa086 	 
  228|       |#define	CHK3DS_A_MAT_WIRESIZE			0xa087 		//float wire_size; 
  229|       |#define	CHK3DS_A_MAT_FACEMAP			0xa088 	 
  230|       |#define	CHK3DS_A_MAT_XPFALLIN			0xa08a 	 
  231|       |#define	CHK3DS_A_MAT_PHONGSOFT			0xa08c 	 
  232|       |#define	CHK3DS_A_MAT_WIREABS			0xa08e 	 
  233|       |#define	CHK3DS_A_MAT_SHADING			0xa100 		//short shading_value; 
  234|      1|#define	CHK3DS_A_MAT_TEXMAP				0xa200 		//followed by percentage chunk, mat_mapname,mat_map_tiling, mat_map_texblur... 
  235|       |#define	CHK3DS_A_MAT_SPECMAP			0xa204 		//followed by percentage_chunk, mat_mapname 
  236|       |#define	CHK3DS_A_MAT_OPACMAP			0xa210 		//followed by percentage_chunk, mat_mapname 
  237|       |#define	CHK3DS_A_MAT_REFLMAP			0xa220 		//followed by percentage_chunk, mat_mapname 
  238|       |#define	CHK3DS_A_MAT_BUMPMAP			0xa230 		//followed by percentage_chunk, mat_mapname 
  239|       |#define	CHK3DS_A_MAT_USE_XPFALL			0xa240 	 
  240|       |#define	CHK3DS_A_MAT_USE_REFBLUR		0xa250 	 
  241|       |#define	CHK3DS_A_MAT_BUMP_PERCENT		0xa252 	 
  242|      1|#define	CHK3DS_A_MAT_MAPNAME			0xa300 		//cstr filename; 
  243|       |#define	CHK3DS_A_MAT_ACUBIC				0xa310 	 
  244|       |#define	CHK3DS_A_MAT_SXP_TEXT_DATA		0xa320 	 
  245|       |#define	CHK3DS_A_MAT_SXP_TEXT2_DATA		0xa321 	 
  246|       |#define	CHK3DS_A_MAT_SXP_OPAC_DATA		0xa322 	 
  247|       |#define	CHK3DS_A_MAT_SXP_BUMP_DATA		0xa324 	 
  248|       |#define	CHK3DS_A_MAT_SXP_SPEC_DATA		0xa325 	 
  249|       |#define	CHK3DS_A_MAT_SXP_SHIN_DATA		0xa326 	 
  250|       |#define	CHK3DS_A_MAT_SXP_SELFI_DATA		0xa328 	 
  251|       |#define	CHK3DS_A_MAT_SXP_TEXT_MASKDATA	0xa32a 	 
  252|       |#define	CHK3DS_A_MAT_SXP_TEXT2_MASKDATA	0xa32c 	 
  253|       |#define	CHK3DS_A_MAT_SXP_OPAC_MASKDATA	0xa32e 	 
  254|       |#define	CHK3DS_A_MAT_SXP_BUMP_MASKDATA	0xa330 	 
  255|       |#define	CHK3DS_A_MAT_SXP_SPEC_MASKDATA	0xa332 	 
  256|       |#define	CHK3DS_A_MAT_SXP_SHIN_MASKDATA	0xa334 	 
  257|       |#define	CHK3DS_A_MAT_SXP_SELFI_MASKDATA	0xa336 	 
  258|       |#define	CHK3DS_A_MAT_SXP_REFL_MASKDATA	0xa338 	 
  259|       |#define	CHK3DS_A_MAT_TEX2MAP			0xa33a 	 
  260|       |#define	CHK3DS_A_MAT_SHINMAP			0xa33c 	 
  261|       |#define	CHK3DS_A_MAT_SELFIMAP			0xa33d 	 
  262|       |#define	CHK3DS_A_MAT_TEXMASK			0xa33e 	 
  263|       |#define	CHK3DS_A_MAT_TEX2MASK			0xa340 	 
  264|       |#define	CHK3DS_A_MAT_OPACMASK			0xa342 	 
  265|       |#define	CHK3DS_A_MAT_BUMPMASK			0xa344 	 
  266|       |#define	CHK3DS_A_MAT_SHINMASK			0xa346 	 
  267|       |#define	CHK3DS_A_MAT_SPECMASK			0xa348 	 
  268|       |#define	CHK3DS_A_MAT_SELFIMASK			0xa34a 	 
  269|       |#define	CHK3DS_A_MAT_REFLMASK			0xa34c 	 
  270|       |#define	CHK3DS_A_MAT_MAP_TILINGOLD		0xa350 	 
  271|       |#define	CHK3DS_A_MAT_MAP_TILING			0xa351 		//short flags; 
  272|       |#define	CHK3DS_A_MAT_MAP_TEXBLUR_OLD	0xa352 	 
  273|       |#define	CHK3DS_A_MAT_MAP_TEXBLUR		0xa353 		//float blurring; 
  274|      0|#define	CHK3DS_A_MAT_MAP_USCALE			0xa354 	 
  275|      0|#define	CHK3DS_A_MAT_MAP_VSCALE			0xa356 	 
  276|      0|#define	CHK3DS_A_MAT_MAP_UOFFSET		0xa358 	 
  277|      0|#define	CHK3DS_A_MAT_MAP_VOFFSET		0xa35a 	 
  278|       |#define	CHK3DS_A_MAT_MAP_ANG			0xa35c 	 
  279|       |#define	CHK3DS_A_MAT_MAP_COL1			0xa360 	 
  280|       |#define	CHK3DS_A_MAT_MAP_COL2			0xa362 	 
  281|       |#define	CHK3DS_A_MAT_MAP_RCOL			0xa364 	 
  282|       |#define	CHK3DS_A_MAT_MAP_GCOL			0xa366 	 
  283|       |#define	CHK3DS_A_MAT_MAP_BCOL			0xa368 	 
  284|      2|#define	CHK3DS_A_MAT_ENTRY				0xafff //This stored the texture info	 
  285|       |
  286|       |//-----------------------------------------------------------------------------
  287|       |// Bxxx Group
  288|       |//-------
  289|      1|#define	CHK3DS_B_KFDATA				0xb000 		//This is the header for all of the key frame info followed by kfhdr 
  290|      0|#define	CHK3DS_B_AMBIENT_NODE_TAG	0xb001 	 
  291|      0|#define	CHK3DS_B_OBJECT_NODE_TAG	0xb002 		//followed by node_hdr, pivot, pos_track_tag, rot_track_tag, scl_track_tag, morph_smooth... 
  292|       |#define	CHK3DS_B_CAMERA_NODE_TAG	0xb003 		//followed by node_hdr, pos_track_tag, fov_track_tag, roll_track_tag... 
  293|       |#define	CHK3DS_B_TARGET_NODE_TAG	0xb004 		//followed by node_hdr, pos_track_tag... 
  294|       |#define	CHK3DS_B_LIGHT_NODE_TAG		0xb005 		//followed by node_hdr, pos_track_tag, col_track_tag... 
  295|       |#define	CHK3DS_B_L_TARGET_NODE_TAG	0xb006 		//followed by node_id, node_hdr, pos_track_tag 
  296|       |#define	CHK3DS_B_SPOTLIGHT_NODE_TAG	0xb007 		//followed by node_id, node_hdr, pos_track_tag, hot_track_tag, fall_track_tag, roll_track_tag, col_track_tag... 
  297|      0|#define	CHK3DS_B_KFSEG				0xb008 		//short start, end; 
  298|       |#define	CHK3DS_B_KFCURTIME			0xb009 		//short curframe; 
  299|       |#define	CHK3DS_B_KFHDR				0xb00a 		//followed by viewport_layout, kfseg, kfcurtime, object_node_tag, light_node_tag, target_node_tag, camera_node_tag, l_target_node_tag, spotlight_node_tag, ambient_node_tag...short revision; cstr filename; short animlen; 
  300|      0|#define	CHK3DS_B_NODE_HDR			0xb010 		//cstr objname;short flags1;short flags2; short heirarchy; ? 
  301|       |#define	CHK3DS_B_INSTANCE_NAME		0xb011 	 
  302|       |#define	CHK3DS_B_PRESCALE			0xb012 	 
  303|      0|#define	CHK3DS_B_PIVOT				0xb013 		//float pivot_x, pivot_y, pivot_z; 
  304|       |#define	CHK3DS_B_BOUNDBOX			0xb014 	 
  305|       |#define	CHK3DS_B_MORPH_SMOOTH		0xb015 		//float morph_smoothing_angle_rad; 
  306|      0|#define	CHK3DS_B_POS_TRACK_TAG		0xb020 		//short flags;short unknown[4];short keys;short unknown;struct {short framenum;long unknown;float pos_x, pos_y, pos_z; } pos[keys]; 
  307|      0|#define	CHK3DS_B_ROT_TRACK_TAG		0xb021 		//short flags;short unknown[4];short keys;short unknown;struct {short framenum;long unknown;float rotation_rad;float axis_x, axis_y, axis_z; } rot[keys]; 
  308|      0|#define	CHK3DS_B_SCL_TRACK_TA		0xb022 		//Gshort flags;short unknown[4];short keys;short unknown;struct {short framenum;long unknown;float scale_x, scale_y, scale_z; } scale[keys]; 
  309|       |#define	CHK3DS_B_FOV_TRACK_TAG		0xb023 		//short flags;short unknown[4];short keys;short unknown;struct {short framenum;long unknown;float camera_field_of_view;} fov[keys] 
  310|       |#define	CHK3DS_B_ROLL_TRACK_TAG		0xb024 		//short flags;short unknown[4];short keys;short unknown;struct {short framenum;long unknown;float camera_roll;} roll[keys]; 
  311|       |#define	CHK3DS_B_COL_TRACK_TAG		0xb025 		//short flags;short unknown[4];short keys;short unknown;struct {short framenum;long unknown;float red, rgn, blu;} color[keys]; 
  312|       |#define	CHK3DS_B_MORPH_TRACK_TAG	0xb026 		//short flags;short unknown[4];short keys;short unknown;struct {short framenum;long unknown;cstr obj_name;} morph[keys]; 
  313|       |#define	CHK3DS_B_HOT_TRACK_TAG		0xb027 		//short flags;short unknown[4];short keys;short unknown;struct {short framenum;long unknown;float hotspot_ang;} hotspot[keys]; 
  314|       |#define	CHK3DS_B_FALL_TRACK_TAG		0xb028 		//short flags;short unknown[4];short keys;short unknown;struct {short framenum;long unknown;float falloff_ang;} falloff[keys]; 
  315|       |#define	CHK3DS_B_HIDE_TRACK_TAG		0xb029 	 
  316|       |#define	CHK3DS_B_NODE_ID			0xb030 		//short id; 
  317|       |
  318|       |//-----------------------------------------------------------------------------
  319|       |// Cxxx Group
  320|       |//-------
  321|       |#define CHK3DS_C_MDRAWER				0xc010
  322|       |#define CHK3DS_C_TDRAWER				0xc020
  323|       |#define CHK3DS_C_SHPDRAWER				0xc030
  324|       |#define CHK3DS_C_MODDRAWER				0xc040
  325|       |#define CHK3DS_C_RIPDRAWER				0xc050
  326|       |#define CHK3DS_C_TXDRAWER				0xc060
  327|       |#define CHK3DS_C_PDRAWER				0xc062
  328|       |#define CHK3DS_C_MTLDRAWER				0xc064
  329|       |#define CHK3DS_C_FLIDRAWER				0xc066
  330|       |#define CHK3DS_C_CUBDRAWER				0xc067
  331|       |#define CHK3DS_C_MFILE					0xc070
  332|       |#define CHK3DS_C_SHPFILE				0xc080
  333|       |#define CHK3DS_C_MODFILE				0xc090
  334|       |#define CHK3DS_C_RIPFILE				0xc0a0
  335|       |#define CHK3DS_C_TXFILE					0xc0b0
  336|       |#define CHK3DS_C_PFILE					0xc0b2
  337|       |#define CHK3DS_C_MTLFILE				0xc0b4
  338|       |#define CHK3DS_C_FLIFILE				0xc0b6
  339|       |#define CHK3DS_C_PALFILE				0xc0b8
  340|       |#define CHK3DS_C_TX_STRING				0xc0c0
  341|       |#define CHK3DS_C_CONSTS					0xc0d0
  342|       |#define CHK3DS_C_SNAPS					0xc0e0
  343|       |#define CHK3DS_C_GRIDS					0xc0f0
  344|       |#define CHK3DS_C_ASNAPS					0xc100
  345|       |#define CHK3DS_C_GRID_RANGE				0xc110
  346|       |#define CHK3DS_C_RENDTYPE				0xc120
  347|       |#define CHK3DS_C_PROGMODE				0xc130
  348|       |#define CHK3DS_C_PREVMODE				0xc140
  349|       |#define CHK3DS_C_MODWMODE				0xc150
  350|       |#define CHK3DS_C_MODMODEL				0xc160
  351|       |#define CHK3DS_C_ALL_LINES				0xc170
  352|       |#define CHK3DS_C_BACK_TYPE				0xc180
  353|       |#define CHK3DS_C_MD_CS					0xc190
  354|       |#define CHK3DS_C_MD_CE					0xc1a0
  355|       |#define CHK3DS_C_MD_SML					0xc1b0
  356|       |#define CHK3DS_C_MD_SMW					0xc1c0
  357|       |#define CHK3DS_C_LOFT_WITH_TEXTURE		0xc1c3
  358|       |#define CHK3DS_C_LOFT_L_REPEAT			0xc1c4
  359|       |#define CHK3DS_C_LOFT_W_REPEAT			0xc1c5
  360|       |#define CHK3DS_C_LOFT_UV_NORMALIZE		0xc1c6
  361|       |#define CHK3DS_C_WELD_LOFT				0xc1c7
  362|       |#define CHK3DS_C_MD_PDET				0xc1d0
  363|       |#define CHK3DS_C_MD_SDET				0xc1e0
  364|       |#define CHK3DS_C_RGB_RMODE				0xc1f0
  365|       |#define CHK3DS_C_RGB_HIDE				0xc200
  366|       |#define CHK3DS_C_RGB_MAPSW				0xc202
  367|       |#define CHK3DS_C_RGB_TWOSIDE			0xc204
  368|       |#define CHK3DS_C_RGB_SHADOW				0xc208
  369|       |#define CHK3DS_C_RGB_AA					0xc210
  370|       |#define CHK3DS_C_RGB_OVW				0xc220
  371|       |#define CHK3DS_C_RGB_OVH				0xc230
  372|       |#define CHK3DS_C_CMAGIC					0xc23d
  373|       |#define CHK3DS_C_RGB_PICTYPE			0xc240
  374|       |#define CHK3DS_C_RGB_OUTPUT				0xc250
  375|       |#define CHK3DS_C_RGB_TODISK				0xc253
  376|       |#define CHK3DS_C_RGB_COMPRESS			0xc254
  377|       |#define CHK3DS_C_JPEG_COMPRESSION		0xc255
  378|       |#define CHK3DS_C_RGB_DISPDEV			0xc256
  379|       |#define CHK3DS_C_RGB_HARDDEV			0xc259
  380|       |#define CHK3DS_C_RGB_PATH				0xc25a
  381|       |#define CHK3DS_C_BITMAP_DRAWER			0xc25b
  382|       |#define CHK3DS_C_RGB_FILE				0xc260
  383|       |#define CHK3DS_C_RGB_OVASPECT			0xc270
  384|       |#define CHK3DS_C_RGB_ANIMTYPE			0xc271
  385|       |#define CHK3DS_C_RENDER_ALL				0xc272
  386|       |#define CHK3DS_C_REND_FROM				0xc273
  387|       |#define CHK3DS_C_REND_TO				0xc274
  388|       |#define CHK3DS_C_REND_NTH				0xc275
  389|       |#define CHK3DS_C_PAL_TYPE				0xc276
  390|       |#define CHK3DS_C_RND_TURBO				0xc277
  391|       |#define CHK3DS_C_RND_MIP				0xc278
  392|       |#define CHK3DS_C_BGND_METHOD			0xc279
  393|       |#define CHK3DS_C_AUTO_REFLECT			0xc27a
  394|       |#define CHK3DS_C_VP_FROM				0xc27b
  395|       |#define CHK3DS_C_VP_TO					0xc27c
  396|       |#define CHK3DS_C_VP_NTH					0xc27d
  397|       |#define CHK3DS_C_REND_TSTEP				0xc27e
  398|       |#define CHK3DS_C_VP_TSTEP				0xc27f
  399|       |#define CHK3DS_C_SRDIAM					0xc280
  400|       |#define CHK3DS_C_SRDEG					0xc290
  401|       |#define CHK3DS_C_SRSEG					0xc2a0
  402|       |#define CHK3DS_C_SRDIR					0xc2b0
  403|       |#define CHK3DS_C_HETOP					0xc2c0
  404|       |#define CHK3DS_C_HEBOT					0xc2d0
  405|       |#define CHK3DS_C_HEHT					0xc2e0
  406|       |#define CHK3DS_C_HETURNS				0xc2f0
  407|       |#define CHK3DS_C_HEDEG					0xc300
  408|       |#define CHK3DS_C_HESEG					0xc310
  409|       |#define CHK3DS_C_HEDIR					0xc320
  410|       |#define CHK3DS_C_QUIKSTUFF				0xc330
  411|       |#define CHK3DS_C_SEE_LIGHTS				0xc340
  412|       |#define CHK3DS_C_SEE_CAMERAS			0xc350
  413|       |#define CHK3DS_C_SEE_3D					0xc360
  414|       |#define CHK3DS_C_MESHSEL				0xc370
  415|       |#define CHK3DS_C_MESHUNSEL				0xc380
  416|       |#define CHK3DS_C_POLYSEL				0xc390
  417|       |#define CHK3DS_C_POLYUNSEL				0xc3a0
  418|       |#define CHK3DS_C_SHPLOCAL				0xc3a2
  419|       |#define CHK3DS_C_MSHLOCAL				0xc3a4
  420|       |#define CHK3DS_C_NUM_FORMAT				0xc3b0
  421|       |#define CHK3DS_C_ARCH_DENOM				0xc3c0
  422|       |#define CHK3DS_C_IN_DEVICE				0xc3d0
  423|       |#define CHK3DS_C_MSCALE					0xc3e0
  424|       |#define CHK3DS_C_COMM_PORT				0xc3f0
  425|       |#define CHK3DS_C_TAB_BASES				0xc400
  426|       |#define CHK3DS_C_TAB_DIVS				0xc410
  427|       |#define CHK3DS_C_MASTER_SCALES			0xc420
  428|       |#define CHK3DS_C_SHOW_1STVERT			0xc430
  429|       |#define CHK3DS_C_SHAPER_OK				0xc440
  430|       |#define CHK3DS_C_LOFTER_OK				0xc450
  431|       |#define CHK3DS_C_EDITOR_OK				0xc460
  432|       |#define CHK3DS_C_KEYFRAMER_OK			0xc470
  433|       |#define CHK3DS_C_PICKSIZE				0xc480
  434|       |#define CHK3DS_C_MAPTYPE				0xc490
  435|       |#define CHK3DS_C_MAP_DISPLAY			0xc4a0
  436|       |#define CHK3DS_C_TILE_XY				0xc4b0
  437|       |#define CHK3DS_C_MAP_XYZ				0xc4c0
  438|       |#define CHK3DS_C_MAP_SCALE				0xc4d0
  439|       |#define CHK3DS_C_MAP_MATRIX_OLD			0xc4e0
  440|       |#define CHK3DS_C_MAP_MATRIX				0xc4e1
  441|       |#define CHK3DS_C_MAP_WID_HT				0xc4f0
  442|       |#define CHK3DS_C_OBNAME					0xc500
  443|       |#define CHK3DS_C_CAMNAME				0xc510
  444|       |#define CHK3DS_C_LTNAME					0xc520
  445|       |#define CHK3DS_C_CUR_MNAME				0xc525
  446|       |#define CHK3DS_C_CURMTL_FROM_MESH		0xc526
  447|       |#define CHK3DS_C_GET_SHAPE_MAKE_FACES	0xc527
  448|       |#define CHK3DS_C_DETAIL					0xc530
  449|       |#define CHK3DS_C_VERTMARK				0xc540
  450|       |#define CHK3DS_C_MSHAX					0xc550
  451|       |#define CHK3DS_C_MSHCP					0xc560
  452|       |#define CHK3DS_C_USERAX					0xc570
  453|       |#define CHK3DS_C_SHOOK					0xc580
  454|       |#define CHK3DS_C_RAX					0xc590
  455|       |#define CHK3DS_C_STAPE					0xc5a0
  456|       |#define CHK3DS_C_LTAPE					0xc5b0
  457|       |#define CHK3DS_C_ETAPE					0xc5c0
  458|       |#define CHK3DS_C_KTAPE					0xc5c8
  459|       |#define CHK3DS_C_SPHSEGS				0xc5d0
  460|       |#define CHK3DS_C_GEOSMOOTH				0xc5e0
  461|       |#define CHK3DS_C_HEMISEGS				0xc5f0
  462|       |#define CHK3DS_C_PRISMSEGS				0xc600
  463|       |#define CHK3DS_C_PRISMSIDES				0xc610
  464|       |#define CHK3DS_C_TUBESEGS				0xc620
  465|       |#define CHK3DS_C_TUBESIDES				0xc630
  466|       |#define CHK3DS_C_TORSEGS				0xc640
  467|       |#define CHK3DS_C_TORSIDES				0xc650
  468|       |#define CHK3DS_C_CONESIDES				0xc660
  469|       |#define CHK3DS_C_CONESEGS				0xc661
  470|       |#define CHK3DS_C_NGPARMS				0xc670
  471|       |#define CHK3DS_C_PTHLEVEL				0xc680
  472|       |#define CHK3DS_C_MSCSYM					0xc690
  473|       |#define CHK3DS_C_MFTSYM					0xc6a0
  474|       |#define CHK3DS_C_MTTSYM					0xc6b0
  475|       |#define CHK3DS_C_SMOOTHING				0xc6c0
  476|       |#define CHK3DS_C_MODICOUNT				0xc6d0
  477|       |#define CHK3DS_C_FONTSEL				0xc6e0
  478|       |#define CHK3DS_C_TESS_TYPE				0xc6f0
  479|       |#define CHK3DS_C_TESS_TENSION			0xc6f1
  480|       |#define CHK3DS_C_SEG_START				0xc700
  481|       |#define CHK3DS_C_SEG_END				0xc705
  482|       |#define CHK3DS_C_CURTIME				0xc710
  483|       |#define CHK3DS_C_ANIMLENGTH				0xc715
  484|       |#define CHK3DS_C_PV_FROM				0xc720
  485|       |#define CHK3DS_C_PV_TO					0xc725
  486|       |#define CHK3DS_C_PV_DOFNUM				0xc730
  487|       |#define CHK3DS_C_PV_RNG					0xc735
  488|       |#define CHK3DS_C_PV_NTH					0xc740
  489|       |#define CHK3DS_C_PV_TYPE				0xc745
  490|       |#define CHK3DS_C_PV_METHOD				0xc750
  491|       |#define CHK3DS_C_PV_FPS					0xc755
  492|       |#define CHK3DS_C_VTR_FRAMES				0xc765
  493|       |#define CHK3DS_C_VTR_HDTL				0xc770
  494|       |#define CHK3DS_C_VTR_HD					0xc771
  495|       |#define CHK3DS_C_VTR_TL					0xc772
  496|       |#define CHK3DS_C_VTR_IN					0xc775
  497|       |#define CHK3DS_C_VTR_PK					0xc780
  498|       |#define CHK3DS_C_VTR_SH					0xc785
  499|       |#define CHK3DS_C_WORK_MTLS				0xc790
  500|       |#define CHK3DS_C_WORK_MTLS_2			0xc792
  501|       |#define CHK3DS_C_WORK_MTLS_3			0xc793
  502|       |#define CHK3DS_C_WORK_MTLS_4			0xc794
  503|       |#define CHK3DS_C_BGTYPE					0xc7a1
  504|       |#define CHK3DS_C_MEDTILE				0xc7b0
  505|       |#define CHK3DS_C_LO_CONTRAST			0xc7d0
  506|       |#define CHK3DS_C_HI_CONTRAST			0xc7d1
  507|       |#define CHK3DS_C_FROZ_DISPLAY			0xc7e0
  508|       |#define CHK3DS_C_BOOLWELD				0xc7f0
  509|       |#define CHK3DS_C_BOOLTYPE				0xc7f1
  510|       |#define CHK3DS_C_ANG_THRESH				0xc900
  511|       |#define CHK3DS_C_SS_THRESH				0xc901
  512|       |#define CHK3DS_C_TEXTURE_BLUR_DEFAULT	0xc903
  513|       |#define CHK3DS_C_MAPDRAWER				0xca00
  514|       |#define CHK3DS_C_MAPDRAWER1				0xca01
  515|       |#define CHK3DS_C_MAPDRAWER2				0xca02
  516|       |#define CHK3DS_C_MAPDRAWER3				0xca03
  517|       |#define CHK3DS_C_MAPDRAWER4				0xca04
  518|       |#define CHK3DS_C_MAPDRAWER5				0xca05
  519|       |#define CHK3DS_C_MAPDRAWER6				0xca06
  520|       |#define CHK3DS_C_MAPDRAWER7				0xca07
  521|       |#define CHK3DS_C_MAPDRAWER8				0xca08
  522|       |#define CHK3DS_C_MAPDRAWER9				0xca09
  523|       |#define CHK3DS_C_MAPDRAWER_ENTRY		0xca10
  524|       |#define CHK3DS_C_BACKUP_FILE			0xca20
  525|       |#define CHK3DS_C_DITHER_256				0xca21
  526|       |#define CHK3DS_C_SAVE_LAST				0xca22
  527|       |#define CHK3DS_C_USE_ALPHA				0xca23
  528|       |#define CHK3DS_C_TGA_DEPTH				0xca24
  529|       |#define CHK3DS_C_REND_FIELDS			0xca25
  530|       |#define CHK3DS_C_REFLIP					0xca26
  531|       |#define CHK3DS_C_SEL_ITEMTOG			0xca27
  532|       |#define CHK3DS_C_SEL_RESET				0xca28
  533|       |#define CHK3DS_C_STICKY_KEYINF			0xca29
  534|       |#define CHK3DS_C_WELD_THRESHOLD			0xca2a
  535|       |#define CHK3DS_C_ZCLIP_POINT			0xca2b
  536|       |#define CHK3DS_C_ALPHA_SPLIT			0xca2c
  537|       |#define CHK3DS_C_KF_SHOW_BACKFACE		0xca30
  538|       |#define CHK3DS_C_OPTIMIZE_LOFT			0xca40
  539|       |#define CHK3DS_C_TENS_DEFAULT			0xca42
  540|       |#define CHK3DS_C_CONT_DEFAULT			0xca44
  541|       |#define CHK3DS_C_BIAS_DEFAULT			0xca46
  542|       |#define CHK3DS_C_DXFNAME_SRC			0xca50
  543|       |#define CHK3DS_C_AUTO_WELD				0xca60
  544|       |#define CHK3DS_C_AUTO_UNIFY				0xca70
  545|       |#define CHK3DS_C_AUTO_SMOOTH			0xca80
  546|       |#define CHK3DS_C_DXF_SMOOTH_ANG			0xca90
  547|       |#define CHK3DS_C_SMOOTH_ANG				0xcaa0
  548|       |#define CHK3DS_C_WORK_MTLS_5			0xcb00
  549|       |#define CHK3DS_C_WORK_MTLS_6			0xcb01
  550|       |#define CHK3DS_C_WORK_MTLS_7			0xcb02
  551|       |#define CHK3DS_C_WORK_MTLS_8			0xcb03
  552|       |#define CHK3DS_C_WORKMTL				0xcb04
  553|       |#define CHK3DS_C_SXP_TEXT_DATA			0xcb10
  554|       |#define CHK3DS_C_SXP_OPAC_DATA			0xcb11
  555|       |#define CHK3DS_C_SXP_BUMP_DATA			0xcb12
  556|       |#define CHK3DS_C_SXP_SHIN_DATA			0xcb13
  557|       |#define CHK3DS_C_SXP_TEXT2_DATA			0xcb20
  558|       |#define CHK3DS_C_SXP_SPEC_DATA			0xcb24
  559|       |#define CHK3DS_C_SXP_SELFI_DATA			0xcb28
  560|       |#define CHK3DS_C_SXP_TEXT_MASKDATA		0xcb30
  561|       |#define CHK3DS_C_SXP_TEXT2_MASKDATA		0xcb32
  562|       |#define CHK3DS_C_SXP_OPAC_MASKDATA		0xcb34
  563|       |#define CHK3DS_C_SXP_BUMP_MASKDATA		0xcb36
  564|       |#define CHK3DS_C_SXP_SPEC_MASKDATA		0xcb38
  565|       |#define CHK3DS_C_SXP_SHIN_MASKDATA		0xcb3a
  566|       |#define CHK3DS_C_SXP_REFL_MASKDATA		0xcb3e
  567|       |#define CHK3DS_C_NET_USE_VPOST			0xcc00
  568|       |#define CHK3DS_C_NET_USE_GAMMA			0xcc10
  569|       |#define CHK3DS_C_NET_FIELD_ORDER		0xcc20
  570|       |#define CHK3DS_C_BLUR_FRAMES			0xcd00
  571|       |#define CHK3DS_C_BLUR_SAMPLES			0xcd10
  572|       |#define CHK3DS_C_BLUR_DUR				0xcd20
  573|       |#define CHK3DS_C_HOT_METHOD				0xcd30
  574|       |#define CHK3DS_C_HOT_CHECK				0xcd40
  575|       |#define CHK3DS_C_PIXEL_SIZE				0xcd50
  576|       |#define CHK3DS_C_DISP_GAMMA				0xcd60
  577|       |#define CHK3DS_C_FBUF_GAMMA				0xcd70
  578|       |#define CHK3DS_C_FILE_OUT_GAMMA			0xcd80
  579|       |#define CHK3DS_C_FILE_IN_GAMMA			0xcd82
  580|       |#define CHK3DS_C_GAMMA_CORRECT			0xcd84
  581|       |#define CHK3DS_C_APPLY_DISP_GAMMA		0xcd90
  582|       |#define CHK3DS_C_APPLY_FBUF_GAMMA		0xcda0
  583|       |#define CHK3DS_C_APPLY_FILE_GAMMA		0xcdb0
  584|       |#define CHK3DS_C_FORCE_WIRE				0xcdc0
  585|       |#define CHK3DS_C_RAY_SHADOWS			0xcdd0
  586|       |#define CHK3DS_C_MASTER_AMBIENT			0xcde0
  587|       |#define CHK3DS_C_SUPER_SAMPLE			0xcdf0
  588|       |#define CHK3DS_C_OBJECT_MBLUR			0xce00
  589|       |#define CHK3DS_C_MBLUR_DITHER			0xce10
  590|       |#define CHK3DS_C_DITHER_24				0xce20
  591|       |#define CHK3DS_C_SUPER_BLACK			0xce30
  592|       |#define CHK3DS_C_SAFE_FRAME				0xce40
  593|       |#define CHK3DS_C_VIEW_PRES_RATIO		0xce50
  594|       |#define CHK3DS_C_BGND_PRES_RATIO		0xce60
  595|       |#define CHK3DS_C_NTH_SERIAL_NUM			0xce70
  596|       |
  597|       |//-----------------------------------------------------------------------------
  598|       |// Dxxx Group
  599|       |//-------
  600|       |#define	CHK3DS_D_VPDATA					0xd000 	 
  601|       |#define	CHK3DS_D_P_QUEUE_ENTRY			0xd100 	 
  602|       |#define	CHK3DS_D_P_QUEUE_IMAGE			0xd110 	 
  603|       |#define	CHK3DS_D_P_QUEUE_USEIGAMMA		0xd114 	 
  604|       |#define	CHK3DS_D_P_QUEUE_PROC			0xd120 	
  605|       |#define	CHK3DS_D_P_QUEUE_SOLID			0xd130 	
  606|       |#define	CHK3DS_D_P_QUEUE_GRADIENT		0xd140 	 
  607|       |#define	CHK3DS_D_P_QUEUE_KF				0xd150 	
  608|       |#define	CHK3DS_D_P_QUEUE_MOTBLUR		0xd152 	 
  609|       |#define	CHK3DS_D_P_QUEUE_MB_REPEAT		0xd153 	 
  610|       |#define	CHK3DS_D_P_QUEUE_NONE			0xd160 	 
  611|       |#define	CHK3DS_D_P_QUEUE_RESIZE			0xd180 	 
  612|       |#define	CHK3DS_D_P_QUEUE_OFFSET			0xd185 	 
  613|       |#define	CHK3DS_D_P_QUEUE_ALIGN			0xd190 	 
  614|       |#define	CHK3DS_D_P_CUSTOM_SIZE			0xd1a0 	 
  615|       |#define	CHK3DS_D_P_ALPH_NONE			0xd210 	 
  616|       |#define	CHK3DS_D_P_ALPH_PSEUDO			0xd220 	 
  617|       |#define	CHK3DS_D_P_ALPH_OP_PSEUDO		0xd221 	 
  618|       |#define	CHK3DS_D_P_ALPH_BLUR			0xd222 	 
  619|       |#define	CHK3DS_D_P_ALPH_PCOL			0xd225 	 
  620|       |#define	CHK3DS_D_P_ALPH_C0				0xd230 	 
  621|       |#define	CHK3DS_D_P_ALPH_OP_KEY			0xd231 	 
  622|       |#define	CHK3DS_D_P_ALPH_KCOL			0xd235 	 
  623|       |#define	CHK3DS_D_P_ALPH_OP_NOCONV		0xd238 	 
  624|       |#define	CHK3DS_D_P_ALPH_IMAGE			0xd240 	 
  625|       |#define	CHK3DS_D_P_ALPH_ALPHA			0xd250 	 
  626|       |#define	CHK3DS_D_P_ALPH_QUES			0xd260 	 
  627|       |#define	CHK3DS_D_P_ALPH_QUEIMG			0xd265 	 
  628|       |#define	CHK3DS_D_P_ALPH_CUTOFF			0xd270 	 
  629|       |#define	CHK3DS_D_P_ALPHANEG				0xd280 	 
  630|       |#define	CHK3DS_D_P_TRAN_NONE			0xd300 	 
  631|       |#define	CHK3DS_D_P_TRAN_IMAGE			0xd310 	 
  632|       |#define	CHK3DS_D_P_TRAN_FRAMES			0xd312 	 
  633|       |#define	CHK3DS_D_P_TRAN_FADEIN			0xd320 	 
  634|       |#define	CHK3DS_D_P_TRAN_FADEOUT			0xd330 	 
  635|       |#define	CHK3DS_D_P_TRANNEG				0xd340 	 
  636|       |#define	CHK3DS_D_P_RANGES				0xd400 	 
  637|       |#define	CHK3DS_D_P_PROC_DATA			0xd500 	 
  638|       |
  639|       |//-----------------------------------------------------------------------------
  640|       |// Fxxx Group
  641|       |//-------
  642|       |#define	CHK3DS_F_POS_TRACK_TAG_KEY		0xf020 	 
  643|       |#define	CHK3DS_F_ROT_TRACK_TAG_KEY		0xf021 	 
  644|       |#define	CHK3DS_F_SCL_TRACK_TAG_KEY		0xf022 	 
  645|       |#define	CHK3DS_F_FOV_TRACK_TAG_KEY		0xf023 	 
  646|       |#define	CHK3DS_F_ROLL_TRACK_TAG_KEY		0xf024 	 
  647|       |#define	CHK3DS_F_COL_TRACK_TAG_KEY		0xf025 	 
  648|       |#define	CHK3DS_F_MORPH_TRACK_TAG_KEY	0xf026 	 
  649|       |#define	CHK3DS_F_HOT_TRACK_TAG_KEY		0xf027 	 
  650|       |#define	CHK3DS_F_FALL_TRACK_TAG_KEY		0xf028 	 
  651|       |#define	CHK3DS_F_POINT_ARRAY_ENTRY		0xf110 	 
  652|       |#define	CHK3DS_F_POINT_FLAG_ARRAY_ENTRY	0xf111 	 
  653|       |#define	CHK3DS_F_FACE_ARRAY_ENTRY		0xf120 	 
  654|       |#define	CHK3DS_F_MSH_MAT_GROUP_ENTRY	0xf130 	 
  655|       |#define	CHK3DS_F_TEX_VERTS_ENTRY		0xf140 	 
  656|       |#define	CHK3DS_F_SMOOTH_GROUP_ENTRY		0xf150 	 
  657|       |#define	CHK3DS_F_DUMMY					0xffff 	 
  658|       |
  659|       |#endif	//_DEFINES_3DS_HEADER_

/workspaces/cg/src/cgmesh/mesh_io_3ds_structures.h:
    1|       |/*****************************************************************************/
    2|       |//
    3|       |// File: Structures_3DS.h
    4|       |//
    5|       |// Desc: The structures needed for loading and saving easily 3D file format
    6|       |//
    7|       |/*****************************************************************************/
    8|       |
    9|       |#ifndef _STRUCTURES_3DS_HEADER_
   10|       |#define _STRUCTURES_3DS_HEADER_
   11|       |
   12|       |#include <vector>
   13|       |using namespace std;
   14|       |
   15|       |typedef bool BOOL;
   16|      5|#define TRUE true
   17|      8|#define FALSE false
   18|       |typedef unsigned char BYTE;
   19|       |typedef float			FLOAT32;
   20|       |typedef short			INT16;
   21|       |typedef unsigned short	UINT16;
   22|       |typedef int				INT32;
   23|       |typedef unsigned int	UINT32;
   24|       |
   25|       |//typedef void* PVOID;
   26|       |
   27|       |typedef struct VECTOR3_F
   28|       |{
   29|       |	FLOAT32 fX;
   30|       |	FLOAT32 fY;
   31|       |	FLOAT32 fZ;
   32|       |} VECTOR3f;
   33|       |
   34|       |typedef struct VECTOR2_F
   35|       |{
   36|       |	FLOAT32 fU;
   37|       |	FLOAT32 fV;
   38|       |} VECTOR2f;
   39|       |
   40|       |typedef struct COLORVALUEUC
   41|       |{
   42|       |    BYTE r;
   43|       |    BYTE g;
   44|       |    BYTE b;
   45|       |    BYTE a;
   46|       |} COLORVALUEUC;
   47|       |
   48|       |typedef struct MATERIALUC
   49|       |{
   50|       |    COLORVALUEUC   Diffuse;	// Diffuse color RGBA
   51|       |    COLORVALUEUC   Ambient;	// Ambient color RGB
   52|       |    COLORVALUEUC   Specular;	// Specular 'shininess'
   53|       |    COLORVALUEUC   Emissive;	// Emissive color RGB
   54|       |    FLOAT32				Power;		// Sharpness if specular highlight
   55|       |} MATERIALUC;
   56|       |
   57|       |
   58|       |
   59|       |
   60|       |// indices structure (since .3DS stores 4 unsigned shorts)
   61|       |struct tIndices
   62|       |{							
   63|       |	UINT16 a, b, c, bVisible;	// This will hold point1, 2, and 3 index's into the vertex array plus a visible flag
   64|       |};
   65|       |
   66|       |// face structure
   67|       |typedef struct _t3DSFace_
   68|       |{
   69|       |	INT32 vertIndex[3];			// indices for the verts that make up this triangle
   70|       |	INT32 coordIndex[3];		// indices for the tex coords to texture this face
   71|       |	INT32 materialID;			// The texture ID to use, which is the index into our texture array
   72|       |
   73|       |} t3DSFace;
   74|       |
   75|       |// Information about the chunk
   76|       |struct t3DSChunk
   77|       |{
   78|       |	UINT16 ID;					// The chunk's ID		
   79|       |	UINT32 length;				// The length of the chunk
   80|       |	UINT32 bytesRead;			// The amount of bytes read within that chunk
   81|       |};
   82|       |
   83|       |//
   84|       |// Information about the material
   85|       |//
   86|       |typedef struct _t3DSMaterialInfo_
   87|       |{
   88|       |	char	strName[255];		// The texture name
   89|       |	char	strFile[255];		// The texture file name (If this is set it's a texture map)
   90|       |	BYTE	color[3];			// The color of the object (R, G, B)
   91|       |	INT32   texureId;			// the texture ID
   92|       |	FLOAT32 uScale;				// u tiling of texture  (Currently not used)
   93|       |	FLOAT32 vScale;				// v tiling of texture	(Currently not used)
   94|       |	FLOAT32 uOffset;			// u offset of texture	(Currently not used)
   95|       |	FLOAT32 vOffset;			// v offset of texture	(Currently not used)
   96|       |
   97|       |	INT32	wTiling;			//Tile mapping value
   98|       |	FLOAT32 fTexBlur;			//Text Blur Value
   99|       |
  100|       |	MATERIALUC sMaterial;
  101|       |	FLOAT32 fTransparency;
  102|       |    
  103|       |	FLOAT32 fTransparencyFalloffPercent;
  104|       |	FLOAT32 fReflectionBlurPercent;
  105|       |	FLOAT32 f2Sided;
  106|       |	FLOAT32 fAddTrans;
  107|       |	FLOAT32 fSelfIllum;
  108|       |	BOOL	bWire;
  109|       |	FLOAT32 fWireThickness;
  110|       |	FLOAT32 fInTranc;
  111|       |	BOOL	bSoften;
  112|       |
  113|       |} t3DSMaterialInfo;
  114|       |
  115|       |
  116|       |// Faces Material List
  117|       |typedef struct _t3DSFacesMaterialList
  118|       |{
  119|       |	INT32  materialID;			// Material ID
  120|       |	INT32  numOfFaces;			// The number of faces
  121|       |	UINT16* pFacesMaterialsList;	// List of faces concerned by a material for each material used by the object
  122|       |} t3DSFacesMaterialList;
  123|       |
  124|       |//
  125|       |// Information about the trimesh
  126|       |//
  127|       |typedef struct _t3DSObject_
  128|       |{
  129|       |	char	strName[255];								// The name of the object
  130|       |
  131|       |	FLOAT32	LocalCoordinateSystem[4][3];				// Local coordinate system
  132|       |
  133|       |	INT32	numOfVerts;									// The number of verts in the model
  134|       |	INT32	numOfFaces;									// The number of faces in the model
  135|       |	INT32	numTexVertex;								// The number of texture coordinates
  136|       |
  137|       |	INT32	numOfMaterials;								// The number of materials
  138|       |	vector<t3DSFacesMaterialList> pFacesMaterialList;	// the faces material list
  139|       |
  140|       |	BOOL    bHasTexture;								// This is TRUE if there is a texture map for this object
  141|       |
  142|       |	VECTOR3f	*pVerts;							// The object's vertices
  143|       |	VECTOR3f	*pNormals;							// The object's normals
  144|       |	VECTOR2f	*pTexVerts;							// The texture's UV coordinates
  145|       |	t3DSFace	*pFaces;							// The faces information of the object
  146|       |} t3DSObject;
  147|       |
  148|       |//
  149|       |// Information about the lights
  150|       |//
  151|       |typedef struct _t3DSLight_
  152|       |{
  153|       |	char	strName[255];		// The name of the light
  154|       |	FLOAT32 position[3];
  155|       |
  156|       |	FLOAT32 color[3];
  157|       |	FLOAT32 outerRange;
  158|       |	FLOAT32 innerRange;
  159|       |	FLOAT32 multiplier;
  160|       |	BOOL	isSpotLight;
  161|       |	FLOAT32 spotLight_target[3];
  162|       |	FLOAT32 spotLight_hotSpot;
  163|       |	FLOAT32 spotLight_fallOff;
  164|       |	
  165|       |	BOOL	isShadowed;
  166|       |	FLOAT32	shadowBias;
  167|       |	FLOAT32	shadowFilter;
  168|       |	INT16	shadowSize;
  169|       |	
  170|       |	FLOAT32	roll;
  171|       |	FLOAT32 rayBias;
  172|       |	BOOL	attenuate;
  173|       |
  174|       |} t3DSLight;
  175|       |
  176|       |//
  177|       |// Information about the cameras
  178|       |//
  179|       |typedef struct _t3DCamera_
  180|       |{
  181|       |	char strName[255];			// The name of the camera
  182|       |	FLOAT32 position[3];
  183|       |	FLOAT32 target[3];
  184|       |	FLOAT32 bank;				// (degrees)
  185|       |	FLOAT32 lens;
  186|       |
  187|       |} t3DSCamera;
  188|       |
  189|       |//
  190|       |// Information about the animations
  191|       |//
  192|       |typedef struct _t3DAnimation_
  193|       |{
  194|       |	INT32			objectType; // object type concerned by the animation
  195|       |	INT32			nTracks;
  196|       |	vector<INT32>	trackType;
  197|       |	vector<void*>	track;
  198|       |} t3DSAnimation;
  199|       |
  200|       |// Information about the tracks
  201|       |typedef struct _t3DSTrack_
  202|       |{
  203|       |	INT16 flag;
  204|       |	INT32 unknown1, unknown2;
  205|       |	INT32 numOfKeys;
  206|       |	INT32 *keyNumber;
  207|       |	INT16 *accelerationDataPresent;
  208|       |} t3DSTrack;
  209|       |
  210|       |// Header of the tracks
  211|       |typedef struct _t3DSTrackHeader_
  212|       |{
  213|       |	INT16 flag;
  214|       |	INT32 unknown1, unknown2;
  215|       |	INT32 numOfKeys;
  216|       |	INT32 *keyNumber;
  217|       |	INT16 *accelerationDataPresent;
  218|       |} t3DSTrackHeader;
  219|       |
  220|       |// position track
  221|       |typedef struct _t3DSPositionTrack_
  222|       |{
  223|       |	t3DSTrackHeader header;
  224|       |	FLOAT32 *position;
  225|       |} t3DSPositionTrack;
  226|       |
  227|       |// rotation track
  228|       |typedef struct _t3DSRotationTrack_
  229|       |{
  230|       |	t3DSTrackHeader header;
  231|       |	FLOAT32 *angle;				// radians
  232|       |	FLOAT32 *axis;
  233|       |} t3DSRotationTrack;
  234|       |
  235|       |// scale track
  236|       |typedef struct _t3DSScaleTrack_
  237|       |{
  238|       |	t3DSTrackHeader header;
  239|       |	FLOAT32 *size;
  240|       |} t3DSScaleTrack;
  241|       |
  242|       |// FOV track
  243|       |typedef struct _t3DSFOVTrack_
  244|       |{
  245|       |	t3DSTrackHeader header;
  246|       |	FLOAT32 *angle;				// degrees
  247|       |} t3DSFOVTrack;
  248|       |
  249|       |// Roll track
  250|       |typedef struct _t3DSRollTrack_
  251|       |{
  252|       |	t3DSTrackHeader header;
  253|       |	FLOAT32 *angle;				// degrees
  254|       |} t3DSRollTrack;
  255|       |
  256|       |// Color track
  257|       |typedef struct _t3DSColorTrack_
  258|       |{
  259|       |	t3DSTrackHeader header;
  260|       |	//FLOAT32 *color; // format not specified !
  261|       |} t3DSColorTrack;
  262|       |
  263|       |// Morph track
  264|       |typedef struct _t3DSMorphTrack_
  265|       |{
  266|       |	t3DSTrackHeader header;
  267|       |	char *strName[255];
  268|       |} t3DSMorphTrack;
  269|       |
  270|       |// Hotspot track
  271|       |typedef struct _t3DSHotspotTrack_
  272|       |{
  273|       |	t3DSTrackHeader header;
  274|       |	FLOAT32 *angle;				// degrees
  275|       |} t3DSHotspotTrack;
  276|       |
  277|       |// Falloff track
  278|       |typedef struct _t3DSFalloffTrack_
  279|       |{
  280|       |	t3DSTrackHeader header;
  281|       |	FLOAT32 *angle;				// degrees
  282|       |} t3DSFalloffTrack;
  283|       |
  284|       |// Hide track
  285|       |typedef struct _t3DSHideTrack_
  286|       |{
  287|       |	t3DSTrackHeader header;
  288|       |} t3DSHideTrack;
  289|       |
  290|       |//
  291|       |// Unknown chunks
  292|       |//
  293|       |typedef struct _t3DSUnknownChunk
  294|       |{
  295|       |	UINT16 chunkID;
  296|       |	UINT16 fatherID;
  297|       |} t3DSUnknownChunk;
  298|       |
  299|       |//
  300|       |// Information about the model
  301|       |//
  302|       |typedef struct _t3DSModel_ 
  303|       |{
  304|       |	INT32 fileVersion; // version of the file
  305|       |	INT32 meshVersion; // version of the mesh
  306|       |
  307|       |	INT32 numOfObjects;			// number of objects in the model
  308|       |	INT32 numOfMaterials;		// number of materials for the model
  309|       |	INT32 numOfLights;
  310|       |	INT32 numOfCameras;
  311|       |	INT32 numOfAnimations;
  312|       |	vector<t3DSMaterialInfo>	pMaterials;		// list of material information (Textures and colors)
  313|       |	vector<t3DSObject>			pObject;		// list of objects (trimesh)
  314|       |	vector<t3DSLight>			pLights;		// list of lights
  315|       |	vector<t3DSCamera>			pCameras;		// list of cameras
  316|       |	vector<t3DSAnimation>		pAnimations;	// list of animations
  317|       |
  318|       |	char strPathToModel[255];					// path to the model
  319|       |
  320|       |	INT32	numOfUnknownChunks;							// The number of unknown chunks
  321|       |	vector<t3DSUnknownChunk>	pUnknownChunks;			// Unknown chunks
  322|       |} t3DSModel;
  323|       |
  324|       |// dump the content of the 3DS structure
  325|       |extern void Dump3DSFile (t3DSModel *pModel, char* pFilename);
  326|       |
  327|       |#endif	// _STRUCTURES_3DS_HEADER_

/workspaces/cg/src/cgmesh/mesh_io_rply.cpp:
    1|       |/* ----------------------------------------------------------------------
    2|       | * RPly library, read/write PLY files
    3|       | * Diego Nehab, IMPA
    4|       | * http://www.impa.br/~diego/software/rply
    5|       | *
    6|       | * This library is distributed under the MIT License. See notice
    7|       | * at the end of this file.
    8|       | * ---------------------------------------------------------------------- */
    9|       |#include <stdio.h>
   10|       |#include <ctype.h>
   11|       |#include <assert.h>
   12|       |#include <string.h>
   13|       |#include <limits.h>
   14|       |#include <float.h>
   15|       |#include <stdarg.h>
   16|       |#include <stdlib.h>
   17|       |#include <stddef.h>
   18|       |
   19|       |#include "mesh_io_rply.h"
   20|       |
   21|       |/* ----------------------------------------------------------------------
   22|       | * Make sure we get our integer types right
   23|       | * ---------------------------------------------------------------------- */
   24|       |#if defined(_MSC_VER) && (_MSC_VER < 1600)
   25|       |/* C99 stdint.h only supported in MSVC++ 10.0 and up */
   26|       |typedef __int8 t_ply_int8;
   27|       |typedef __int16 t_ply_int16;
   28|       |typedef __int32 t_ply_int32;
   29|       |typedef unsigned __int8 t_ply_uint8;
   30|       |typedef unsigned __int16 t_ply_uint16;
   31|       |typedef unsigned __int32 t_ply_uint32;
   32|       |#define PLY_INT8_MAX (127)
   33|       |#define PLY_INT8_MIN (-PLY_INT8_MAX-1)
   34|       |#define PLY_INT16_MAX (32767)
   35|       |#define PLY_INT16_MIN (-PLY_INT16_MAX-1)
   36|       |#define PLY_INT32_MAX (2147483647)
   37|       |#define PLY_INT32_MIN (-PLY_INT32_MAX-1)
   38|       |#define PLY_UINT8_MAX (255)
   39|       |#define PLY_UINT16_MAX (65535)
   40|       |#define PLY_UINT32_MAX  (4294967295)
   41|       |#else
   42|       |#define __STDC_LIMIT_MACROS
   43|       |#include <stdint.h>
   44|       |typedef int8_t t_ply_int8;
   45|       |typedef int16_t t_ply_int16;
   46|       |typedef int32_t t_ply_int32;
   47|       |typedef uint8_t t_ply_uint8;
   48|       |typedef uint16_t t_ply_uint16;
   49|       |typedef uint32_t t_ply_uint32;
   50|      0|#define PLY_INT8_MIN INT8_MIN
   51|      0|#define PLY_INT8_MAX INT8_MAX
   52|      0|#define PLY_INT16_MIN INT16_MIN
   53|      0|#define PLY_INT16_MAX INT16_MAX
   54|      0|#define PLY_INT32_MIN INT32_MIN
   55|      0|#define PLY_INT32_MAX INT32_MAX
   56|      0|#define PLY_UINT8_MAX UINT8_MAX
   57|      0|#define PLY_UINT16_MAX UINT16_MAX
   58|      0|#define PLY_UINT32_MAX UINT32_MAX
   59|       |#endif
   60|       |
   61|       |/* ----------------------------------------------------------------------
   62|       | * Constants 
   63|       | * ---------------------------------------------------------------------- */
   64|      0|#define WORDSIZE 256
   65|      0|#define LINESIZE 1024
   66|      0|#define BUFFERSIZE (8*1024)
   67|       |
   68|       |typedef enum e_ply_io_mode_ {
   69|       |    PLY_READ, 
   70|       |    PLY_WRITE
   71|       |} e_ply_io_mode;
   72|       |
   73|       |static const char *const ply_storage_mode_list[] = {
   74|       |    "binary_big_endian", "binary_little_endian", "ascii", NULL
   75|       |};     /* order matches e_ply_storage_mode enum */
   76|       |
   77|       |static const char *const ply_type_list[] = {
   78|       |    "int8", "uint8", "int16", "uint16", 
   79|       |    "int32", "uint32", "float32", "float64",
   80|       |    "char", "uchar", "short", "ushort", 
   81|       |    "int", "uint", "float", "double",
   82|       |    "list", NULL
   83|       |};     /* order matches e_ply_type enum */
   84|       |
   85|       |/* ----------------------------------------------------------------------
   86|       | * Property reading callback argument
   87|       | *
   88|       | * element: name of element being processed
   89|       | * property: name of property being processed
   90|       | * nelements: number of elements of this kind in file
   91|       | * instance_index: index current element of this kind being processed
   92|       | * length: number of values in current list (or 1 for scalars)
   93|       | * value_index: index of current value int this list (or 0 for scalars)
   94|       | * value: value of property
   95|       | * pdata/idata: user data defined with ply_set_cb
   96|       | *
   97|       | * Returns handle to PLY file if succesful, NULL otherwise.
   98|       | * ---------------------------------------------------------------------- */
   99|       |typedef struct t_ply_argument_ {
  100|       |    p_ply_element element;
  101|       |    long instance_index;
  102|       |    p_ply_property property;
  103|       |    long length, value_index;
  104|       |    double value;
  105|       |    void *pdata;
  106|       |    long idata;
  107|       |} t_ply_argument;
  108|       |
  109|       |/* ----------------------------------------------------------------------
  110|       | * Property information
  111|       | *
  112|       | * name: name of this property
  113|       | * type: type of this property (list or type of scalar value)
  114|       | * length_type, value_type: type of list property count and values
  115|       | * read_cb: function to be called when this property is called
  116|       | *
  117|       | * Returns 1 if should continue processing file, 0 if should abort.
  118|       | * ---------------------------------------------------------------------- */
  119|       |typedef struct t_ply_property_ {
  120|       |    char name[WORDSIZE];
  121|       |    e_ply_type type, value_type, length_type;
  122|       |    p_ply_read_cb read_cb;
  123|       |    void *pdata;
  124|       |    long idata;
  125|       |} t_ply_property; 
  126|       |
  127|       |/* ----------------------------------------------------------------------
  128|       | * Element information
  129|       | *
  130|       | * name: name of this property
  131|       | * ninstances: number of elements of this type in file
  132|       | * property: property descriptions for this element
  133|       | * nproperty: number of properties in this element
  134|       | *
  135|       | * Returns 1 if should continue processing file, 0 if should abort.
  136|       | * ---------------------------------------------------------------------- */
  137|       |typedef struct t_ply_element_ {
  138|       |    char name[WORDSIZE];
  139|       |    long ninstances;
  140|       |    p_ply_property property;
  141|       |    long nproperties;
  142|       |} t_ply_element;
  143|       |
  144|       |/* ----------------------------------------------------------------------
  145|       | * Input/output driver
  146|       | *
  147|       | * Depending on file mode, different functions are used to read/write 
  148|       | * property fields. The drivers make it transparent to read/write in ascii, 
  149|       | * big endian or little endian cases.
  150|       | * ---------------------------------------------------------------------- */
  151|       |typedef int (*p_ply_ihandler)(p_ply ply, double *value);
  152|       |typedef int (*p_ply_ichunk)(p_ply ply, void *anydata, size_t size);
  153|       |typedef struct t_ply_idriver_ {
  154|       |    p_ply_ihandler ihandler[16];
  155|       |    p_ply_ichunk ichunk;
  156|       |    const char *name;
  157|       |} t_ply_idriver;
  158|       |typedef t_ply_idriver *p_ply_idriver;
  159|       |
  160|       |typedef int (*p_ply_ohandler)(p_ply ply, double value);
  161|       |typedef int (*p_ply_ochunk)(p_ply ply, void *anydata, size_t size);
  162|       |typedef struct t_ply_odriver_ {
  163|       |    p_ply_ohandler ohandler[16];
  164|       |    p_ply_ochunk ochunk;
  165|       |    const char *name;
  166|       |} t_ply_odriver;
  167|       |typedef t_ply_odriver *p_ply_odriver;
  168|       |
  169|       |/* ----------------------------------------------------------------------
  170|       | * Ply file handle. 
  171|       | *
  172|       | * io_mode: read or write (from e_ply_io_mode)
  173|       | * storage_mode: mode of file associated with handle (from e_ply_storage_mode)
  174|       | * element: elements description for this file
  175|       | * nelement: number of different elements in file
  176|       | * comment: comments for this file
  177|       | * ncomments: number of comments in file
  178|       | * obj_info: obj_info items for this file
  179|       | * nobj_infos: number of obj_info items in file
  180|       | * fp: file pointer associated with ply file
  181|       | * rn: skip extra char after end_header? 
  182|       | * buffer: last word/chunck of data read from ply file
  183|       | * buffer_first, buffer_last: interval of untouched good data in buffer
  184|       | * buffer_token: start of parsed token (line or word) in buffer
  185|       | * idriver, odriver: input driver used to get property fields from file 
  186|       | * argument: storage space for callback arguments
  187|       | * welement, wproperty: element/property type being written
  188|       | * winstance_index: index of instance of current element being written
  189|       | * wvalue_index: index of list property value being written 
  190|       | * wlength: number of values in list property being written
  191|       | * error_cb: error callback
  192|       | * pdata/idata: user data defined with ply_open/ply_create
  193|       | * ---------------------------------------------------------------------- */
  194|       |typedef struct t_ply_ {
  195|       |    e_ply_io_mode io_mode;
  196|       |    e_ply_storage_mode storage_mode;
  197|       |    p_ply_element element;
  198|       |    long nelements;
  199|       |    char *comment;
  200|       |    long ncomments;
  201|       |    char *obj_info;
  202|       |    long nobj_infos;
  203|       |    FILE *fp;
  204|       |    int rn;
  205|       |    char buffer[BUFFERSIZE];
  206|       |    size_t buffer_first, buffer_token, buffer_last;
  207|       |    p_ply_idriver idriver;
  208|       |    p_ply_odriver odriver;
  209|       |    t_ply_argument argument;
  210|       |    long welement, wproperty;
  211|       |    long winstance_index, wvalue_index, wlength;
  212|       |    p_ply_error_cb error_cb;
  213|       |    void *pdata;
  214|       |    long idata;
  215|       |} t_ply;
  216|       |
  217|       |static int ply_read_word(p_ply ply);
  218|       |static int ply_check_word(p_ply ply);
  219|       |static void ply_finish_word(p_ply ply, size_t size);
  220|       |static int ply_read_line(p_ply ply);
  221|       |static int ply_check_line(p_ply ply);
  222|       |static int ply_read_chunk(p_ply ply, void *anybuffer, size_t size);
  223|       |static int ply_read_chunk_reverse(p_ply ply, void *anybuffer, size_t size);
  224|       |static int ply_write_chunk(p_ply ply, void *anybuffer, size_t size);
  225|       |static int ply_write_chunk_reverse(p_ply ply, void *anybuffer, size_t size);
  226|       |static void ply_reverse(void *anydata, size_t size);
  227|       |
  228|       |
  229|       |/* ----------------------------------------------------------------------
  230|       | * Output handlers
  231|       | * ---------------------------------------------------------------------- */
  232|      0|static int oascii_int8(p_ply ply, double value) {
  233|      0|    if (value > PLY_INT8_MAX || value < PLY_INT8_MIN) return 0;
  234|      0|    return fprintf(ply->fp, "%d ", (t_ply_int8) value) > 0;
  235|      0|}
  236|       |
  237|      0|static int oascii_uint8(p_ply ply, double value) {
  238|      0|    if (value > PLY_UINT8_MAX || value < 0) return 0;
  239|      0|    return fprintf(ply->fp, "%d ", (t_ply_uint8) value) > 0;
  240|      0|}
  241|       |
  242|      0|static int oascii_int16(p_ply ply, double value) {
  243|      0|    if (value > PLY_INT16_MAX || value < PLY_INT16_MIN) return 0;
  244|      0|    return fprintf(ply->fp, "%d ", (t_ply_int16) value) > 0;
  245|      0|}
  246|       |
  247|      0|static int oascii_uint16(p_ply ply, double value) {
  248|      0|    if (value > PLY_UINT16_MAX || value < 0) return 0;
  249|      0|    return fprintf(ply->fp, "%d ", (t_ply_uint16) value) > 0;
  250|      0|}
  251|       |
  252|      0|static int oascii_int32(p_ply ply, double value) {
  253|      0|    if (value > PLY_INT32_MAX || value < PLY_INT32_MIN) return 0;
  254|      0|    return fprintf(ply->fp, "%d ", (t_ply_int32) value) > 0;
  255|      0|}
  256|       |
  257|      0|static int oascii_uint32(p_ply ply, double value) {
  258|      0|    if (value > PLY_UINT32_MAX || value < 0) return 0;
  259|      0|    return fprintf(ply->fp, "%d ", (t_ply_uint32) value) > 0;
  260|      0|}
  261|       |
  262|      0|static int oascii_float32(p_ply ply, double value) {
  263|      0|    if (value < -FLT_MAX || value > FLT_MAX) return 0;
  264|      0|    return fprintf(ply->fp, "%g ", (float) value) > 0;
  265|      0|}
  266|       |
  267|      0|static int oascii_float64(p_ply ply, double value) {
  268|      0|    if (value < -DBL_MAX || value > DBL_MAX) return 0;
  269|      0|    return fprintf(ply->fp, "%g ", value) > 0;
  270|      0|}
  271|       |
  272|      0|static int obinary_int8(p_ply ply, double value) {
  273|      0|    t_ply_int8 int8 = (t_ply_int8) value;
  274|      0|    if (value > PLY_INT8_MAX || value < PLY_INT8_MIN) return 0;
  275|      0|    return ply->odriver->ochunk(ply, &int8, sizeof(int8));
  276|      0|}
  277|       |
  278|      0|static int obinary_uint8(p_ply ply, double value) {
  279|      0|    t_ply_uint8 uint8 = (t_ply_uint8) value;
  280|      0|    if (value > PLY_UINT8_MAX || value < 0) return 0;
  281|      0|    return ply->odriver->ochunk(ply, &uint8, sizeof(uint8)); 
  282|      0|}
  283|       |
  284|      0|static int obinary_int16(p_ply ply, double value) {
  285|      0|    t_ply_int16 int16 = (t_ply_int16) value;
  286|      0|    if (value > PLY_INT16_MAX || value < PLY_INT16_MIN) return 0;
  287|      0|    return ply->odriver->ochunk(ply, &int16, sizeof(int16));
  288|      0|}
  289|       |
  290|      0|static int obinary_uint16(p_ply ply, double value) {
  291|      0|    t_ply_uint16 uint16 = (t_ply_uint16) value;
  292|      0|    if (value > PLY_UINT16_MAX || value < 0) return 0;
  293|      0|    return ply->odriver->ochunk(ply, &uint16, sizeof(uint16)); 
  294|      0|}
  295|       |
  296|      0|static int obinary_int32(p_ply ply, double value) {
  297|      0|    t_ply_int32 int32 = (t_ply_int32) value;
  298|      0|    if (value > PLY_INT32_MAX || value < PLY_INT32_MIN) return 0;
  299|      0|    return ply->odriver->ochunk(ply, &int32, sizeof(int32));
  300|      0|}
  301|       |
  302|      0|static int obinary_uint32(p_ply ply, double value) {
  303|      0|    t_ply_uint32 uint32 = (t_ply_uint32) value;
  304|      0|    if (value > PLY_UINT32_MAX || value < 0) return 0;
  305|      0|    return ply->odriver->ochunk(ply, &uint32, sizeof(uint32));
  306|      0|}
  307|       |
  308|      0|static int obinary_float32(p_ply ply, double value) {
  309|      0|    float float32 = (float) value;
  310|      0|    if (value > FLT_MAX || value < -FLT_MAX) return 0;
  311|      0|    return ply->odriver->ochunk(ply, &float32, sizeof(float32));
  312|      0|}
  313|       |
  314|      0|static int obinary_float64(p_ply ply, double value) {
  315|      0|    return ply->odriver->ochunk(ply, &value, sizeof(value)); 
  316|      0|}
  317|       |
  318|       |/* ----------------------------------------------------------------------
  319|       | * Buffer support functions
  320|       | * ---------------------------------------------------------------------- */
  321|       |/* pointers to tokenized word and line in buffer */
  322|      0|#define BWORD(p) (p->buffer + p->buffer_token)
  323|      0|#define BLINE(p) (p->buffer + p->buffer_token)
  324|       |
  325|       |/* pointer to start of untouched bytes in buffer */
  326|      0|#define BFIRST(p) (p->buffer + p->buffer_first) 
  327|       |
  328|       |/* number of bytes untouched in buffer */
  329|      0|#define BSIZE(p) (p->buffer_last - p->buffer_first) 
  330|       |
  331|       |/* consumes data from buffer */
  332|      0|#define BSKIP(p, s) (p->buffer_first += s)
  333|       |
  334|       |/* refills the buffer */
  335|      0|static int BREFILL(p_ply ply) {
  336|       |    /* move untouched data to beginning of buffer */
  337|      0|    size_t size = BSIZE(ply);
  338|      0|    memmove(ply->buffer, BFIRST(ply), size);
  339|      0|    ply->buffer_last = size;
  340|      0|    ply->buffer_first = ply->buffer_token = 0;
  341|       |    /* fill remaining with new data */
  342|      0|    size = fread(ply->buffer+size, 1, BUFFERSIZE-size-1, ply->fp);
  343|       |    /* place sentinel so we can use str* functions with buffer */
  344|      0|    ply->buffer[BUFFERSIZE-1] = '\0';
  345|       |    /* check if read failed */
  346|      0|    if (size <= 0) return 0;
  347|       |    /* increase size to account for new data */
  348|      0|    ply->buffer_last += size;
  349|      0|    return 1;
  350|      0|}
  351|       |
  352|       |/* We don't care about end-of-line, generally, because we
  353|       | * separate words by any white-space character.
  354|       | * Unfortunately, in binary mode, right after 'end_header', 
  355|       | * we have to know *exactly* how many characters to skip */
  356|       |/* We use the end-of-line marker after the 'ply' magic
  357|       | * number to figure out what to do */
  358|      0|static int ply_read_header_magic(p_ply ply) {
  359|      0|    char *magic = ply->buffer;
  360|      0|    if (!BREFILL(ply)) {
  361|      0|        ply->error_cb(ply, "Unable to read magic number from file");
  362|      0|        return 0;
  363|      0|    }
  364|       |    /* check if it is ply */
  365|      0|    if (magic[0] != 'p' || magic[1] != 'l' || magic[2] != 'y' 
  366|      0|            || !isspace(magic[3])) {
  367|      0|        ply->error_cb(ply, "Wrong magic number. Expected 'ply'");
  368|      0|        return 0;
  369|      0|    }
  370|       |    /* figure out if we have to skip the extra character
  371|       |     * after header when we reach the binary part of file */
  372|      0|    ply->rn = magic[3] == '\r' && magic[4] == '\n';
  373|      0|    BSKIP(ply, 3);
  374|      0|    return 1;
  375|      0|}
  376|       |
  377|       |/* ----------------------------------------------------------------------
  378|       | * Input  handlers
  379|       | * ---------------------------------------------------------------------- */
  380|      0|static int iascii_int8(p_ply ply, double *value) {
  381|      0|    char *end;
  382|      0|    if (!ply_read_word(ply)) return 0;
  383|      0|    *value = strtol(BWORD(ply), &end, 10);
  384|      0|    if (*end || *value > PLY_INT8_MAX || *value < PLY_INT8_MIN) return 0;
  385|      0|    return 1;
  386|      0|}
  387|       |
  388|      0|static int iascii_uint8(p_ply ply, double *value) {
  389|      0|    char *end;
  390|      0|    if (!ply_read_word(ply)) return 0;
  391|      0|    *value = strtol(BWORD(ply), &end, 10);
  392|      0|    if (*end || *value > PLY_UINT8_MAX || *value < 0) return 0;
  393|      0|    return 1;
  394|      0|}
  395|       |
  396|      0|static int iascii_int16(p_ply ply, double *value) {
  397|      0|    char *end;
  398|      0|    if (!ply_read_word(ply)) return 0;
  399|      0|    *value = strtol(BWORD(ply), &end, 10);
  400|      0|    if (*end || *value > PLY_INT16_MAX || *value < PLY_INT16_MIN) return 0;
  401|      0|    return 1;
  402|      0|}
  403|       |
  404|      0|static int iascii_uint16(p_ply ply, double *value) {
  405|      0|    char *end;
  406|      0|    if (!ply_read_word(ply)) return 0;
  407|      0|    *value = strtol(BWORD(ply), &end, 10);
  408|      0|    if (*end || *value > PLY_UINT16_MAX || *value < 0) return 0;
  409|      0|    return 1;
  410|      0|}
  411|       |
  412|      0|static int iascii_int32(p_ply ply, double *value) {
  413|      0|    char *end;
  414|      0|    if (!ply_read_word(ply)) return 0;
  415|      0|    *value = strtol(BWORD(ply), &end, 10);
  416|      0|    if (*end || *value > PLY_INT32_MAX || *value < PLY_INT32_MIN) return 0;
  417|      0|    return 1;
  418|      0|}
  419|       |
  420|      0|static int iascii_uint32(p_ply ply, double *value) {
  421|      0|    char *end;
  422|      0|    if (!ply_read_word(ply)) return 0;
  423|      0|    *value = strtol(BWORD(ply), &end, 10);
  424|      0|    if (*end || *value > PLY_UINT32_MAX || *value < 0) return 0;
  425|      0|    return 1;
  426|      0|}
  427|       |
  428|      0|static int iascii_float32(p_ply ply, double *value) {
  429|      0|    char *end;
  430|      0|    if (!ply_read_word(ply)) return 0;
  431|      0|    *value = strtod(BWORD(ply), &end);
  432|      0|    if (*end || *value < -FLT_MAX || *value > FLT_MAX) return 0;
  433|      0|    return 1;
  434|      0|}
  435|       |
  436|      0|static int iascii_float64(p_ply ply, double *value) {
  437|      0|    char *end;
  438|      0|    if (!ply_read_word(ply)) return 0;
  439|      0|    *value = strtod(BWORD(ply), &end);
  440|      0|    if (*end || *value < -DBL_MAX || *value > DBL_MAX) return 0;
  441|      0|    return 1;
  442|      0|}
  443|       |
  444|      0|static int ibinary_int8(p_ply ply, double *value) {
  445|      0|    t_ply_int8 int8;
  446|      0|    if (!ply->idriver->ichunk(ply, &int8, 1)) return 0;
  447|      0|    *value = int8;
  448|      0|    return 1;
  449|      0|}
  450|       |
  451|      0|static int ibinary_uint8(p_ply ply, double *value) {
  452|      0|    t_ply_uint8 uint8;
  453|      0|    if (!ply->idriver->ichunk(ply, &uint8, 1)) return 0;
  454|      0|    *value = uint8;
  455|      0|    return 1;
  456|      0|}
  457|       |
  458|      0|static int ibinary_int16(p_ply ply, double *value) {
  459|      0|    t_ply_int16 int16;
  460|      0|    if (!ply->idriver->ichunk(ply, &int16, sizeof(int16))) return 0;
  461|      0|    *value = int16;
  462|      0|    return 1;
  463|      0|}
  464|       |
  465|      0|static int ibinary_uint16(p_ply ply, double *value) {
  466|      0|    t_ply_uint16 uint16;
  467|      0|    if (!ply->idriver->ichunk(ply, &uint16, sizeof(uint16))) return 0;
  468|      0|    *value = uint16;
  469|      0|    return 1;
  470|      0|}
  471|       |
  472|      0|static int ibinary_int32(p_ply ply, double *value) {
  473|      0|    t_ply_int32 int32;
  474|      0|    if (!ply->idriver->ichunk(ply, &int32, sizeof(int32))) return 0;
  475|      0|    *value = int32;
  476|      0|    return 1;
  477|      0|}
  478|       |
  479|      0|static int ibinary_uint32(p_ply ply, double *value) {
  480|      0|    t_ply_uint32 uint32;
  481|      0|    if (!ply->idriver->ichunk(ply, &uint32, sizeof(uint32))) return 0;
  482|      0|    *value = uint32;
  483|      0|    return 1;
  484|      0|}
  485|       |
  486|      0|static int ibinary_float32(p_ply ply, double *value) {
  487|      0|    float float32;
  488|      0|    if (!ply->idriver->ichunk(ply, &float32, sizeof(float32))) return 0;
  489|      0|    *value = float32;
  490|      0|    return 1;
  491|      0|}
  492|       |
  493|      0|static int ibinary_float64(p_ply ply, double *value) {
  494|      0|    return ply->idriver->ichunk(ply, value, sizeof(double));
  495|      0|}
  496|       |
  497|       |/* ----------------------------------------------------------------------
  498|       | * I/O functions and drivers
  499|       | * ---------------------------------------------------------------------- */
  500|       |/*
  501|       |static t_ply_idriver ply_idriver_ascii;
  502|       |static t_ply_idriver ply_idriver_binary;
  503|       |static t_ply_idriver ply_idriver_binary_reverse;
  504|       |static t_ply_odriver ply_odriver_ascii;
  505|       |static t_ply_odriver ply_odriver_binary;
  506|       |static t_ply_odriver ply_odriver_binary_reverse;
  507|       |*/
  508|       |
  509|       |/* ----------------------------------------------------------------------
  510|       | * Constants
  511|       | * ---------------------------------------------------------------------- */
  512|       |static t_ply_idriver ply_idriver_ascii = {
  513|       |    {   iascii_int8, iascii_uint8, iascii_int16, iascii_uint16,
  514|       |        iascii_int32, iascii_uint32, iascii_float32, iascii_float64,
  515|       |        iascii_int8, iascii_uint8, iascii_int16, iascii_uint16,
  516|       |        iascii_int32, iascii_uint32, iascii_float32, iascii_float64
  517|       |    }, /* order matches e_ply_type enum */
  518|       |    NULL,
  519|       |    "ascii input"
  520|       |};
  521|       |
  522|       |static t_ply_idriver ply_idriver_binary = {
  523|       |    {   ibinary_int8, ibinary_uint8, ibinary_int16, ibinary_uint16,
  524|       |        ibinary_int32, ibinary_uint32, ibinary_float32, ibinary_float64,
  525|       |        ibinary_int8, ibinary_uint8, ibinary_int16, ibinary_uint16,
  526|       |        ibinary_int32, ibinary_uint32, ibinary_float32, ibinary_float64
  527|       |    }, /* order matches e_ply_type enum */
  528|       |    ply_read_chunk,
  529|       |    "binary input"
  530|       |};
  531|       |
  532|       |static t_ply_idriver ply_idriver_binary_reverse = {
  533|       |    {   ibinary_int8, ibinary_uint8, ibinary_int16, ibinary_uint16,
  534|       |        ibinary_int32, ibinary_uint32, ibinary_float32, ibinary_float64,
  535|       |        ibinary_int8, ibinary_uint8, ibinary_int16, ibinary_uint16,
  536|       |        ibinary_int32, ibinary_uint32, ibinary_float32, ibinary_float64
  537|       |    }, /* order matches e_ply_type enum */
  538|       |    ply_read_chunk_reverse,
  539|       |    "reverse binary input"
  540|       |};
  541|       |
  542|       |static t_ply_odriver ply_odriver_ascii = {
  543|       |    {   oascii_int8, oascii_uint8, oascii_int16, oascii_uint16,
  544|       |        oascii_int32, oascii_uint32, oascii_float32, oascii_float64,
  545|       |        oascii_int8, oascii_uint8, oascii_int16, oascii_uint16,
  546|       |        oascii_int32, oascii_uint32, oascii_float32, oascii_float64
  547|       |    }, /* order matches e_ply_type enum */
  548|       |    NULL,
  549|       |    "ascii output"
  550|       |};
  551|       |
  552|       |static t_ply_odriver ply_odriver_binary = {
  553|       |    {   obinary_int8, obinary_uint8, obinary_int16, obinary_uint16,
  554|       |        obinary_int32, obinary_uint32, obinary_float32, obinary_float64,
  555|       |        obinary_int8, obinary_uint8, obinary_int16, obinary_uint16,
  556|       |        obinary_int32, obinary_uint32, obinary_float32, obinary_float64
  557|       |    }, /* order matches e_ply_type enum */
  558|       |    ply_write_chunk,
  559|       |    "binary output"
  560|       |};
  561|       |
  562|       |static t_ply_odriver ply_odriver_binary_reverse = {
  563|       |    {   obinary_int8, obinary_uint8, obinary_int16, obinary_uint16,
  564|       |        obinary_int32, obinary_uint32, obinary_float32, obinary_float64,
  565|       |        obinary_int8, obinary_uint8, obinary_int16, obinary_uint16,
  566|       |        obinary_int32, obinary_uint32, obinary_float32, obinary_float64
  567|       |    }, /* order matches e_ply_type enum */
  568|       |    ply_write_chunk_reverse,
  569|       |    "reverse binary output"
  570|       |};
  571|       |
  572|       |
  573|       |/* ----------------------------------------------------------------------
  574|       | * String functions
  575|       | * ---------------------------------------------------------------------- */
  576|       |static int ply_find_string(const char *item, const char* const list[]);
  577|       |static p_ply_element ply_find_element(p_ply ply, const char *name);
  578|       |static p_ply_property ply_find_property(p_ply_element element, 
  579|       |        const char *name);
  580|       |
  581|       |/* ----------------------------------------------------------------------
  582|       | * Header parsing
  583|       | * ---------------------------------------------------------------------- */
  584|       |static int ply_read_header_magic(p_ply ply); 
  585|       |static int ply_read_header_format(p_ply ply);
  586|       |static int ply_read_header_comment(p_ply ply);
  587|       |static int ply_read_header_obj_info(p_ply ply);
  588|       |static int ply_read_header_property(p_ply ply);
  589|       |static int ply_read_header_element(p_ply ply);
  590|       |
  591|       |/* ----------------------------------------------------------------------
  592|       | * Error handling
  593|       | * ---------------------------------------------------------------------- */
  594|       |static void ply_error_cb(p_ply ply, const char *message);
  595|       |static void ply_ferror(p_ply ply, const char *fmt, ...);
  596|       |
  597|       |/* ----------------------------------------------------------------------
  598|       | * Memory allocation and initialization
  599|       | * ---------------------------------------------------------------------- */
  600|       |static void ply_init(p_ply ply);
  601|       |static void ply_element_init(p_ply_element element);
  602|       |static void ply_property_init(p_ply_property property);
  603|       |static p_ply ply_alloc(void);
  604|       |static p_ply_element ply_grow_element(p_ply ply);
  605|       |static p_ply_property ply_grow_property(p_ply ply, p_ply_element element);
  606|       |static void *ply_grow_array(p_ply ply, void **pointer, long *nmemb, long size);
  607|       |
  608|       |/* ----------------------------------------------------------------------
  609|       | * Special functions
  610|       | * ---------------------------------------------------------------------- */
  611|       |static e_ply_storage_mode ply_arch_endian(void);
  612|       |static int ply_type_check(void); 
  613|       |
  614|       |/* ----------------------------------------------------------------------
  615|       | * Auxiliary read functions
  616|       | * ---------------------------------------------------------------------- */
  617|       |static int ply_read_element(p_ply ply, p_ply_element element, 
  618|       |        p_ply_argument argument);
  619|       |static int ply_read_property(p_ply ply, p_ply_element element, 
  620|       |        p_ply_property property, p_ply_argument argument);
  621|       |static int ply_read_list_property(p_ply ply, p_ply_element element, 
  622|       |        p_ply_property property, p_ply_argument argument);
  623|       |static int ply_read_scalar_property(p_ply ply, p_ply_element element, 
  624|       |        p_ply_property property, p_ply_argument argument);
  625|       |
  626|       |/* ----------------------------------------------------------------------
  627|       | * Exported functions
  628|       | * ---------------------------------------------------------------------- */
  629|       |/* ----------------------------------------------------------------------
  630|       | * Read support functions
  631|       | * ---------------------------------------------------------------------- */
  632|       |p_ply ply_open(const char *name, p_ply_error_cb error_cb, 
  633|      0|        long idata, void *pdata) {
  634|      0|    FILE *fp = NULL; 
  635|      0|    p_ply ply = ply_alloc();
  636|      0|    if (error_cb == NULL) error_cb = ply_error_cb;
  637|      0|    if (!ply) {
  638|      0|        error_cb(NULL, "Out of memory");
  639|      0|        return NULL;
  640|      0|    }
  641|      0|    ply->idata = idata;
  642|      0|    ply->pdata = pdata;
  643|      0|    ply->io_mode = PLY_READ;
  644|      0|    ply->error_cb = error_cb;
  645|      0|    if (!ply_type_check()) {
  646|      0|        error_cb(ply, "Incompatible type system");
  647|      0|        free(ply);
  648|      0|        return NULL;
  649|      0|    }
  650|      0|    assert(name);
  651|      0|    fp = fopen(name, "rb");
  652|      0|    if (!fp) {
  653|      0|        error_cb(ply, "Unable to open file");
  654|      0|        free(ply);
  655|      0|        return NULL;
  656|      0|    }
  657|      0|    ply->fp = fp;
  658|      0|    return ply;
  659|      0|}
  660|       |
  661|      0|int ply_read_header(p_ply ply) {
  662|      0|    assert(ply && ply->fp && ply->io_mode == PLY_READ);
  663|      0|    if (!ply_read_header_magic(ply)) return 0;
  664|      0|    if (!ply_read_word(ply)) return 0;
  665|       |    /* parse file format */
  666|      0|    if (!ply_read_header_format(ply)) {
  667|      0|        ply_ferror(ply, "Invalid file format");
  668|      0|        return 0;
  669|      0|    }
  670|       |    /* parse elements, comments or obj_infos until the end of header */
  671|      0|    while (strcmp(BWORD(ply), "end_header")) {
  672|      0|        if (!ply_read_header_comment(ply) && 
  673|      0|                !ply_read_header_element(ply) && 
  674|      0|                !ply_read_header_obj_info(ply)) {
  675|      0|            ply_ferror(ply, "Unexpected token '%s'", BWORD(ply));
  676|      0|            return 0;
  677|      0|        }
  678|      0|    }
  679|       |    /* skip extra character? */
  680|      0|    if (ply->rn) {
  681|      0|        if (BSIZE(ply) < 1 && !BREFILL(ply)) {
  682|      0|            ply_ferror(ply, "Unexpected end of file");
  683|      0|            return 0;
  684|      0|        }
  685|      0|        BSKIP(ply, 1);
  686|      0|    }
  687|      0|    return 1;
  688|      0|}
  689|       |
  690|       |long ply_set_read_cb(p_ply ply, const char *element_name, 
  691|       |        const char* property_name, p_ply_read_cb read_cb, 
  692|      0|        void *pdata, long idata) {
  693|      0|    p_ply_element element = NULL; 
  694|      0|    p_ply_property property = NULL;
  695|      0|    assert(ply && element_name && property_name);
  696|      0|    element = ply_find_element(ply, element_name);
  697|      0|    if (!element) return 0;
  698|      0|    property = ply_find_property(element, property_name);
  699|      0|    if (!property) return 0;
  700|      0|    property->read_cb = read_cb;
  701|      0|    property->pdata = pdata;
  702|      0|    property->idata = idata;
  703|      0|    return (int) element->ninstances;
  704|      0|}
  705|       |
  706|      0|int ply_read(p_ply ply) {
  707|      0|    long i;
  708|      0|    p_ply_argument argument;
  709|      0|    assert(ply && ply->fp && ply->io_mode == PLY_READ);
  710|      0|    argument = &ply->argument;
  711|       |    /* for each element type */
  712|      0|    for (i = 0; i < ply->nelements; i++) {
  713|      0|        p_ply_element element = &ply->element[i];
  714|      0|        argument->element = element;
  715|      0|        if (!ply_read_element(ply, element, argument))
  716|      0|            return 0;
  717|      0|    }
  718|      0|    return 1;
  719|      0|}
  720|       |
  721|       |/* ----------------------------------------------------------------------
  722|       | * Write support functions
  723|       | * ---------------------------------------------------------------------- */
  724|       |p_ply ply_create(const char *name, e_ply_storage_mode storage_mode, 
  725|      0|        p_ply_error_cb error_cb, long idata, void *pdata) {
  726|      0|    FILE *fp = NULL;
  727|      0|    p_ply ply = ply_alloc();
  728|      0|    if (error_cb == NULL) error_cb = ply_error_cb;
  729|      0|    if (!ply) {
  730|      0|        error_cb(NULL, "Out of memory");
  731|      0|        return NULL;
  732|      0|    }
  733|      0|    if (!ply_type_check()) {
  734|      0|        error_cb(ply, "Incompatible type system");
  735|      0|        free(ply);
  736|      0|        return NULL;
  737|      0|    }
  738|      0|    assert(name && storage_mode <= PLY_DEFAULT);
  739|      0|    fp = fopen(name, "wb");
  740|      0|    if (!fp) {
  741|      0|        error_cb(ply, "Unable to create file");
  742|      0|        free(ply);
  743|      0|        return NULL;
  744|      0|    }
  745|      0|    ply->idata = idata;
  746|      0|    ply->pdata = pdata;
  747|      0|    ply->io_mode = PLY_WRITE;
  748|      0|    if (storage_mode == PLY_DEFAULT) storage_mode = ply_arch_endian();
  749|      0|    if (storage_mode == PLY_ASCII) ply->odriver = &ply_odriver_ascii;
  750|      0|    else if (storage_mode == ply_arch_endian()) 
  751|      0|        ply->odriver = &ply_odriver_binary;
  752|      0|    else ply->odriver = &ply_odriver_binary_reverse;
  753|      0|    ply->storage_mode = storage_mode;
  754|      0|    ply->fp = fp;
  755|      0|    ply->error_cb = error_cb;
  756|      0|    return ply;
  757|      0|}
  758|       |
  759|      0|int ply_add_element(p_ply ply, const char *name, long ninstances) {
  760|      0|    p_ply_element element = NULL;
  761|      0|    assert(ply && ply->fp && ply->io_mode == PLY_WRITE);
  762|      0|    assert(name && strlen(name) < WORDSIZE && ninstances >= 0);
  763|      0|    if (strlen(name) >= WORDSIZE || ninstances < 0) {
  764|      0|        ply_ferror(ply, "Invalid arguments");
  765|      0|        return 0;
  766|      0|    }
  767|      0|    element = ply_grow_element(ply);
  768|      0|    if (!element) return 0;
  769|      0|    strcpy(element->name, name);
  770|      0|    element->ninstances = ninstances;
  771|      0|    return 1;
  772|      0|}
  773|       |
  774|      0|int ply_add_scalar_property(p_ply ply, const char *name, e_ply_type type) {
  775|      0|    p_ply_element element = NULL;
  776|      0|    p_ply_property property = NULL;
  777|      0|    assert(ply && ply->fp && ply->io_mode == PLY_WRITE);
  778|      0|    assert(name && strlen(name) < WORDSIZE);
  779|      0|    assert(type < PLY_LIST);
  780|      0|    if (strlen(name) >= WORDSIZE || type >= PLY_LIST) {
  781|      0|        ply_ferror(ply, "Invalid arguments");
  782|      0|        return 0;
  783|      0|    }
  784|      0|    element = &ply->element[ply->nelements-1];
  785|      0|    property = ply_grow_property(ply, element);
  786|      0|    if (!property) return 0;
  787|      0|    strcpy(property->name, name);
  788|      0|    property->type = type;
  789|      0|    return 1;
  790|      0|}
  791|       |
  792|       |int ply_add_list_property(p_ply ply, const char *name, 
  793|      0|        e_ply_type length_type, e_ply_type value_type) {
  794|      0|    p_ply_element element = NULL;
  795|      0|    p_ply_property property = NULL;
  796|      0|    assert(ply && ply->fp && ply->io_mode == PLY_WRITE);
  797|      0|    assert(name && strlen(name) < WORDSIZE);
  798|      0|    if (strlen(name) >= WORDSIZE) {
  799|      0|        ply_ferror(ply, "Invalid arguments");
  800|      0|        return 0;
  801|      0|    }
  802|      0|    assert(length_type < PLY_LIST);
  803|      0|    assert(value_type < PLY_LIST);
  804|      0|    if (length_type >= PLY_LIST || value_type >= PLY_LIST) {
  805|      0|        ply_ferror(ply, "Invalid arguments");
  806|      0|        return 0;
  807|      0|    }
  808|      0|    element = &ply->element[ply->nelements-1];
  809|      0|    property = ply_grow_property(ply, element);
  810|      0|    if (!property) return 0;
  811|      0|    strcpy(property->name, name);
  812|      0|    property->type = PLY_LIST;
  813|      0|    property->length_type = length_type;
  814|      0|    property->value_type = value_type;
  815|      0|    return 1;
  816|      0|}
  817|       |
  818|       |int ply_add_property(p_ply ply, const char *name, e_ply_type type,
  819|      0|        e_ply_type length_type, e_ply_type value_type) {
  820|      0|    if (type == PLY_LIST) 
  821|      0|        return ply_add_list_property(ply, name, length_type, value_type);
  822|      0|    else 
  823|      0|        return ply_add_scalar_property(ply, name, type);
  824|      0|}
  825|       |
  826|      0|int ply_add_comment(p_ply ply, const char *comment) {
  827|      0|    char *new_comment = NULL;
  828|      0|    assert(ply && comment && strlen(comment) < LINESIZE);
  829|      0|    if (!comment || strlen(comment) >= LINESIZE) {
  830|      0|        ply_ferror(ply, "Invalid arguments");
  831|      0|        return 0;
  832|      0|    }
  833|      0|    new_comment = (char *) ply_grow_array(ply, (void **) &ply->comment,
  834|      0|            &ply->ncomments, LINESIZE);
  835|      0|    if (!new_comment) return 0;
  836|      0|    strcpy(new_comment, comment);
  837|      0|    return 1;
  838|      0|}
  839|       |
  840|      0|int ply_add_obj_info(p_ply ply, const char *obj_info) {
  841|      0|    char *new_obj_info = NULL;
  842|      0|    assert(ply && obj_info && strlen(obj_info) < LINESIZE);
  843|      0|    if (!obj_info || strlen(obj_info) >= LINESIZE) {
  844|      0|        ply_ferror(ply, "Invalid arguments");
  845|      0|        return 0;
  846|      0|    }
  847|      0|    new_obj_info = (char *) ply_grow_array(ply, (void **) &ply->obj_info,
  848|      0|            &ply->nobj_infos, LINESIZE);
  849|      0|    if (!new_obj_info) return 0;
  850|      0|    strcpy(new_obj_info, obj_info);
  851|      0|    return 1;
  852|      0|}
  853|       |
  854|      0|int ply_write_header(p_ply ply) {
  855|      0|    long i, j;
  856|      0|    assert(ply && ply->fp && ply->io_mode == PLY_WRITE);
  857|      0|    assert(ply->element || ply->nelements == 0); 
  858|      0|    assert(!ply->element || ply->nelements > 0); 
  859|      0|    if (fprintf(ply->fp, "ply\nformat %s 1.0\n", 
  860|      0|                ply_storage_mode_list[ply->storage_mode]) <= 0) goto error;
  861|      0|    for (i = 0; i < ply->ncomments; i++)
  862|      0|        if (fprintf(ply->fp, "comment %s\n", ply->comment + LINESIZE*i) <= 0)
  863|      0|            goto error;
  864|      0|    for (i = 0; i < ply->nobj_infos; i++)
  865|      0|        if (fprintf(ply->fp, "obj_info %s\n", ply->obj_info + LINESIZE*i) <= 0)
  866|      0|            goto error;
  867|      0|    for (i = 0; i < ply->nelements; i++) {
  868|      0|        p_ply_element element = &ply->element[i];
  869|      0|        assert(element->property || element->nproperties == 0); 
  870|      0|        assert(!element->property || element->nproperties > 0); 
  871|      0|        if (fprintf(ply->fp, "element %s %ld\n", element->name, 
  872|      0|                    element->ninstances) <= 0) goto error;
  873|      0|        for (j = 0; j < element->nproperties; j++) {
  874|      0|            p_ply_property property = &element->property[j];
  875|      0|            if (property->type == PLY_LIST) {
  876|      0|                if (fprintf(ply->fp, "property list %s %s %s\n", 
  877|      0|                            ply_type_list[property->length_type],
  878|      0|                            ply_type_list[property->value_type],
  879|      0|                            property->name) <= 0) goto error;
  880|      0|            } else {
  881|      0|                if (fprintf(ply->fp, "property %s %s\n", 
  882|      0|                            ply_type_list[property->type],
  883|      0|                            property->name) <= 0) goto error;
  884|      0|            }
  885|      0|        }
  886|      0|    }
  887|      0|    return fprintf(ply->fp, "end_header\n") > 0;
  888|      0|error:
  889|      0|    ply_ferror(ply, "Error writing to file");
  890|      0|    return 0;
  891|      0|}
  892|       |
  893|      0|int ply_write(p_ply ply, double value) {
  894|      0|    p_ply_element element = NULL;
  895|      0|    p_ply_property property = NULL;
  896|      0|    int type = -1;
  897|      0|    int breakafter = 0;
  898|      0|    if (ply->welement > ply->nelements) return 0;
  899|      0|    element = &ply->element[ply->welement];
  900|      0|    if (ply->wproperty > element->nproperties) return 0;
  901|      0|    property = &element->property[ply->wproperty];
  902|      0|    if (property->type == PLY_LIST) {
  903|      0|        if (ply->wvalue_index == 0) {
  904|      0|            type = property->length_type;
  905|      0|            ply->wlength = (long) value;
  906|      0|        } else type = property->value_type;
  907|      0|    } else {
  908|      0|        type = property->type;
  909|      0|        ply->wlength = 0;
  910|      0|    }
  911|      0|    if (!ply->odriver->ohandler[type](ply, value)) {
  912|      0|        ply_ferror(ply, "Failed writing %s of %s %d (%s: %s)", 
  913|      0|                    property->name, element->name, 
  914|      0|                    ply->winstance_index, 
  915|      0|                    ply->odriver->name, ply_type_list[type]);
  916|      0|        return 0;
  917|      0|    }
  918|      0|    ply->wvalue_index++;
  919|      0|    if (ply->wvalue_index > ply->wlength) {
  920|      0|        ply->wvalue_index = 0;
  921|      0|        ply->wproperty++;
  922|      0|    }
  923|      0|    if (ply->wproperty >= element->nproperties) {
  924|      0|        ply->wproperty = 0;
  925|      0|        ply->winstance_index++;
  926|      0|        if (ply->storage_mode == PLY_ASCII) breakafter = 1;
  927|      0|    }
  928|      0|    if (ply->winstance_index >= element->ninstances) {
  929|      0|        ply->winstance_index = 0;
  930|      0|        ply->welement++;
  931|      0|    }
  932|      0|    return !breakafter || putc('\n', ply->fp) > 0;
  933|      0|}
  934|       |
  935|      0|int ply_close(p_ply ply) {
  936|      0|    long i;
  937|      0|    assert(ply && ply->fp);
  938|      0|    assert(ply->element || ply->nelements == 0);
  939|      0|    assert(!ply->element || ply->nelements > 0);
  940|       |    /* write last chunk to file */
  941|      0|    if (ply->io_mode == PLY_WRITE && 
  942|      0|      fwrite(ply->buffer, 1, ply->buffer_last, ply->fp) < ply->buffer_last) {
  943|      0|        ply_ferror(ply, "Error closing up");
  944|      0|        return 0;
  945|      0|    }
  946|      0|    fclose(ply->fp);
  947|       |    /* free all memory used by handle */
  948|      0|    if (ply->element) {
  949|      0|        for (i = 0; i < ply->nelements; i++) {
  950|      0|            p_ply_element element = &ply->element[i];
  951|      0|            if (element->property) free(element->property);
  952|      0|        }
  953|      0|        free(ply->element);
  954|      0|    }
  955|      0|    if (ply->obj_info) free(ply->obj_info);
  956|      0|    if (ply->comment) free(ply->comment);
  957|      0|    free(ply);
  958|      0|    return 1;
  959|      0|}
  960|       |
  961|       |/* ----------------------------------------------------------------------
  962|       | * Query support functions
  963|       | * ---------------------------------------------------------------------- */
  964|       |p_ply_element ply_get_next_element(p_ply ply, 
  965|      0|        p_ply_element last) {
  966|      0|    assert(ply);
  967|      0|    if (!last) return ply->element;
  968|      0|    last++;
  969|      0|    if (last < ply->element + ply->nelements) return last;
  970|      0|    else return NULL;
  971|      0|}
  972|       |
  973|       |int ply_get_element_info(p_ply_element element, const char** name,
  974|      0|        long *ninstances) {
  975|      0|    assert(element);
  976|      0|    if (name) *name = element->name;
  977|      0|    if (ninstances) *ninstances = (long) element->ninstances;
  978|      0|    return 1;
  979|      0|}
  980|       |
  981|       |p_ply_property ply_get_next_property(p_ply_element element, 
  982|      0|        p_ply_property last) {
  983|      0|    assert(element);
  984|      0|    if (!last) return element->property;
  985|      0|    last++;
  986|      0|    if (last < element->property + element->nproperties) return last;
  987|      0|    else return NULL;
  988|      0|}
  989|       |
  990|       |int ply_get_property_info(p_ply_property property, const char** name,
  991|      0|        e_ply_type *type, e_ply_type *length_type, e_ply_type *value_type) {
  992|      0|    assert(property);
  993|      0|    if (name) *name = property->name;
  994|      0|    if (type) *type = property->type;
  995|      0|    if (length_type) *length_type = property->length_type;
  996|      0|    if (value_type) *value_type = property->value_type;
  997|      0|    return 1;
  998|       |
  999|      0|}
 1000|       |
 1001|      0|const char *ply_get_next_comment(p_ply ply, const char *last) {
 1002|      0|    assert(ply);
 1003|      0|    if (!last) return ply->comment; 
 1004|      0|    last += LINESIZE;
 1005|      0|    if (last < ply->comment + LINESIZE*ply->ncomments) return last;
 1006|      0|    else return NULL;
 1007|      0|}
 1008|       |
 1009|      0|const char *ply_get_next_obj_info(p_ply ply, const char *last) {
 1010|      0|    assert(ply);
 1011|      0|    if (!last) return ply->obj_info; 
 1012|      0|    last += LINESIZE;
 1013|      0|    if (last < ply->obj_info + LINESIZE*ply->nobj_infos) return last;
 1014|      0|    else return NULL;
 1015|      0|}
 1016|       |
 1017|       |/* ----------------------------------------------------------------------
 1018|       | * Callback argument support functions 
 1019|       | * ---------------------------------------------------------------------- */
 1020|       |int ply_get_argument_element(p_ply_argument argument, 
 1021|      0|        p_ply_element *element, long *instance_index) {
 1022|      0|    assert(argument);
 1023|      0|    if (!argument) return 0;
 1024|      0|    if (element) *element = argument->element;
 1025|      0|    if (instance_index) *instance_index = argument->instance_index;
 1026|      0|    return 1;
 1027|      0|}
 1028|       |
 1029|       |int ply_get_argument_property(p_ply_argument argument, 
 1030|      0|        p_ply_property *property, long *length, long *value_index) {
 1031|      0|    assert(argument);
 1032|      0|    if (!argument) return 0;
 1033|      0|    if (property) *property = argument->property;
 1034|      0|    if (length) *length = argument->length;
 1035|      0|    if (value_index) *value_index = argument->value_index;
 1036|      0|    return 1;
 1037|      0|}
 1038|       |
 1039|       |int ply_get_argument_user_data(p_ply_argument argument, void **pdata, 
 1040|      0|        long *idata) {
 1041|      0|    assert(argument);
 1042|      0|    if (!argument) return 0;
 1043|      0|    if (pdata) *pdata = argument->pdata;
 1044|      0|    if (idata) *idata = argument->idata;
 1045|      0|    return 1;
 1046|      0|}
 1047|       |
 1048|      0|double ply_get_argument_value(p_ply_argument argument) {
 1049|      0|    assert(argument);
 1050|      0|    if (!argument) return 0.0;
 1051|      0|    return argument->value;
 1052|      0|}
 1053|       |
 1054|      0|int ply_get_ply_user_data(p_ply ply, void **pdata, long *idata) {
 1055|      0|    assert(ply);
 1056|      0|    if (!ply) return 0;
 1057|      0|    if (pdata) *pdata = ply->pdata;
 1058|      0|    if (idata) *idata = ply->idata;
 1059|      0|    return 1;
 1060|      0|}
 1061|       |
 1062|       |/* ----------------------------------------------------------------------
 1063|       | * Internal functions
 1064|       | * ---------------------------------------------------------------------- */
 1065|       |static int ply_read_list_property(p_ply ply, p_ply_element element, 
 1066|      0|        p_ply_property property, p_ply_argument argument) {
 1067|      0|    int l;
 1068|      0|    p_ply_read_cb read_cb = property->read_cb;
 1069|      0|    p_ply_ihandler *driver = ply->idriver->ihandler; 
 1070|       |    /* get list length */
 1071|      0|    p_ply_ihandler handler = driver[property->length_type];
 1072|      0|    double length;
 1073|      0|    if (!handler(ply, &length)) {
 1074|      0|        ply_ferror(ply, "Error reading '%s' of '%s' number %d",
 1075|      0|                property->name, element->name, argument->instance_index);
 1076|      0|        return 0;
 1077|      0|    }
 1078|       |    /* invoke callback to pass length in value field */
 1079|      0|    argument->length = (long) length;
 1080|      0|    argument->value_index = -1;
 1081|      0|    argument->value = length;
 1082|      0|    if (read_cb && !read_cb(argument)) {
 1083|      0|        ply_ferror(ply, "Aborted by user");
 1084|      0|        return 0;
 1085|      0|    }
 1086|       |    /* read list values */
 1087|      0|    handler = driver[property->value_type];
 1088|       |    /* for each value in list */
 1089|      0|    for (l = 0; l < (long) length; l++) {
 1090|       |        /* read value from file */
 1091|      0|        argument->value_index = l;
 1092|      0|        if (!handler(ply, &argument->value)) {
 1093|      0|            ply_ferror(ply, "Error reading value number %d of '%s' of "
 1094|      0|                    "'%s' number %d", l+1, property->name, 
 1095|      0|                    element->name, argument->instance_index);
 1096|      0|            return 0;
 1097|      0|        }
 1098|       |        /* invoke callback to pass value */
 1099|      0|        if (read_cb && !read_cb(argument)) {
 1100|      0|            ply_ferror(ply, "Aborted by user");
 1101|      0|            return 0;
 1102|      0|        }
 1103|      0|    }
 1104|      0|    return 1;
 1105|      0|}
 1106|       |
 1107|       |static int ply_read_scalar_property(p_ply ply, p_ply_element element, 
 1108|      0|        p_ply_property property, p_ply_argument argument) {
 1109|      0|    p_ply_read_cb read_cb = property->read_cb;
 1110|      0|    p_ply_ihandler *driver = ply->idriver->ihandler; 
 1111|      0|    p_ply_ihandler handler = driver[property->type];
 1112|      0|    argument->length = 1;
 1113|      0|    argument->value_index = 0;
 1114|      0|    if (!handler(ply, &argument->value)) {
 1115|      0|        ply_ferror(ply, "Error reading '%s' of '%s' number %d",
 1116|      0|                property->name, element->name, argument->instance_index);
 1117|      0|        return 0;
 1118|      0|    }
 1119|      0|    if (read_cb && !read_cb(argument)) {
 1120|      0|        ply_ferror(ply, "Aborted by user");
 1121|      0|        return 0;
 1122|      0|    }
 1123|      0|    return 1;
 1124|      0|}
 1125|       |
 1126|       |static int ply_read_property(p_ply ply, p_ply_element element, 
 1127|      0|        p_ply_property property, p_ply_argument argument) {
 1128|      0|    if (property->type == PLY_LIST) 
 1129|      0|        return ply_read_list_property(ply, element, property, argument);
 1130|      0|    else 
 1131|      0|        return ply_read_scalar_property(ply, element, property, argument);
 1132|      0|}
 1133|       |
 1134|       |static int ply_read_element(p_ply ply, p_ply_element element, 
 1135|      0|        p_ply_argument argument) {
 1136|      0|    long j, k;
 1137|       |    /* for each element of this type */
 1138|      0|    for (j = 0; j < element->ninstances; j++) {
 1139|      0|        argument->instance_index = j;
 1140|       |        /* for each property */
 1141|      0|        for (k = 0; k < element->nproperties; k++) {
 1142|      0|            p_ply_property property = &element->property[k];
 1143|      0|            argument->property = property;
 1144|      0|            argument->pdata = property->pdata;
 1145|      0|            argument->idata = property->idata;
 1146|      0|            if (!ply_read_property(ply, element, property, argument))
 1147|      0|                return 0;
 1148|      0|        }
 1149|      0|    }
 1150|      0|    return 1;
 1151|      0|}
 1152|       |
 1153|      0|static int ply_find_string(const char *item, const char* const list[]) {
 1154|      0|    int i;
 1155|      0|    assert(item && list);
 1156|      0|    for (i = 0; list[i]; i++) 
 1157|      0|        if (!strcmp(list[i], item)) return i;
 1158|      0|    return -1;
 1159|      0|}
 1160|       |
 1161|      0|static p_ply_element ply_find_element(p_ply ply, const char *name) {
 1162|      0|    p_ply_element element;
 1163|      0|    int i, nelements;
 1164|      0|    assert(ply && name); 
 1165|      0|    element = ply->element;
 1166|      0|    nelements = ply->nelements;
 1167|      0|    assert(element || nelements == 0); 
 1168|      0|    assert(!element || nelements > 0); 
 1169|      0|    for (i = 0; i < nelements; i++) 
 1170|      0|        if (!strcmp(element[i].name, name)) return &element[i];
 1171|      0|    return NULL;
 1172|      0|}
 1173|       |
 1174|       |static p_ply_property ply_find_property(p_ply_element element, 
 1175|      0|        const char *name) {
 1176|      0|    p_ply_property property;
 1177|      0|    int i, nproperties;
 1178|      0|    assert(element && name); 
 1179|      0|    property = element->property;
 1180|      0|    nproperties = element->nproperties;
 1181|      0|    assert(property || nproperties == 0); 
 1182|      0|    assert(!property || nproperties > 0); 
 1183|      0|    for (i = 0; i < nproperties; i++) 
 1184|      0|        if (!strcmp(property[i].name, name)) return &property[i];
 1185|      0|    return NULL;
 1186|      0|}
 1187|       |
 1188|      0|static int ply_check_word(p_ply ply) {
 1189|      0|    size_t size = strlen(BWORD(ply));
 1190|      0|    if (size >= WORDSIZE) {
 1191|      0|        ply_ferror(ply, "Word too long");
 1192|      0|        return 0;
 1193|      0|    } else if (size == 0) {
 1194|      0|        ply_ferror(ply, "Unexpected end of file");
 1195|      0|        return 0;
 1196|      0|    }
 1197|      0|    return 1;
 1198|      0|}
 1199|       |
 1200|      0|static int ply_read_word(p_ply ply) {
 1201|      0|    size_t t = 0;
 1202|      0|    assert(ply && ply->fp && ply->io_mode == PLY_READ);
 1203|       |    /* skip leading blanks */
 1204|      0|    while (1) {
 1205|      0|        t = strspn(BFIRST(ply), " \n\r\t");
 1206|       |        /* check if all buffer was made of blanks */
 1207|      0|        if (t >= BSIZE(ply)) {
 1208|      0|            if (!BREFILL(ply)) {
 1209|      0|                ply_ferror(ply, "Unexpected end of file");
 1210|      0|                return 0;
 1211|      0|            }
 1212|      0|        } else break; 
 1213|      0|    } 
 1214|      0|    BSKIP(ply, t); 
 1215|       |    /* look for a space after the current word */
 1216|      0|    t = strcspn(BFIRST(ply), " \n\r\t");
 1217|       |    /* if we didn't reach the end of the buffer, we are done */
 1218|      0|    if (t < BSIZE(ply)) {
 1219|      0|        ply_finish_word(ply, t);
 1220|      0|        return ply_check_word(ply);
 1221|      0|    }
 1222|       |    /* otherwise, try to refill buffer */
 1223|      0|    if (!BREFILL(ply)) {
 1224|       |        /* if we reached the end of file, try to do with what we have */
 1225|      0|        ply_finish_word(ply, t);
 1226|      0|        return ply_check_word(ply);
 1227|       |        /* ply_ferror(ply, "Unexpected end of file"); */
 1228|       |        /* return 0; */
 1229|      0|    }
 1230|       |    /* keep looking from where we left */
 1231|      0|    t += strcspn(BFIRST(ply) + t, " \n\r\t");
 1232|       |    /* check if the token is too large for our buffer */
 1233|      0|    if (t >= BSIZE(ply)) {
 1234|      0|        ply_ferror(ply, "Token too large");
 1235|      0|        return 0;
 1236|      0|    }
 1237|       |    /* we are done */
 1238|      0|    ply_finish_word(ply, t);
 1239|      0|    return ply_check_word(ply);
 1240|      0|}
 1241|       |
 1242|      0|static void ply_finish_word(p_ply ply, size_t size) {
 1243|      0|    ply->buffer_token = ply->buffer_first;
 1244|      0|    BSKIP(ply, size);
 1245|      0|    *BFIRST(ply) = '\0';
 1246|      0|    BSKIP(ply, 1);
 1247|      0|}
 1248|       |
 1249|      0|static int ply_check_line(p_ply ply) {
 1250|      0|    if (strlen(BLINE(ply)) >= LINESIZE) {
 1251|      0|        ply_ferror(ply, "Line too long");
 1252|      0|        return 0;
 1253|      0|    }
 1254|      0|    return 1;
 1255|      0|}
 1256|       |
 1257|      0|static int ply_read_line(p_ply ply) {
 1258|      0|    const char *end = NULL;
 1259|      0|    assert(ply && ply->fp && ply->io_mode == PLY_READ);
 1260|       |    /* look for a end of line */
 1261|      0|    end = strchr(BFIRST(ply), '\n');
 1262|       |    /* if we didn't reach the end of the buffer, we are done */
 1263|      0|    if (end) {
 1264|      0|        ply->buffer_token = ply->buffer_first;
 1265|      0|        BSKIP(ply, end - BFIRST(ply));
 1266|      0|        *BFIRST(ply) = '\0';
 1267|      0|        BSKIP(ply, 1);
 1268|      0|        return ply_check_line(ply);
 1269|      0|    } else {
 1270|      0|        end = ply->buffer + BSIZE(ply); 
 1271|       |        /* otherwise, try to refill buffer */
 1272|      0|        if (!BREFILL(ply)) {
 1273|      0|            ply_ferror(ply, "Unexpected end of file");
 1274|      0|            return 0;
 1275|      0|        }
 1276|      0|    }
 1277|       |    /* keep looking from where we left */
 1278|      0|    end = strchr(end, '\n');
 1279|       |    /* check if the token is too large for our buffer */
 1280|      0|    if (!end) {
 1281|      0|        ply_ferror(ply, "Token too large");
 1282|      0|        return 0;
 1283|      0|    }
 1284|       |    /* we are done */
 1285|      0|    ply->buffer_token = ply->buffer_first;
 1286|      0|    BSKIP(ply, end - BFIRST(ply));
 1287|      0|    *BFIRST(ply) = '\0';
 1288|      0|    BSKIP(ply, 1);
 1289|      0|    return ply_check_line(ply);
 1290|      0|}
 1291|       |
 1292|      0|static int ply_read_chunk(p_ply ply, void *anybuffer, size_t size) {
 1293|      0|    char *buffer = (char *) anybuffer;
 1294|      0|    size_t i = 0;
 1295|      0|    assert(ply && ply->fp && ply->io_mode == PLY_READ);
 1296|      0|    assert(ply->buffer_first <= ply->buffer_last);
 1297|      0|    while (i < size) {
 1298|      0|        if (ply->buffer_first < ply->buffer_last) {
 1299|      0|            buffer[i] = ply->buffer[ply->buffer_first];
 1300|      0|            ply->buffer_first++;
 1301|      0|            i++;
 1302|      0|        } else {
 1303|      0|            ply->buffer_first = 0;
 1304|      0|            ply->buffer_last = fread(ply->buffer, 1, BUFFERSIZE, ply->fp);
 1305|      0|            if (ply->buffer_last <= 0) return 0;
 1306|      0|        }
 1307|      0|    }
 1308|      0|    return 1;
 1309|      0|}
 1310|       |
 1311|      0|static int ply_write_chunk(p_ply ply, void *anybuffer, size_t size) {
 1312|      0|    char *buffer = (char *) anybuffer;
 1313|      0|    size_t i = 0;
 1314|      0|    assert(ply && ply->fp && ply->io_mode == PLY_WRITE);
 1315|      0|    assert(ply->buffer_last <= BUFFERSIZE);
 1316|      0|    while (i < size) {
 1317|      0|        if (ply->buffer_last < BUFFERSIZE) {
 1318|      0|            ply->buffer[ply->buffer_last] = buffer[i];
 1319|      0|            ply->buffer_last++;
 1320|      0|            i++;
 1321|      0|        } else {
 1322|      0|            ply->buffer_last = 0;
 1323|      0|            if (fwrite(ply->buffer, 1, BUFFERSIZE, ply->fp) < BUFFERSIZE)
 1324|      0|                return 0;
 1325|      0|        }
 1326|      0|    }
 1327|      0|    return 1;
 1328|      0|}
 1329|       |
 1330|      0|static int ply_write_chunk_reverse(p_ply ply, void *anybuffer, size_t size) {
 1331|      0|    int ret = 0;
 1332|      0|    ply_reverse(anybuffer, size);
 1333|      0|    ret = ply_write_chunk(ply, anybuffer, size);
 1334|      0|    ply_reverse(anybuffer, size);
 1335|      0|    return ret;
 1336|      0|}
 1337|       |
 1338|      0|static int ply_read_chunk_reverse(p_ply ply, void *anybuffer, size_t size) {
 1339|      0|    if (!ply_read_chunk(ply, anybuffer, size)) return 0;
 1340|      0|    ply_reverse(anybuffer, size);
 1341|      0|    return 1;
 1342|      0|}
 1343|       |
 1344|      0|static void ply_reverse(void *anydata, size_t size) {
 1345|      0|    char *data = (char *) anydata;
 1346|      0|    char temp;
 1347|      0|    size_t i;
 1348|      0|    for (i = 0; i < size/2; i++) {
 1349|      0|        temp = data[i];
 1350|      0|        data[i] = data[size-i-1];
 1351|      0|        data[size-i-1] = temp;
 1352|      0|    }
 1353|      0|}
 1354|       |
 1355|      0|static void ply_init(p_ply ply) {
 1356|      0|    ply->element = NULL;
 1357|      0|    ply->nelements = 0;
 1358|      0|    ply->comment = NULL;
 1359|      0|    ply->ncomments = 0;
 1360|      0|    ply->obj_info = NULL;
 1361|      0|    ply->nobj_infos = 0;
 1362|      0|    ply->idriver = NULL;
 1363|      0|    ply->odriver = NULL;
 1364|      0|    ply->buffer[0] = '\0';
 1365|      0|    ply->buffer_first = ply->buffer_last = ply->buffer_token = 0;
 1366|      0|    ply->welement = 0;
 1367|      0|    ply->wproperty = 0;
 1368|      0|    ply->winstance_index = 0;
 1369|      0|    ply->wlength = 0;
 1370|      0|    ply->wvalue_index = 0;
 1371|      0|}
 1372|       |
 1373|      0|static void ply_element_init(p_ply_element element) {
 1374|      0|    element->name[0] = '\0';
 1375|      0|    element->ninstances = 0;
 1376|      0|    element->property = NULL;
 1377|      0|    element->nproperties = 0; 
 1378|      0|}
 1379|       |
 1380|      0|static void ply_property_init(p_ply_property property) {
 1381|      0|    property->name[0] = '\0';
 1382|      0|    property->type = (e_ply_type)(-1);
 1383|      0|    property->length_type = (e_ply_type)-1;
 1384|      0|    property->value_type = (e_ply_type)-1;
 1385|      0|    property->read_cb = (p_ply_read_cb) NULL;
 1386|      0|    property->pdata = NULL;
 1387|      0|    property->idata = 0;
 1388|      0|}
 1389|       |
 1390|      0|static p_ply ply_alloc(void) {
 1391|      0|    p_ply ply = (p_ply) calloc(1, sizeof(t_ply));
 1392|      0|    if (!ply) return NULL;
 1393|      0|    ply_init(ply);
 1394|      0|    return ply;
 1395|      0|}
 1396|       |
 1397|       |static void *ply_grow_array(p_ply ply, void **pointer, 
 1398|      0|        long *nmemb, long size) {
 1399|      0|    void *temp = *pointer;
 1400|      0|    long count = *nmemb + 1;
 1401|      0|    if (!temp) temp = malloc(count*size);
 1402|      0|    else temp = realloc(temp, count*size);
 1403|      0|    if (!temp) {
 1404|      0|        ply_ferror(ply, "Out of memory");
 1405|      0|        return NULL;
 1406|      0|    }
 1407|      0|    *pointer = temp;
 1408|      0|    *nmemb = count;
 1409|      0|    return (char *) temp + (count-1) * size;
 1410|      0|}
 1411|       |
 1412|      0|static p_ply_element ply_grow_element(p_ply ply) {
 1413|      0|    p_ply_element element = NULL;
 1414|      0|    assert(ply); 
 1415|      0|    assert(ply->element || ply->nelements == 0); 
 1416|      0|    assert(!ply->element || ply->nelements > 0); 
 1417|      0|    element = (p_ply_element) ply_grow_array(ply, (void **) &ply->element, 
 1418|      0|            &ply->nelements, sizeof(t_ply_element));
 1419|      0|    if (!element) return NULL;
 1420|      0|    ply_element_init(element);
 1421|      0|    return element; 
 1422|      0|}
 1423|       |
 1424|      0|static p_ply_property ply_grow_property(p_ply ply, p_ply_element element) {
 1425|      0|    p_ply_property property = NULL;
 1426|      0|    assert(ply);
 1427|      0|    assert(element);
 1428|      0|    assert(element->property || element->nproperties == 0);
 1429|      0|    assert(!element->property || element->nproperties > 0);
 1430|      0|    property = (p_ply_property) ply_grow_array(ply, 
 1431|      0|            (void **) &element->property, 
 1432|      0|            &element->nproperties, sizeof(t_ply_property));
 1433|      0|    if (!property) return NULL;
 1434|      0|    ply_property_init(property);
 1435|      0|    return property;
 1436|      0|}
 1437|       |
 1438|      0|static int ply_read_header_format(p_ply ply) {
 1439|      0|    assert(ply && ply->fp && ply->io_mode == PLY_READ);
 1440|      0|    if (strcmp(BWORD(ply), "format")) return 0;
 1441|      0|    if (!ply_read_word(ply)) return 0;
 1442|      0|    ply->storage_mode = (e_ply_storage_mode)ply_find_string(BWORD(ply), ply_storage_mode_list);
 1443|      0|    if (ply->storage_mode == (e_ply_storage_mode) (-1)) return 0;
 1444|      0|    if (ply->storage_mode == PLY_ASCII) ply->idriver = &ply_idriver_ascii;
 1445|      0|    else if (ply->storage_mode == ply_arch_endian()) 
 1446|      0|        ply->idriver = &ply_idriver_binary;
 1447|      0|    else ply->idriver = &ply_idriver_binary_reverse;
 1448|      0|    if (!ply_read_word(ply)) return 0;
 1449|      0|    if (strcmp(BWORD(ply), "1.0")) return 0;
 1450|      0|    if (!ply_read_word(ply)) return 0;
 1451|      0|    return 1;
 1452|      0|}
 1453|       |
 1454|      0|static int ply_read_header_comment(p_ply ply) {
 1455|      0|    assert(ply && ply->fp && ply->io_mode == PLY_READ);
 1456|      0|    if (strcmp(BWORD(ply), "comment")) return 0;
 1457|      0|    if (!ply_read_line(ply)) return 0;
 1458|      0|    if (!ply_add_comment(ply, BLINE(ply))) return 0;
 1459|      0|    if (!ply_read_word(ply)) return 0;
 1460|      0|    return 1;
 1461|      0|}
 1462|       |
 1463|      0|static int ply_read_header_obj_info(p_ply ply) {
 1464|      0|    assert(ply && ply->fp && ply->io_mode == PLY_READ);
 1465|      0|    if (strcmp(BWORD(ply), "obj_info")) return 0;
 1466|      0|    if (!ply_read_line(ply)) return 0;
 1467|      0|    if (!ply_add_obj_info(ply, BLINE(ply))) return 0;
 1468|      0|    if (!ply_read_word(ply)) return 0;
 1469|      0|    return 1;
 1470|      0|}
 1471|       |
 1472|      0|static int ply_read_header_property(p_ply ply) {
 1473|      0|    p_ply_element element = NULL;
 1474|      0|    p_ply_property property = NULL;
 1475|       |    /* make sure it is a property */
 1476|      0|    if (strcmp(BWORD(ply), "property")) return 0;
 1477|      0|    element = &ply->element[ply->nelements-1];
 1478|      0|    property = ply_grow_property(ply, element);
 1479|      0|    if (!property) return 0;
 1480|       |    /* get property type */
 1481|      0|    if (!ply_read_word(ply)) return 0;
 1482|      0|    property->type = (e_ply_type)ply_find_string(BWORD(ply), ply_type_list);
 1483|      0|    if (property->type == (e_ply_type) (-1)) return 0;
 1484|      0|    if (property->type == PLY_LIST) {
 1485|       |        /* if it's a list, we need the base types */
 1486|      0|        if (!ply_read_word(ply)) return 0;
 1487|      0|        property->length_type = (e_ply_type)ply_find_string(BWORD(ply), ply_type_list);
 1488|      0|        if (property->length_type == (e_ply_type) (-1)) return 0;
 1489|      0|        if (!ply_read_word(ply)) return 0;
 1490|      0|        property->value_type = (e_ply_type)ply_find_string(BWORD(ply), ply_type_list);
 1491|      0|        if (property->value_type == (e_ply_type) (-1)) return 0;
 1492|      0|    }
 1493|       |    /* get property name */
 1494|      0|    if (!ply_read_word(ply)) return 0;
 1495|      0|    strcpy(property->name, BWORD(ply));
 1496|      0|    if (!ply_read_word(ply)) return 0;
 1497|      0|    return 1;
 1498|      0|}
 1499|       |
 1500|      0|static int ply_read_header_element(p_ply ply) {
 1501|      0|    p_ply_element element = NULL;
 1502|      0|    long dummy;
 1503|      0|    assert(ply && ply->fp && ply->io_mode == PLY_READ);
 1504|      0|    if (strcmp(BWORD(ply), "element")) return 0;
 1505|       |    /* allocate room for new element */
 1506|      0|    element = ply_grow_element(ply);
 1507|      0|    if (!element) return 0;
 1508|       |    /* get element name */
 1509|      0|    if (!ply_read_word(ply)) return 0;
 1510|      0|    strcpy(element->name, BWORD(ply));
 1511|       |    /* get number of elements of this type */
 1512|      0|    if (!ply_read_word(ply)) return 0;
 1513|      0|    if (sscanf(BWORD(ply), "%ld", &dummy) != 1) {
 1514|      0|        ply_ferror(ply, "Expected number got '%s'", BWORD(ply));
 1515|      0|        return 0;
 1516|      0|    }
 1517|      0|    element->ninstances = dummy;
 1518|       |    /* get all properties for this element */
 1519|      0|    if (!ply_read_word(ply)) return 0;
 1520|      0|    while (ply_read_header_property(ply) || 
 1521|      0|        ply_read_header_comment(ply) || ply_read_header_obj_info(ply))
 1522|      0|        /* do nothing */;
 1523|      0|    return 1;
 1524|      0|}
 1525|       |
 1526|      0|static void ply_error_cb(p_ply ply, const char *message) {
 1527|      0|    (void) ply;
 1528|      0|    fprintf(stderr, "RPly: %s\n", message);
 1529|      0|}
 1530|       |
 1531|      0|static void ply_ferror(p_ply ply, const char *fmt, ...) {
 1532|      0|    char buffer[1024];
 1533|      0|    va_list ap;
 1534|      0|    va_start(ap, fmt);
 1535|      0|    vsprintf(buffer, fmt, ap);
 1536|      0|    va_end(ap);
 1537|      0|    ply->error_cb(ply, buffer);
 1538|      0|}
 1539|       |
 1540|      0|static e_ply_storage_mode ply_arch_endian(void) {
 1541|      0|    unsigned long i = 1;
 1542|      0|    unsigned char *s = (unsigned char *) &i;
 1543|      0|    if (*s == 1) return PLY_LITTLE_ENDIAN;
 1544|      0|    else return PLY_BIG_ENDIAN;
 1545|      0|}
 1546|       |
 1547|      0|static int ply_type_check(void) {
 1548|      0|    assert(sizeof(t_ply_int8) == 1);
 1549|      0|    assert(sizeof(t_ply_uint8) == 1);
 1550|      0|    assert(sizeof(t_ply_int16) == 2);
 1551|      0|    assert(sizeof(t_ply_uint16) == 2);
 1552|      0|    assert(sizeof(t_ply_int32) == 4);
 1553|      0|    assert(sizeof(t_ply_uint32) == 4);
 1554|      0|    assert(sizeof(float) == 4);
 1555|      0|    assert(sizeof(double) == 8);
 1556|      0|    if (sizeof(t_ply_int8) != 1) return 0;
 1557|      0|    if (sizeof(t_ply_uint8) != 1) return 0;
 1558|      0|    if (sizeof(t_ply_int16) != 2) return 0;
 1559|      0|    if (sizeof(t_ply_uint16) != 2) return 0;
 1560|      0|    if (sizeof(t_ply_int32) != 4) return 0;
 1561|      0|    if (sizeof(t_ply_uint32) != 4) return 0;
 1562|      0|    if (sizeof(float) != 4) return 0;
 1563|      0|    if (sizeof(double) != 8) return 0;
 1564|      0|    return 1;
 1565|      0|}
 1566|       |
 1567|       |
 1568|       |/* ----------------------------------------------------------------------
 1569|       | * Copyright (C) 2003-2011 Diego Nehab.  All rights reserved.
 1570|       | *
 1571|       | * Permission is hereby granted, free of charge, to any person obtaining
 1572|       | * a copy of this software and associated documentation files (the
 1573|       | * "Software"), to deal in the Software without restriction, including
 1574|       | * without limitation the rights to use, copy, modify, merge, publish,
 1575|       | * distribute, sublicense, and/or sell copies of the Software, and to
 1576|       | * permit persons to whom the Software is furnished to do so, subject to
 1577|       | * the following conditions:
 1578|       | *
 1579|       | * The above copyright notice and this permission notice shall be
 1580|       | * included in all copies or substantial portions of the Software.
 1581|       | *
 1582|       | * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 1583|       | * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 1584|       | * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 1585|       | * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 1586|       | * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 1587|       | * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 1588|       | * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 1589|       | * ---------------------------------------------------------------------- */

/workspaces/cg/src/cgmesh/mesh_io_u3d.cpp:
    1|       |#include "mesh.h"
    2|       |#if 0
    3|       |#include "io/FileFormat_U3D.h"
    4|       |#endif
    5|       |
    6|       |int Mesh::import_u3d (char *filename)
    7|      0|{
    8|      0|	if (filename == NULL)
    9|      0|		return -1;
   10|       |#if 0
   11|       |	U3DModel *pU3DModel = LoadU3DFile(filename);
   12|       |	DumpU3DFile (pU3DModel, "u3d_output.html");
   13|       |	FreeU3DModel(pU3DModel);
   14|       |#endif
   15|       |
   16|      0|	return 0;
   17|      0|}
   18|       |
   19|       |int Mesh::export_u3d (char *filename)
   20|      0|{
   21|       |	/*
   22|       |	if (filename == NULL)
   23|       |		return -1;
   24|       |
   25|       |	IFXWriteManager* pWriteManager = NULL;
   26|       |	IFXWriteBuffer* pWriteBuffer = NULL;
   27|       |	IFXStdio* pStdio = NULL;
   28|       |
   29|       |	// Create Write Manager component
   30|       |	if (IFXSUCCESS(result))
   31|       |		result = IFXCreateComponent(CID_IFXWriteManager, IID_IFXWriteManager,
   32|       |		(void**)&pWriteManager);
   33|       |
   34|       |	// Initialize WriteManeger
   35|       |	if (IFXSUCCESS(result))
   36|       |		result = pWriteManager->Initialize(pCoreServices);
   37|       |
   38|       |	// Create an IFXWriteBuffer object
   39|       |	if (IFXSUCCESS(result))
   40|       |		result = IFXCreateComponent(CID_IFXStdioWriteBuffer, IID_IFXWriteBuffer,
   41|       |		(void**)&pWriteBuffer);
   42|       |
   43|       |	// Get the objects's IFXStdio interface.
   44|       |	if (IFXSUCCESS(result))
   45|       |		result = pWriteBuffer->QueryInterface(IID_IFXStdio, (void**)&pStdio);
   46|       |
   47|       |	// Open file to store scene
   48|       |	if (IFXSUCCESS(result))
   49|       |		result = pStdio->Open(filename);
   50|       |
   51|       |	// Mark all subnodes to store. (Recursively marks a subset of the database)
   52|       |	if (IFXSUCCESS(result))
   53|       |		result = pSceneGraph->Mark();
   54|       |
   55|       |	// Write an SceneGraph out to an WriteBuffer, based on the options supplied
   56|       |	// in exportOptions.
   57|       |	if (IFXSUCCESS(result))
   58|       |		result = pWriteManager->Write(pWriteBuffer, IFXEXPORT_EVERYTHING);
   59|       |
   60|       |	// Close the file
   61|       |	if (IFXSUCCESS(result))
   62|       |		result = pStdio->Close();
   63|       |
   64|       |	IFXRELEASE(pStdio)
   65|       |		IFXRELEASE(pWriteBuffer)
   66|       |		IFXRELEASE(pWriteManager)
   67|       |		*/
   68|      0|	return 0;
   69|      0|}

/workspaces/cg/src/cgmesh/mesh_transform.cpp:
    1|       |#include "mesh.h"
    2|       |
    3|       |//
    4|       |// Transformations
    5|       |//
    6|       |
    7|       |void Mesh::centerize (void)
    8|      1|{
    9|      1|	float cx = 0., cy = 0., cz = 0.;
   10|  1.98k|	for (unsigned int i=0; i<m_nVertices; i++)
   11|  1.98k|	{
   12|  1.98k|		cx += m_pVertices[3*i];
   13|  1.98k|		cy += m_pVertices[3*i+1];
   14|  1.98k|		cz += m_pVertices[3*i+2];
   15|  1.98k|	}
   16|      1|	cx /= m_nVertices;
   17|      1|	cy /= m_nVertices;
   18|      1|	cz /= m_nVertices;
   19|  1.98k|	for (unsigned int i=0; i<m_nVertices; i++)
   20|  1.98k|	{
   21|  1.98k|		m_pVertices[3*i+0] -= cx;
   22|  1.98k|		m_pVertices[3*i+1] -= cy;
   23|  1.98k|		m_pVertices[3*i+2] -= cz;
   24|  1.98k|	}
   25|      1|}
   26|       |
   27|       |void Mesh::scale (float s)
   28|      1|{
   29|  5.95k|	for (unsigned int i=0; i<3*m_nVertices; i++)
   30|  5.95k|		m_pVertices[i] *= s;
   31|      1|}
   32|       |
   33|       |void Mesh::scale_xyz (float sx, float sy, float sz)
   34|      0|{
   35|      0|	for (unsigned int i=0; i<m_nVertices; i++)
   36|      0|	{
   37|      0|		m_pVertices[3*i+0] *= sx;
   38|      0|		m_pVertices[3*i+1] *= sy;
   39|      0|		m_pVertices[3*i+2] *= sz;
   40|      0|	}
   41|      0|}
   42|       |
   43|       |void Mesh::translate (float tx, float ty, float tz)
   44|      0|{
   45|      0|	for (unsigned int i=0; i<m_nVertices; i++)
   46|      0|	{
   47|      0|		m_pVertices[3*i+0] += tx;
   48|      0|		m_pVertices[3*i+1] += ty;
   49|      0|		m_pVertices[3*i+2] += tz;
   50|      0|	}
   51|      0|}
   52|       |
   53|       |void Mesh::transform (float mrot[9])
   54|      0|{
   55|      0|	float tmp[3];
   56|      0|	for (unsigned int i=0; i<m_nVertices; i++)
   57|      0|	{
   58|      0|		tmp[0] = m_pVertices[3*i];
   59|      0|		tmp[1] = m_pVertices[3*i+1];
   60|      0|		tmp[2] = m_pVertices[3*i+2];
   61|      0|		m_pVertices[3*i]   = mrot[0]*tmp[0] + mrot[1]*tmp[1] + mrot[2]*tmp[2];
   62|      0|		m_pVertices[3*i+1] = mrot[3]*tmp[0] + mrot[4]*tmp[1] + mrot[5]*tmp[2];
   63|      0|		m_pVertices[3*i+2] = mrot[6]*tmp[0] + mrot[7]*tmp[1] + mrot[8]*tmp[2];
   64|      0|	}
   65|      0|}
   66|       |
   67|       |void Mesh::transform (mat3 m)
   68|      1|{
   69|      1|	vec3 vtmp;
   70|  1.98k|	for (unsigned int i=0; i<m_nVertices; i++)
   71|  1.98k|	{
   72|  1.98k|		vec3_init (vtmp, m_pVertices[3*i], m_pVertices[3*i+1], m_pVertices[3*i+2]);
   73|  1.98k|		mat3_transform (vtmp, m, vtmp);
   74|  1.98k|		m_pVertices[3*i]   = vtmp[0];
   75|  1.98k|		m_pVertices[3*i+1] = vtmp[1];
   76|  1.98k|		m_pVertices[3*i+2] = vtmp[2];
   77|  1.98k|	}
   78|      1|}
   79|       |
   80|       |void Mesh::transform4 (mat4 m)
   81|      0|{
   82|      0|	vec4 vtmp;
   83|      0|	for (unsigned int i=0; i<m_nVertices; i++)
   84|      0|	{
   85|      0|		vec4_init (vtmp, m_pVertices[3*i], m_pVertices[3*i+1], m_pVertices[3*i+2], 1.);
   86|      0|		mat4_transform (vtmp, m, vtmp);
   87|      0|		m_pVertices[3*i]   = vtmp[0];
   88|      0|		m_pVertices[3*i+1] = vtmp[1];
   89|      0|		m_pVertices[3*i+2] = vtmp[2];
   90|      0|	}
   91|      0|}
   92|       |

/workspaces/cg/src/cgmesh/normals.h:
    1|       |#ifndef __NORMALS_H__
    2|       |#define __NORMALS_H__
    3|       |
    4|       |#include "mesh_half_edge.h"
    5|       |
    6|       |//
    7|       |// THURMER
    8|       |// G. Thurmer, C. A. Wuthrich, "Computing vertex normals from polygonal facets" Journal of Graphics Tools, 3 1998
    9|       |//
   10|       |// MAX
   11|       |// Nelson Max, "Weights for Computing Vertex Normals from Facet Normals", Journal of Graphics Tools, 4(2) (1999)
   12|       |//
   13|       |// Comparisons :
   14|       |// S. Jin, R.R. Lewis, D. West, "A comparison of algorithms for vertex normal computations", The Visual Computer, 2005 - Springer
   15|       |//
   16|       |class Normals
   17|       |{
   18|       |public:
   19|       |enum MethodId {
   20|       |	GOURAUD,
   21|       |	THURMER,
   22|       |	MAX,
   23|       |	DESBRUN
   24|       |   };
   25|       |
   26|      0|	Normals () {};
   27|      0|	~Normals () {};
   28|       |
   29|       |	int EvalOnVertices (Mesh_half_edge *mesh, MethodId par_id);
   30|       |	int EvalOnFaces (Mesh_half_edge *mesh);
   31|       |
   32|       |	void invert_vertices_normales (Mesh_half_edge *mesh);
   33|       |
   34|       |private:
   35|       |};
   36|       |
   37|       |#endif // __NORMALS

/workspaces/cg/src/cgmesh/object3D.cpp:
    1|       |#include "object3D.h"
    2|       |#include "mesh_io_3ds.h"
    3|       |
    4|       |//
    5|       |//
    6|       |//
    7|       |Object3D::Object3D ()
    8|      1|{
    9|      1|	m_listMeshes.clear ();
   10|      1|}
   11|       |
   12|       |//
   13|       |//
   14|       |//
   15|       |Object3D::~Object3D ()
   16|      0|{
   17|      0|	for (list<Mesh*>::iterator it = m_listMeshes.begin (); it != m_listMeshes.end (); it++)
   18|      0|	{
   19|      0|		Mesh *pMesh = (*it);
   20|      0|		if (pMesh)
   21|      0|			delete pMesh;
   22|      0|	}
   23|      0|	m_listMeshes.clear ();
   24|      0|}
   25|       |
   26|       |
   27|       |unsigned int Object3D::GetNVertices() const
   28|      0|{
   29|      0|	unsigned int nVertices = 0;
   30|       |
   31|      0|	for (const auto& mesh : m_listMeshes)
   32|      0|		nVertices += mesh->GetNVertices();
   33|       |
   34|      0|	return nVertices;
   35|      0|}
   36|       |
   37|       |unsigned int Object3D::GetNFaces() const
   38|      0|{
   39|      0|	unsigned int nFaces = 0;
   40|       |
   41|      0|	for (const auto& mesh : m_listMeshes)
   42|      0|		nFaces += mesh->GetNFaces();
   43|       |
   44|      0|	return nFaces;
   45|      0|}
   46|       |
   47|       |
   48|       |size_t Object3D::GetNMeshes() const
   49|      0|{
   50|      0|	return m_listMeshes.size();
   51|      0|}
   52|       |
   53|       |bool Object3D::IsTriangleMesh() const
   54|      0|{
   55|      0|	for (const auto& mesh : m_listMeshes)
   56|      0|		if (!mesh->IsTriangleMesh())
   57|      0|			return false;
   58|      0|	return true;
   59|      0|}
   60|       |
   61|       |//
   62|       |//
   63|       |//
   64|       |bool Object3D::import_file (char *filename)
   65|      1|{
   66|      1|	bool res = false;
   67|       |
   68|      1|	clean ();
   69|       |	
   70|       |  // check if the filename exists
   71|      1|  FILE *ptr = fopen (filename, "r");
   72|      1|  if (ptr == NULL)
   73|      0|    {
   74|      0|      return false;
   75|      0|    }
   76|      1|  else
   77|      1|  {
   78|      1|    fclose (ptr);
   79|      1|  }
   80|       |
   81|       |  // determine the format
   82|      1|  int size = strlen(filename);
   83|       |
   84|       |  // obj
   85|      1|  if (filename[size - 3] == 'o' && filename[size - 2] == 'b' && filename[size - 1] == 'j')
   86|      0|	  res = import_obj(filename);
   87|       |
   88|       |  // stl
   89|      1|  if (filename[size - 3] == 's' && filename[size - 2] == 't' && filename[size - 1] == 'l')
   90|      0|	  res = import_obj(filename);
   91|       |
   92|       |  // 3ds
   93|      1|  if (filename[size-3] == '3' && filename[size-2] == 'd' && filename[size-1] == 's')
   94|      1|    res = import_3ds (filename);
   95|       |
   96|      1|  return res;
   97|      1|}
   98|       |
   99|       |//
  100|       |//
  101|       |//
  102|       |bool Object3D::export_file (char *filename)
  103|      0|{
  104|      0|	bool res = false;
  105|       |
  106|       |	// determine the format
  107|      0|	int size = strlen(filename);
  108|       |
  109|       |	// obj
  110|      0|	if (filename[size - 3] == 'o' && filename[size - 2] == 'b' && filename[size - 1] == 'j')
  111|      0|		res = export_obj(filename);
  112|       |
  113|      0|	return res;
  114|       |
  115|      0|}
  116|       |
  117|       |// import / export
  118|       |void Object3D::clean (void)
  119|      1|{
  120|      1|}
  121|       |
  122|       |bool Object3D::import_obj(char* filename)
  123|      0|{
  124|      0|	auto pMesh = new Mesh();
  125|      0|	pMesh->load(filename);
  126|       |
  127|      0|	m_listMeshes.push_back(pMesh);
  128|       |
  129|      0|	return true;
  130|      0|}
  131|       |
  132|       |bool Object3D::export_obj(char* filename)
  133|      0|{
  134|      0|	if (!m_listMeshes.empty())
  135|      0|	{
  136|      0|		auto pMesh = m_listMeshes.front();
  137|      0|		pMesh->save(filename);
  138|      0|	}
  139|       |
  140|      0|	return true;
  141|      0|}
  142|       |
  143|       |bool Object3D::import_stl(char* filename)
  144|      0|{
  145|      0|	auto pMesh = new Mesh();
  146|      0|	pMesh->load(filename);
  147|       |
  148|      0|	m_listMeshes.push_back(pMesh);
  149|       |
  150|      0|	return true;
  151|      0|}
  152|       |
  153|       |bool Object3D::export_stl(char* filename)
  154|      0|{
  155|      0|	if (!m_listMeshes.empty())
  156|      0|	{
  157|      0|		auto pMesh = m_listMeshes.front();
  158|      0|		pMesh->save(filename);
  159|      0|	}
  160|       |
  161|      0|	return true;
  162|      0|}
  163|       |
  164|       |bool Object3D::import_3ds(char* filename)
  165|      1|{
  166|      1|	t3DSModel* p = Load3DSFile(filename, nullptr);
  167|       |
  168|      1|	for (auto& object : p->pObject)
  169|      4|	{
  170|      4|		auto pMesh = new Mesh();
  171|       |
  172|       |		/*mat3 rot;
  173|       |		mat3_init(rot,
  174|       |			object.LocalCoordinateSystem[0][0], object.LocalCoordinateSystem[0][1], object.LocalCoordinateSystem[0][2],
  175|       |			object.LocalCoordinateSystem[1][0], object.LocalCoordinateSystem[1][1], object.LocalCoordinateSystem[1][2],
  176|       |			object.LocalCoordinateSystem[2][0], object.LocalCoordinateSystem[2][1], object.LocalCoordinateSystem[2][2]
  177|       |		);
  178|       |		mat3_transpose(rot);
  179|       |		mat3_inverse(rot);*/
  180|       |
  181|      4|		Matrix3f rot2(
  182|      4|			object.LocalCoordinateSystem[0][0], object.LocalCoordinateSystem[0][1], object.LocalCoordinateSystem[0][2],
  183|      4|			object.LocalCoordinateSystem[1][0], object.LocalCoordinateSystem[1][1], object.LocalCoordinateSystem[1][2],
  184|      4|			object.LocalCoordinateSystem[2][0], object.LocalCoordinateSystem[2][1], object.LocalCoordinateSystem[2][2]
  185|      4|		);
  186|       |		//rot2.Transpose();
  187|      4|		rot2.Inverse();
  188|       |
  189|      4|		unsigned int nVertices = object.numOfVerts;
  190|      4|		unsigned int nFaces = object.numOfFaces;
  191|      4|		pMesh->Init(nVertices, nFaces);
  192|       |		
  193|    688|		for (unsigned int i = 0; i < nVertices; i++)
  194|    684|		{
  195|    684|			Vector3f pt(
  196|    684|				object.pVerts[i].fX,// - object.LocalCoordinateSystem[3][0],
  197|    684|				object.pVerts[i].fY,// - object.LocalCoordinateSystem[3][1],
  198|    684|				object.pVerts[i].fZ);// -object.LocalCoordinateSystem[3][2]);
  199|       |			//rot2.TransformPoint(pt);
  200|    684|			pMesh->m_pVertices[3 * i] = pt.x;// +object.LocalCoordinateSystem[3][0];
  201|    684|			pMesh->m_pVertices[3 * i + 1] = pt.y;// +object.LocalCoordinateSystem[3][1];
  202|    684|			pMesh->m_pVertices[3 * i + 2] = pt.z;// +object.LocalCoordinateSystem[3][2];
  203|    684|		}
  204|       |
  205|  1.07k|		for (unsigned int i = 0; i < nFaces; i++)
  206|  1.06k|		{
  207|  1.06k|			auto face = object.pFaces[i];
  208|       |
  209|  1.06k|			pMesh->m_pFaces[i]->SetNVertices(3);
  210|  4.27k|			for (unsigned int j = 0; j < 3; j++)
  211|  3.20k|				pMesh->m_pFaces[i]->SetVertex(j, face.vertIndex[j]);
  212|  1.06k|		}
  213|       |
  214|      4|		pMesh->m_name = std::string(object.strName);
  215|       |
  216|      4|		m_listMeshes.push_back(pMesh);
  217|      4|	}
  218|       |
  219|      1|	Free3DSModel(p);
  220|       |
  221|      1|	return true;
  222|      1|}
  223|       |
  224|       |bool Object3D::export_3ds(char* filename)
  225|      0|{
  226|      0|	return true;
  227|      0|}
  228|       |

/workspaces/cg/src/cgmesh/object3D.h:
    1|       |#pragma once
    2|       |
    3|       |#include "mesh.h"
    4|       |
    5|       |#include <list>
    6|       |#include <memory>
    7|       |using namespace std;
    8|       |
    9|       |class Object3D
   10|       |{
   11|       |public:
   12|       |	Object3D ();
   13|       |	~Object3D ();
   14|       |
   15|       |	bool import_file (char *filename);
   16|       |	bool export_file (char *filename);
   17|       |
   18|      0|	void AddMesh (Mesh *pMesh) { m_listMeshes.push_back (pMesh); };
   19|       |
   20|      1|	list<Mesh*>& GetMeshes (void) { return m_listMeshes; };
   21|       |
   22|       |	unsigned int GetNVertices() const;
   23|       |	unsigned int GetNFaces() const;
   24|       |	size_t GetNMeshes() const;
   25|       |	bool IsTriangleMesh() const;
   26|       |
   27|       |
   28|       |protected:
   29|       |	// import / export
   30|       |	void clean (void);
   31|       |
   32|       |	bool import_obj(char* filename);
   33|       |	bool export_obj(char* filename);
   34|       |
   35|       |	bool import_stl(char* filename);
   36|       |	bool export_stl(char* filename);
   37|       |
   38|       |	bool import_3ds(char* filename);
   39|       |	bool export_3ds(char* filename);
   40|       |
   41|       |private:
   42|       |	list<Mesh*> m_listMeshes;
   43|       |};

/workspaces/cg/src/cgmesh/octree.cpp:
    1|       |#include <stdio.h>
    2|       |#include <stdlib.h>
    3|       |#include <string.h>
    4|       |
    5|       |#include "octree.h"
    6|       |
    7|       |Octree::Octree ()
    8|     46|{
    9|     46|	m_pFather = NULL;
   10|    414|	for (int i=0; i<8; i++)
   11|    368|		m_pChildren[i] = NULL;
   12|     46|	m_nPoints = 0;
   13|     46|	m_pPoints = NULL;
   14|     46|	m_nIndices = 0;
   15|     46|	m_pIndices = NULL;
   16|     46|	m_nTriangles = 0;
   17|     46|	m_pTriangles = NULL;
   18|     46|}
   19|       |
   20|       |Octree::~Octree ()
   21|      0|{
   22|      0|	for (int i=0; i<8; i++)
   23|      0|		if (m_pChildren[i])
   24|      0|			delete m_pChildren[i];
   25|      0|	if (m_pPoints)
   26|      0|		delete m_pPoints;
   27|      0|	if (m_pIndices)
   28|      0|		delete m_pIndices;
   29|      0|}
   30|       |
   31|       |void Octree::GetCenter (float center[3]) const
   32|      6|{
   33|     24|	for (int i=0; i<3; i++)
   34|     18|		center[i] = (m_vecMin[i]+m_vecMax[i])/2.;
   35|      6|}
   36|       |
   37|       |void Octree::GetMinMax (float vecMin[3], float vecMax[3]) const
   38|      0|{
   39|      0|	memcpy (vecMin, m_vecMin, 3*sizeof(float));
   40|      0|	memcpy (vecMax, m_vecMax, 3*sizeof(float));
   41|      0|}
   42|       |
   43|       |void Octree::ComputeBounding (float *pPoints, int nPoints, float min[3], float max[3])
   44|      0|{
   45|      0|	for (int i=0; i<3; i++)
   46|      0|	{
   47|      0|		min[i] = pPoints[i];
   48|      0|		max[i] = pPoints[i];
   49|      0|	}
   50|      0|	for (int i=1; i<nPoints; i++)
   51|      0|	{
   52|      0|		for (int j=0; j<3; j++)
   53|      0|		{
   54|      0|			if (pPoints[3*i+j] < min[j]) min[j] = pPoints[3*i+j];
   55|      0|			if (pPoints[3*i+j] > max[j]) max[j] = pPoints[3*i+j];
   56|      0|		}
   57|      0|	}
   58|      0|}
   59|       |
   60|       |// basic algorithm (store positions)
   61|       |int Octree::Build (float *pPoints, int nPoints,
   62|       |				   unsigned int maxPoints,
   63|       |				   unsigned int maxDepth, unsigned int currentDepth)
   64|      0|{
   65|      0|	if (!pPoints)
   66|      0|		return -1;
   67|       |	
   68|       |	// compute the bounding values
   69|      0|	ComputeBounding (pPoints, nPoints, m_vecMin, m_vecMax);
   70|       |	
   71|      0|	if (currentDepth >= maxDepth || nPoints <= maxPoints)
   72|      0|	{
   73|      0|		m_nPoints = nPoints;
   74|      0|		m_pPoints = new float[3*nPoints];
   75|      0|		memcpy (m_pPoints, pPoints, 3*nPoints*sizeof(float));
   76|      0|		return 0;
   77|      0|	}
   78|       |
   79|       |	// get the center of the node
   80|      0|	float center[3];
   81|      0|	GetCenter(center);
   82|       |
   83|       |	// distribute the points
   84|      0|	unsigned int childPointCounts[8];
   85|      0|	memset(childPointCounts, 0, 8*sizeof(unsigned int));
   86|      0|	int *codes = new int[nPoints];
   87|      0|	memset (codes, 0, nPoints*sizeof(int));
   88|      0|	for (int i=0; i<nPoints; i++)
   89|      0|    {
   90|       |		// get the current point
   91|      0|		float x = pPoints[3*i];
   92|      0|		float y = pPoints[3*i+1];
   93|      0|		float z = pPoints[3*i+2];
   94|       |
   95|      0|        if (x > center[0]) codes[i] |= 1;
   96|      0|        if (y > center[1]) codes[i] |= 2;
   97|      0|        if (z > center[2]) codes[i] |= 4;
   98|       |
   99|      0|        childPointCounts[codes[i]]++;
  100|      0|    }
  101|       |
  102|       |	// call Build for the each child
  103|      0|    for (int i=0; i<8; i++)
  104|      0|    {
  105|       |		// no points for this child
  106|      0|        if (!childPointCounts[i])
  107|      0|		{
  108|      0|			m_pChildren[i] = NULL;
  109|      0|			continue;
  110|      0|		}
  111|       |
  112|       | 		// get the points for the current child
  113|      0|		float *_pPoints = (float*)malloc(3*childPointCounts[i]*sizeof(float));
  114|      0|		int k=0;
  115|      0|        for (int j=0; j<nPoints; j++)
  116|      0|        {
  117|      0|            if (codes[j] == i)
  118|      0|            {
  119|      0|                _pPoints[3*k]   = pPoints[3*j];
  120|      0|                _pPoints[3*k+1] = pPoints[3*j+1];
  121|      0|                _pPoints[3*k+2] = pPoints[3*j+2];
  122|      0|				k++;
  123|      0|            }
  124|      0|        }
  125|       |
  126|       |        // recurse
  127|      0|        m_pChildren[i] = new Octree ();
  128|      0|		m_pChildren[i]->m_pFather = this;
  129|      0|        m_pChildren[i]->Build(_pPoints, childPointCounts[i], maxPoints, maxDepth, currentDepth+1);
  130|       |
  131|       |        // cleaning
  132|      0|		free (_pPoints);
  133|      0|	}
  134|       |
  135|      0|	return 0;
  136|      0|}
  137|       |
  138|       |void Octree::ComputeBoundingWithIndices (float *pPoints, int nPoints, unsigned int *pIndices, int nIndices, float min[3], float max[3])
  139|      0|{
  140|      0|	for (int i=0; i<3; i++)
  141|      0|	{
  142|      0|		min[i] = pPoints[3*pIndices[0]+i];
  143|      0|		max[i] = pPoints[3*pIndices[0]+i];
  144|      0|	}
  145|      0|	for (int i=1; i<nIndices; i++)
  146|      0|	{
  147|      0|		for (int j=0; j<3; j++)
  148|      0|		{
  149|      0|			if (pPoints[3*pIndices[i]+j] < min[j]) min[j] = pPoints[3*pIndices[i]+j];
  150|      0|			if (pPoints[3*pIndices[i]+j] > max[j]) max[j] = pPoints[3*pIndices[i]+j];
  151|      0|		}
  152|      0|	}
  153|      0|}
  154|       |
  155|       |int Octree::BuildWithIndices (float *pPoints, int nPoints,
  156|       |								unsigned int maxPoints, unsigned int maxDepth,
  157|       |								unsigned int *pIndices, int nIndices, unsigned int currentDepth)
  158|      0|{
  159|      0|	if (!pPoints)
  160|      0|		return -1;
  161|       |
  162|       |	// initialization
  163|      0|	if (currentDepth == 0 && pIndices == NULL)
  164|      0|	{
  165|      0|		nIndices = nPoints;
  166|      0|		pIndices = (unsigned int*)malloc(nIndices*sizeof(unsigned int));
  167|      0|		for (int i=0; i<nIndices; i++)
  168|      0|			pIndices[i] = i;
  169|      0|		return BuildWithIndices (pPoints, nPoints, maxPoints, maxDepth, pIndices, nIndices, currentDepth);
  170|      0|	}
  171|       |	
  172|       |	// compute the bounding values
  173|      0|	ComputeBoundingWithIndices (pPoints, nPoints, pIndices, nIndices, m_vecMin, m_vecMax);
  174|       |	
  175|       |	// terminal condition
  176|      0|	if (currentDepth >= maxDepth || nPoints <= maxPoints)
  177|      0|	{
  178|      0|		m_nIndices = nIndices;
  179|      0|		m_pIndices = new unsigned int[nIndices];
  180|      0|		memcpy (m_pIndices, pIndices, nIndices*sizeof(int));
  181|      0|		return 0;
  182|      0|	}
  183|       |
  184|       |	// get the center of the node
  185|      0|	float center[3];
  186|      0|	GetCenter(center);
  187|       |
  188|       |	// distribute the points
  189|      0|	unsigned int childPointCounts[8];
  190|      0|	memset(childPointCounts, 0, 8*sizeof(unsigned int));
  191|      0|	int *codes = new int[nPoints];
  192|      0|	memset (codes, 0, nPoints*sizeof(int));
  193|      0|	for (int i=0; i<nIndices; i++)
  194|      0|    {
  195|       |		// get the current point
  196|      0|		int vi = 3*pIndices[i];
  197|      0|		float x = pPoints[vi];
  198|      0|		float y = pPoints[vi+1];
  199|      0|		float z = pPoints[vi+2];
  200|       |
  201|      0|		if (x > center[0]) codes[i] |= 1;
  202|      0|		if (y > center[1]) codes[i] |= 2;
  203|      0|		if (z > center[2]) codes[i] |= 4;
  204|       |
  205|      0|		childPointCounts[codes[i]]++;
  206|      0|    }
  207|       |
  208|       |	// call Build for the each child
  209|      0|    for (int i=0; i<8; i++)
  210|      0|    {
  211|       |		// no points for this child
  212|      0|		if (!childPointCounts[i])
  213|      0|		{
  214|      0|			m_pChildren[i] = NULL;
  215|      0|			continue;
  216|      0|		}
  217|       |
  218|       | 		// get the indices for the current child
  219|      0|		unsigned int *_pIndices = (unsigned int*)malloc(childPointCounts[i]*sizeof(unsigned int));
  220|      0|		int k=0;
  221|      0|        for (int j=0; j<nIndices; j++)
  222|      0|                if (codes[j] == i)
  223|      0|                        _pIndices[k++] = pIndices[j];
  224|       |
  225|       |        // recurse
  226|      0|        m_pChildren[i] = new Octree ();
  227|      0|		m_pChildren[i]->m_pFather = this;
  228|      0|        m_pChildren[i]->BuildWithIndices(pPoints, nPoints, maxPoints, maxDepth, _pIndices, childPointCounts[i], currentDepth+1);
  229|       |
  230|       |        // cleaning
  231|      0|		free (_pIndices);
  232|      0|	}
  233|       |
  234|       |	// cleaning
  235|      0|	delete[] codes;
  236|       |
  237|      0|	return 0;
  238|      0|}
  239|       |
  240|       |//
  241|       |// Fill the octree with triangles
  242|       |//
  243|       |void Octree::ComputeBoundinForTriangles (float *pPoints, int nPoints, unsigned int *pTriangles, int nTriangles, float min[3], float max[3])
  244|     46|{
  245|    184|	for (int i=0; i<3; i++)
  246|    138|	{
  247|    138|		min[i] = pPoints[3*pTriangles[0]+i];
  248|    138|		max[i] = pPoints[3*pTriangles[0]+i];
  249|    138|	}
  250|  7.67k|	for (int i=1; i<3*nTriangles; i++)
  251|  7.63k|	{
  252|  30.5k|		for (int j=0; j<3; j++)
  253|  22.8k|		{
  254|  22.8k|			if (pPoints[3*pTriangles[i]+j] < min[j]) min[j] = pPoints[3*pTriangles[i]+j];
  255|  22.8k|			if (pPoints[3*pTriangles[i]+j] > max[j]) max[j] = pPoints[3*pTriangles[i]+j];
  256|  22.8k|		}
  257|  7.63k|	}
  258|     46|}
  259|       |
  260|       |int Octree::BuildForTriangles (float *pPoints, int nPoints,
  261|       |			      unsigned int maxTriangles, unsigned int maxDepth,
  262|       |			      unsigned int *pTriangles, int nTriangles, unsigned int currentDepth)
  263|     46|{
  264|     46|	if (!pPoints || !pTriangles)
  265|      0|		return -1;
  266|       |	
  267|       |	// compute the bounding values
  268|     46|	ComputeBoundinForTriangles (pPoints, nPoints, pTriangles, nTriangles, m_vecMin, m_vecMax);
  269|       |	
  270|     46|	if (currentDepth >= maxDepth || nTriangles <= maxTriangles)
  271|     40|	{
  272|     40|		m_nTriangles = nTriangles;
  273|     40|		m_pTriangles = new unsigned int[3*nTriangles];
  274|     40|		memcpy (m_pTriangles, pTriangles, 3*nTriangles*sizeof(unsigned int));
  275|     40|		return 0;
  276|     40|	}
  277|       |	
  278|       |	// get the center of the node
  279|      6|	float center[3];
  280|      6|	GetCenter(center);
  281|       |
  282|       |	// distribute the triangles
  283|      6|	unsigned int childTriangleCounts[8];
  284|      6|	memset(childTriangleCounts, 0, 8*sizeof(unsigned int));
  285|      6|	int *codes = new int[nTriangles];
  286|      6|	memset (codes, 0, nTriangles*sizeof(int));
  287|  1.39k|	for (int i=0; i<nTriangles; i++)
  288|  1.38k|    {
  289|       |		// get the current triangle
  290|  1.38k|		Triangle tri;
  291|  1.38k|		tri.Init (pPoints[3*pTriangles[3*i]], pPoints[3*pTriangles[3*i]+1], pPoints[3*pTriangles[3*i]+2],
  292|  1.38k|				pPoints[3*pTriangles[3*i+1]], pPoints[3*pTriangles[3*i+1]+1], pPoints[3*pTriangles[3*i+1]+2],
  293|  1.38k|				pPoints[3*pTriangles[3*i+2]], pPoints[3*pTriangles[3*i+2]+1], pPoints[3*pTriangles[3*i+2]+2]);
  294|       |
  295|  1.38k|		AABox aabox0 (center[0], center[1], center[2]);
  296|  1.38k|		aabox0.AddVertex (m_vecMin[0], m_vecMin[1], m_vecMin[2]);
  297|       |
  298|  1.38k|		AABox aabox1 (center[0], center[1], center[2]);
  299|  1.38k|		aabox1.AddVertex (m_vecMin[0], m_vecMax[1], m_vecMin[2]);
  300|       |
  301|  1.38k|		AABox aabox2 (center[0], center[1], center[2]);
  302|  1.38k|		aabox2.AddVertex (m_vecMax[0], m_vecMin[1], m_vecMin[2]);
  303|       |
  304|  1.38k|		AABox aabox3 (center[0], center[1], center[2]);
  305|  1.38k|		aabox3.AddVertex (m_vecMax[0], m_vecMax[1], m_vecMin[2]);
  306|       |
  307|  1.38k|		AABox aabox4 (center[0], center[1], center[2]);
  308|  1.38k|		aabox4.AddVertex (m_vecMin[0], m_vecMin[1], m_vecMax[2]);
  309|       |
  310|  1.38k|		AABox aabox5 (center[0], center[1], center[2]);
  311|  1.38k|		aabox5.AddVertex (m_vecMin[0], m_vecMax[1], m_vecMax[2]);
  312|       |
  313|  1.38k|		AABox aabox6 (center[0], center[1], center[2]);
  314|  1.38k|		aabox6.AddVertex (m_vecMax[0], m_vecMin[1], m_vecMax[2]);
  315|       |
  316|  1.38k|		AABox aabox7 (center[0], center[1], center[2]);
  317|  1.38k|		aabox7.AddVertex (m_vecMax[0], m_vecMax[1], m_vecMax[2]);
  318|       |
  319|  1.38k|		float xmin = MIN3 (pPoints[3*pTriangles[3*i]], pPoints[3*pTriangles[3*i+1]], pPoints[3*pTriangles[3*i+2]]);
  320|  1.38k|		float ymin = MIN3 (pPoints[3*pTriangles[3*i]+1], pPoints[3*pTriangles[3*i+1]+1], pPoints[3*pTriangles[3*i+2]+1]);
  321|  1.38k|		float zmin = MIN3 (pPoints[3*pTriangles[3*i]+2], pPoints[3*pTriangles[3*i+1]+2], pPoints[3*pTriangles[3*i+2]+2]);
  322|  1.38k|		float xmax = MAX3 (pPoints[3*pTriangles[3*i]], pPoints[3*pTriangles[3*i+1]], pPoints[3*pTriangles[3*i+2]]);
  323|  1.38k|		float ymax = MAX3 (pPoints[3*pTriangles[3*i]+1], pPoints[3*pTriangles[3*i+1]+1], pPoints[3*pTriangles[3*i+2]+1]);
  324|  1.38k|		float zmax = MAX3 (pPoints[3*pTriangles[3*i]+2], pPoints[3*pTriangles[3*i+1]+2], pPoints[3*pTriangles[3*i+2]+2]);
  325|       |
  326|  1.38k|		if (aabox0.contains (tri) || aabox0.intersection (tri)) { codes[i] |= 1;   childTriangleCounts[0]++; }
  327|  1.38k|		if (aabox1.contains (tri) || aabox1.intersection (tri)) { codes[i] |= 2;   childTriangleCounts[1]++; }
  328|  1.38k|		if (aabox2.contains (tri) || aabox2.intersection (tri)) { codes[i] |= 4;   childTriangleCounts[2]++; }
  329|  1.38k|		if (aabox3.contains (tri) || aabox3.intersection (tri)) { codes[i] |= 8;   childTriangleCounts[3]++; }
  330|  1.38k|		if (aabox4.contains (tri) || aabox4.intersection (tri)) { codes[i] |= 16;  childTriangleCounts[4]++; }
  331|  1.38k|		if (aabox5.contains (tri) || aabox5.intersection (tri)) { codes[i] |= 32;  childTriangleCounts[5]++; }
  332|  1.38k|		if (aabox6.contains (tri) || aabox6.intersection (tri)) { codes[i] |= 64;  childTriangleCounts[6]++; }
  333|  1.38k|		if (aabox7.contains (tri) || aabox7.intersection (tri)) { codes[i] |= 128; childTriangleCounts[7]++; }
  334|  1.38k|    }
  335|       |
  336|       |	// call Build for each child
  337|     54|    for (int i=0; i<8; i++)
  338|     48|    {
  339|       |		// no triangle for this child
  340|     48|		if (!childTriangleCounts[i])
  341|      3|		{
  342|      3|			m_pChildren[i] = NULL;
  343|      3|			continue;
  344|      3|		}
  345|       |
  346|       | 		// get the triangles for the current child
  347|     45|		unsigned int *_pTriangles = (unsigned int*)malloc(3*childTriangleCounts[i]*sizeof(unsigned int));
  348|     45|		int k=0;
  349|  10.7k|        for (int j=0; j<nTriangles; j++)
  350|  10.7k|                if (codes[j] & (1<<i))
  351|  1.89k|				{
  352|  1.89k|                        _pTriangles[k++] = pTriangles[3*j];
  353|  1.89k|                        _pTriangles[k++] = pTriangles[3*j+1];
  354|  1.89k|                        _pTriangles[k++] = pTriangles[3*j+2];
  355|  1.89k|				}
  356|       |
  357|       |        // recurse
  358|     45|        m_pChildren[i] = new Octree ();
  359|     45|		m_pChildren[i]->m_pFather = this;
  360|     45|        m_pChildren[i]->BuildForTriangles(pPoints, nPoints, maxTriangles, maxDepth, _pTriangles, childTriangleCounts[i], currentDepth+1);
  361|       |
  362|       |        // cleaning
  363|     45|		free (_pTriangles);
  364|     45|	}
  365|       |
  366|      6|	return 0;
  367|     46|}
  368|       |
  369|       |
  370|       |void Octree::Dump (void)
  371|      0|{
  372|      0|	printf ("Stats :\n");
  373|      0|	printf ("number of leaves : %d\n", GetNLeaves ());
  374|      0|	printf ("max depth : %d\n", GetMaxDepth ());
  375|      0|}
  376|       |
  377|       |int Octree::GetKNeighbours (vec3 pt, float distance)
  378|      0|{
  379|      0|	if (m_nPoints)
  380|      0|	{
  381|      0|		vec3 tmp;
  382|      0|		int res = 0;
  383|      0|		for (int i=0; i<m_nPoints; i++)
  384|      0|		{
  385|      0|			vec3_init (tmp, m_pPoints[3*i], m_pPoints[3*i+1], m_pPoints[3*i+2]);
  386|      0|			if (vec3_distance (pt, tmp) < distance)
  387|      0|				res++;
  388|      0|		}
  389|      0|		return res;
  390|      0|	}
  391|      0|	else
  392|      0|	{
  393|      0|		int neighbours = 0;
  394|      0|	        for (int i=0; i<8; i++)
  395|      0|			if (m_pChildren[i])
  396|      0|			{
  397|      0|				if (pt[0] >= m_vecMin[0]-distance &&
  398|      0|				    pt[0] <= m_vecMax[0]+distance &&
  399|      0|				    pt[1] >= m_vecMin[1]-distance &&
  400|      0|				    pt[1] <= m_vecMax[1]+distance &&
  401|      0|				    pt[2] >= m_vecMin[2]-distance &&
  402|      0|				    pt[2] <= m_vecMax[2]+distance)
  403|      0|					neighbours += m_pChildren[i]->GetKNeighbours (pt, distance);
  404|      0|			}
  405|      0|		return neighbours;
  406|      0|	}
  407|      0|}
  408|       |
  409|       |int Octree::GetClosestPoints (vec3 pt, float distance, float **pNeighbours, unsigned int *nNeighbours)
  410|      0|{
  411|      0|	if (m_nPoints)
  412|      0|	{
  413|      0|		vec3 tmp;
  414|      0|		int res = 0;
  415|      0|		for (int i=0; i<m_nPoints; i++)
  416|      0|		{
  417|      0|			vec3_init (tmp, m_pPoints[3*i], m_pPoints[3*i+1], m_pPoints[3*i+2]);
  418|      0|			if (vec3_distance (pt, tmp) < distance)
  419|      0|			{
  420|      0|				if (*pNeighbours)
  421|      0|					(*pNeighbours) = (float*)malloc(3*(*nNeighbours)*sizeof(float));
  422|      0|				else
  423|      0|					(*pNeighbours) = (float*)realloc((*pNeighbours), 3*(*nNeighbours)*sizeof(float));
  424|      0|				(*pNeighbours)[3*(*nNeighbours)]   = tmp[0];
  425|      0|				(*pNeighbours)[3*(*nNeighbours)+1] = tmp[1];
  426|      0|				(*pNeighbours)[3*(*nNeighbours)+2] = tmp[2];
  427|      0|				(*nNeighbours)++;
  428|      0|				res++;
  429|      0|			}
  430|      0|		}
  431|      0|		return res;
  432|      0|	}
  433|      0|	else
  434|      0|	{
  435|      0|		int neighbours = 0;
  436|      0|		for (int i=0; i<8; i++)
  437|      0|			if (m_pChildren[i])
  438|      0|			{
  439|      0|				if (pt[0] >= m_vecMin[0]-distance &&
  440|      0|					pt[0] <= m_vecMax[0]+distance &&
  441|      0|					pt[1] >= m_vecMin[1]-distance &&
  442|      0|					pt[1] <= m_vecMax[1]+distance &&
  443|      0|					pt[2] >= m_vecMin[2]-distance &&
  444|      0|					pt[2] <= m_vecMax[2]+distance)
  445|      0|					neighbours += m_pChildren[i]->GetClosestPoints (pt, distance, pNeighbours, nNeighbours);
  446|      0|			}
  447|      0|			return neighbours;
  448|      0|	}
  449|      0|}
  450|       |
  451|       |int Octree::GetClosestIndicesPoints (float *pVertices, vec3 pt, float distance, unsigned int **pNeighbours, unsigned int *nNeighbours)
  452|      0|{
  453|      0|	if (m_nIndices)
  454|      0|	{
  455|      0|		vec3 tmp;
  456|      0|		int res = 0;
  457|      0|		for (int i=0; i<m_nIndices; i++)
  458|      0|		{
  459|      0|			unsigned int vi = m_pIndices[i];
  460|      0|			vec3_init (tmp, pVertices[3*vi], pVertices[3*vi+1], pVertices[3*vi+2]);
  461|      0|			if (vec3_distance (pt, tmp) < distance)
  462|      0|			{
  463|      0|				if (*pNeighbours)
  464|      0|					(*pNeighbours) = (unsigned int*)realloc((*pNeighbours), ((*nNeighbours)+1)*sizeof(unsigned int));
  465|      0|				else
  466|      0|					(*pNeighbours) = (unsigned int*)malloc((*nNeighbours)*sizeof(unsigned int));
  467|      0|				(*pNeighbours)[(*nNeighbours)] = vi;
  468|      0|				(*nNeighbours)++;
  469|      0|				res++;
  470|      0|			}
  471|      0|		}
  472|      0|		return res;
  473|      0|	}
  474|      0|	else
  475|      0|	{
  476|      0|		int neighbours = 0;
  477|      0|		for (int i=0; i<8; i++)
  478|      0|			if (m_pChildren[i])
  479|      0|			{
  480|      0|				if (pt[0] >= m_vecMin[0]-distance &&
  481|      0|					pt[0] <= m_vecMax[0]+distance &&
  482|      0|					pt[1] >= m_vecMin[1]-distance &&
  483|      0|					pt[1] <= m_vecMax[1]+distance &&
  484|      0|					pt[2] >= m_vecMin[2]-distance &&
  485|      0|					pt[2] <= m_vecMax[2]+distance)
  486|      0|					neighbours += m_pChildren[i]->GetClosestIndicesPoints (pVertices, pt, distance, pNeighbours, nNeighbours);
  487|      0|			}
  488|      0|			return neighbours;
  489|      0|	}
  490|      0|}
  491|       |
  492|       |int Octree::GetSumNeighbours (vec3 pt, float distance, vec3 accum)
  493|      0|{
  494|      0|	if (m_nPoints)
  495|      0|	{
  496|      0|		vec3 tmp;
  497|      0|		int res = 0;
  498|      0|		for (int i=0; i<m_nPoints; i++)
  499|      0|		{
  500|      0|			vec3_init (tmp, m_pPoints[3*i], m_pPoints[3*i+1], m_pPoints[3*i+2]);
  501|      0|			if (vec3_distance (pt, tmp) <= distance)
  502|      0|			{
  503|      0|				vec3_addition (accum, accum, tmp);
  504|      0|				res++;
  505|      0|			}
  506|      0|		}
  507|      0|		return res;
  508|      0|	}
  509|      0|	else
  510|      0|	{
  511|      0|		int neighbours = 0;
  512|      0|	        for (int i=0; i<8; i++)
  513|      0|			if (m_pChildren[i])
  514|      0|			{
  515|      0|				if (pt[0] >= m_vecMin[0]-distance &&
  516|      0|				    pt[0] <= m_vecMax[0]+distance &&
  517|      0|				    pt[1] >= m_vecMin[1]-distance &&
  518|      0|				    pt[1] <= m_vecMax[1]+distance &&
  519|      0|				    pt[2] >= m_vecMin[2]-distance &&
  520|      0|				    pt[2] <= m_vecMax[2]+distance)
  521|      0|					neighbours += m_pChildren[i]->GetSumNeighbours (pt, distance, accum);
  522|      0|			}
  523|      0|		return neighbours;
  524|      0|	}
  525|      0|}
  526|       |
  527|       |int Octree::GetNLeaves (void)
  528|      0|{
  529|      0|	if (IsLeaf())
  530|      0|		return 1;
  531|      0|	else
  532|      0|	{
  533|      0|		int res = 0;
  534|      0|		for (int i=0; i<8; i++)
  535|      0|			if (m_pChildren[i])
  536|      0|				res += m_pChildren[i]->GetNLeaves ();
  537|      0|		return res;
  538|      0|	}
  539|      0|}
  540|       |
  541|       |bool Octree::IsLeaf (void)
  542|   120k|{
  543|   715k|	for (int i=0; i<8; i++)
  544|   640k|		if (m_pChildren[i])
  545|  45.8k|			return false;
  546|       |
  547|  74.3k|	return true;
  548|   120k|}
  549|       |
  550|       |int Octree::GetMaxDepth (void)
  551|      0|{
  552|      0|	if (IsLeaf())
  553|      0|		return 0;
  554|      0|	else
  555|      0|	{
  556|      0|		int res = 0;
  557|      0|		for (int i=0; i<8; i++)
  558|      0|			if (m_pChildren[i])
  559|      0|			{
  560|      0|				 int tmp = 1+m_pChildren[i]->GetMaxDepth ();
  561|      0|				 if (res < tmp)
  562|      0|					 res = tmp;
  563|      0|			}
  564|      0|		return res;
  565|      0|	}
  566|      0|}
  567|       |
  568|       |/*
  569|       |//
  570|       |// iterator
  571|       |//
  572|       |OctreeIt::OctreeIt (const Octree *pOctree)
  573|       |{
  574|       |	m_pOctree = pOctree;
  575|       |	m_pOctreeCurrentOctree = m_pOctree;
  576|       |}
  577|       |
  578|       |OctreeIt::~OctreeIt ()
  579|       |{
  580|       |}
  581|       |
  582|       |Octree* OctreeIt::First ()
  583|       |{
  584|       |	if (m_nIndices)
  585|       |		return m_pOctree;
  586|       |
  587|       |	for (int i=0; i<8; i++)
  588|       |		if (m_pOctree->GetChildren()[i])
  589|       |			return m_pOctree->GetChildren()[i])->First ();
  590|       |
  591|       |	return NULL;
  592|       |}
  593|       |
  594|       |Octree* OctreeIt::Next ()
  595|       |{
  596|       |	if (m_pCurrentNode->m_pFather)
  597|       |	{
  598|       |		int i=0;
  599|       |		for (i=0; i<8; i++)
  600|       |		{
  601|       |			if (m_pChildren[i] == m_pCurrentNode)
  602|       |			{
  603|       |				i++;
  604|       |				break;
  605|       |			}
  606|       |			if (i<8)
  607|       |			{
  608|       |
  609|       |				return m_pChildren[i]->First();
  610|       |			}
  611|       |			else
  612|       |
  613|       |		}
  614|       |	}
  615|       |}
  616|       |
  617|       |bool OctreeIt::Last ()
  618|       |{
  619|       |	return (m_pCurrentNode->m_pFather);
  620|       |}
  621|       |*/

/workspaces/cg/src/cgmesh/octree.h:
    1|       |#ifndef __OCTREE_H__
    2|       |#define __OCTREE_H__
    3|       |
    4|       |#include "../cgmath/cgmath.h"
    5|       |
    6|       |class Octree
    7|       |{
    8|       |	friend class Mesh;
    9|       |public:
   10|       |	Octree ();
   11|       |	~Octree ();
   12|       |
   13|       |	void GetCenter (float center[3]) const;
   14|       |	void GetMinMax (float vecMin[3], float vecMax[3]) const;
   15|       |
   16|       |	// Fill the octree with the points
   17|       |	int Build (float *pPoints, int nPoints,
   18|       |		   unsigned int maxPoints,
   19|       |		   unsigned int maxDepth, unsigned int currentDepth = 0);
   20|       |
   21|       |
   22|       |	// Same as former, but use an array of indices
   23|       |	int BuildWithIndices (float *pPoints, int nPoints,
   24|       |			      unsigned int maxPoints, unsigned int maxDepth,
   25|       |			      unsigned int *pIndices = 0, int nIndices = 0, unsigned int currentDepth = 0);
   26|       |
   27|       |	// Fill the octree with the triangles
   28|       |	int BuildForTriangles (float *pPoints, int nPoints,
   29|       |			      unsigned int maxTriangles, unsigned int maxDepth,
   30|       |			      unsigned int *pTriangles, int nTriangles, unsigned int currentDepth = 0); // pTriangles contains indices
   31|       |
   32|   366k|	Octree** GetChildren (void) { return m_pChildren; };
   33|       |	int GetNLeaves (void);
   34|       |	bool IsLeaf (void);
   35|       |	int GetMaxDepth (void);
   36|       |
   37|       |	// deal with coordinates
   38|      0|	unsigned int GetNPoints (void) { return m_nPoints; };
   39|      0|	float* GetPoints (void) { return m_pPoints; };
   40|       |	int GetKNeighbours (vec3 pt, float distance);
   41|       |	int GetSumNeighbours (vec3 pt, float distance, vec3 accum);
   42|       |	int GetClosestPoints (vec3 pt, float distance, float **pNeighbours, unsigned int *nNeighbours);
   43|       |
   44|       |	// deal with indices
   45|      0|	unsigned int GetNIndices (void) { return m_nIndices; };
   46|      0|	unsigned int* GetIndices (void) { return m_pIndices; };
   47|       |	int GetClosestIndicesPoints (float *pVertices, vec3 pt, float distance, unsigned int **pNeighbours, unsigned int *nNeighbours);
   48|       |
   49|       |	// deal with triangles
   50|  74.3k|	unsigned int GetNTriangles (void) { return m_nTriangles; };
   51|  74.3k|	unsigned int* GetTriangles (void) { return m_pTriangles; };
   52|       |
   53|       |	void Dump (void);
   54|       |
   55|       |
   56|       |
   57|       |
   58|       |	//
   59|       |	// traverse
   60|       |	//
   61|       |	class Callback
   62|       |	{
   63|       |	public:
   64|       |		virtual bool operator()(Octree *pOctree, void *data) = 0; // Return value: true = continue; false = abort
   65|       |	};
   66|       |	void traverse(Callback* callback, void *data)
   67|      0|	{
   68|      0|		if(callback)
   69|      0|			traverseRecursive(callback, this, data);
   70|      0|	}
   71|       |	void traverseRecursive(Callback* callback, Octree *pOctree, void *data)
   72|      0|	{
   73|      0|		bool shouldContinue = callback->operator()(pOctree, data);
   74|      0|		if (!shouldContinue)
   75|      0|			return;
   76|      0|		for (int i=0; i<8; i++)
   77|      0|			if (pOctree->m_pChildren[i])
   78|      0|				traverseRecursive (callback, pOctree->m_pChildren[i], data);
   79|      0|	}    
   80|       |
   81|       |private:
   82|       |	void ComputeBounding (float *pPoints, int nPoints, float min[3], float max[3]);
   83|       |	void ComputeBoundingWithIndices (float *pPoints, int nPoints, unsigned int *pIndices, int nIndices, float min[3], float max[3]);
   84|       |	void ComputeBoundinForTriangles (float *pPoints, int nPoints, unsigned int *pTriangles, int nTriangles, float min[3], float max[3]);
   85|       |
   86|       |	Octree *m_pFather;
   87|       |	Octree *m_pChildren[8];
   88|       |	
   89|       |	// fill points
   90|       |	unsigned int m_nPoints;
   91|       |	float *m_pPoints;
   92|       |
   93|       |	// fill points by using indices
   94|       |	unsigned int m_nIndices;
   95|       |	unsigned int *m_pIndices;
   96|       |
   97|       |	// fill triangles
   98|       |	unsigned int m_nTriangles;
   99|       |	unsigned int *m_pTriangles;
  100|       |
  101|       |	float m_vecMin[3];
  102|       |	float m_vecMax[3];
  103|       |
  104|       |
  105|       |};
  106|       |
  107|       |/*
  108|       |class OctreeIt
  109|       |{
  110|       |public:
  111|       |	OctreeIt (const Octree *pOctree);
  112|       |	~OctreeIt ();
  113|       |	Octree* First ();
  114|       |	Octree* Next ();
  115|       |	bool Last ();
  116|       |private:
  117|       |	Octree *m_pOctree;
  118|       |	Octree *m_pCurrentOctree;
  119|       |};
  120|       |*/
  121|       |
  122|       |#endif // __OCTREE_H__

/workspaces/cg/src/cgmesh/particles_system.h:
    1|       |#ifndef __PARTICLES_SYSTEM_H__
    2|       |#define __PARTICLES_SYSTEM_H__
    3|       |
    4|       |/****************/
    5|       |/*** Particle ***/
    6|       |/****************/
    7|       |class CParticle
    8|       |{
    9|       |	friend class CParticles_system;
   10|       |public:
   11|       |	CParticle ();
   12|       |	~CParticle ();
   13|       |
   14|       |	void init (void);
   15|       |	void init_config1 (void);
   16|       |	void init_config2 (void);
   17|       |	void init_config3 (void);
   18|       |
   19|       |	// getters / setters
   20|       |	void set_position    (float par_x, float par_y, float par_z);
   21|       |	void get_position    (float *par_x, float *par_y, float *par_z);
   22|       |
   23|       |	void set_orientation (float par_xi, float par_yi, float par_zi);
   24|       |	void get_orientation (float *par_xi, float *par_yi, float *par_zi);
   25|       |
   26|       |	void set_color       (float par_r, float par_g, float par_b);
   27|       |	void get_color       (float *par_r, float *par_g, float *par_b);
   28|       |
   29|       |	void set_gravity     (float par_xg, float par_yg, float par_zg);
   30|       |	void get_gravity     (float *par_xg, float *par_yg, float *par_zg);
   31|       |
   32|       |	void set_life        (float par_life);
   33|       |	void get_life        (float *par_life);
   34|       |
   35|       |	void set_fade        (float par_fade);
   36|       |	void get_fade        (float *par_fade);
   37|       |
   38|       |	void set_active      (int par_active);
   39|       |	int  is_active       (void);
   40|       |
   41|       |private:
   42|       |	float m_x, m_y, m_z;    // position
   43|       |	float m_r, m_g, m_b;    // color
   44|       |	float m_xi, m_yi, m_zi; // orientation
   45|       |	float m_xg, m_yg, m_zg; // gravity
   46|       |	int	m_active;			// active or not
   47|       |	float m_life;			// life of the particle
   48|       |	float m_fade;			// fade speed
   49|       |};
   50|       |
   51|       |
   52|       |/************************/
   53|       |/*** Particles system ***/
   54|       |/************************/
   55|       |class CParticles_system
   56|       |{
   57|       |public:
   58|       |	CParticles_system (int par_n);
   59|       |	~CParticles_system ();
   60|       |
   61|       |	//int  attach_texture (unsigned int &par_texture, int par_type);
   62|       |
   63|       |	//void draw (void);
   64|       |	void next (void);
   65|       |
   66|      0|	int get_n_particles (void) { return m_n_particles; };
   67|      0|	CParticle** get_particles (void) { return m_particles; };
   68|       |
   69|       |private:
   70|       |	int m_n_particles;
   71|       |	CParticle **m_particles;
   72|       |
   73|       |	float m_slowdown; // slow down particles
   74|       |	int m_col;        // current color selection
   75|       |	int m_delay;      // rainbow effect delay
   76|       |};
   77|       |
   78|       |#endif // __PARTICLES_SYSTEM_H__

/workspaces/cg/src/cgmesh/points_strange_attractor.h:
    1|       |#ifndef __STRANGE_ATTRACTOR_H__
    2|       |#define __STRANGE_ATTRACTOR_H__
    3|       |
    4|       |#include <stdio.h>
    5|       |
    6|       |class StrangeAttractor
    7|       |{
    8|       |public:
    9|      0|	StrangeAttractor () { x = y = z = 0.0; };
   10|      0|	~StrangeAttractor () {};
   11|       |
   12|       |	virtual void set_origin (double xorig, double yorig, double zorig = 0.0);
   13|      0|	virtual double getX (void) { return x; };
   14|      0|	virtual double getY (void) { return y; };
   15|      0|	virtual double getZ (void) { return z; };
   16|      0|	bool get_signature (char **signature, int *length) { *signature = 0; *length = 0; return true; };
   17|       |
   18|      0|	virtual void next (void) {};
   19|       |	
   20|       |	void export_obj (char *filename, unsigned int npts);
   21|       |	void export_asc (char *filename, unsigned int npts);
   22|       |protected:
   23|       |	double random_parameter (void);
   24|       |	char   random_signature (void);
   25|       |
   26|       |	double convert (char c);
   27|       |
   28|       |	double x, y, z;
   29|       |};
   30|       |
   31|       |#endif // __STRANGE_ATTRACTOR_H__

/workspaces/cg/src/cgmesh/points_strange_attractor_cubicmaps.h:
    1|       |#ifndef __POINTS_STRANGE_ATTRACTOR_CUBICMAPS_H__
    2|       |#define __POINTS_STRANGE_ATTRACTOR_CUBICMAPS_H__
    3|       |
    4|       |#include "points_strange_attractor.h"
    5|       |
    6|       |class StrangeAttractor_CubicMaps : public StrangeAttractor
    7|       |{
    8|       |public:
    9|      0|	StrangeAttractor_CubicMaps () {};
   10|       |	void set_parameters (double _a1, double _a2, double _a3, double _a4, double _a5,
   11|       |			     double _a6, double _a7, double _a8, double _a9, double _a10,
   12|       |			     double _a11, double _a12, double _a13, double _a14, double _a15,
   13|       |			     double _a16, double _a17, double _a18, double _a19, double _a20);
   14|       |	void next (void);
   15|       |	
   16|       |private:
   17|       |	double a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20;
   18|       |};
   19|       |
   20|       |#endif // __POINTS_STRANGE_ATTRACTOR_CUBICMAPS_H__

/workspaces/cg/src/cgmesh/points_strange_attractor_pickover.h:
    1|       |#ifndef __POINTS_STRANGE_ATTRACTOR_PICKOVER_H__
    2|       |#define __POINTS_STRANGE_ATTRACTOR_PICKOVER_H__
    3|       |
    4|       |#include "points_strange_attractor.h"
    5|       |
    6|       |class StrangeAttractor_Pickover : public StrangeAttractor
    7|       |{
    8|       |public:
    9|      0|	StrangeAttractor_Pickover () {};
   10|       |	void set_parameters (double _a, double _b, double _c, double _d);
   11|       |	void next (void);
   12|       |
   13|       |private:
   14|       |	double a, b, c, d;
   15|       |};
   16|       |
   17|       |#endif // __POINTS_STRANGE_ATTRACTOR_PICKOVER_H__

/workspaces/cg/src/cgmesh/points_strange_attractor_quadraticmaps.h:
    1|       |#ifndef __POINTS_STRANGE_ATTRACTOR_QUADRATICMAPS_H__
    2|       |#define __POINTS_STRANGE_ATTRACTOR_QUADRATICMAPS_H__
    3|       |
    4|       |#include "points_strange_attractor.h"
    5|       |
    6|       |/**
    7|       |*
    8|       |* Examples:
    9|       |*
   10|       |* AGHNFODVNJCP (-1.2, -0.6, -0.5,  0.1, -0.7,  0.2, -0.9,  0.9,  0.1, -0.3, -1.0,  0.3)
   11|       |* BCQAFMFVPXKQ (-1.1, -1.0,  0.4, -1.2, -0.7,  0.0, -0.7,  0.9,  0.3,  1.1, -0.2,  0.4)
   12|       |* DSYUECINGQNV (-0.9,  0.6,  1.2,  0.8, -0.8, -1.0, -0.4,  0.1, -0.6,  0.4,  0.1,  0.9) 
   13|       |* ELXAPXMPQOBT (-0.8, -0.1,  1.1, -1.2,  0.3,  1.1,  0.0,  0.3,  0.4,  0.2, -1.1,  0.7) 
   14|       |* EYYMKTUMXUVC (-0.8,  1.2,  1.2,  0.0, -0.2,  0.7,  0.8,  0.0,  1.1,  0.8,  0.9, -1.0) 
   15|       |* JTTSMBOGLLQF (-0.3,  0.7,  0.7,  0.6,  0.0, -1.1,  0.2, -0.6, -0.1, -0.1,  0.4, -0.7) 
   16|       |* OUGFJKDHSAJU ( 0.2,  0.8, -0.6, -0.7, -0.3, -0.2, -0.9, -0.5,  0.6, -1.2, -0.3,  0.8) 
   17|       |* QKOCSIDVTPGY
   18|       |*
   19|       |*/
   20|       |
   21|       |class StrangeAttractor_QuadraticMaps : public StrangeAttractor
   22|       |{
   23|       |public:
   24|      0|	StrangeAttractor_QuadraticMaps () {};
   25|       |	void set_parameters (double _a1, double _a2, double _a3, double _a4, double _a5, double _a6,
   26|       |						 double _a7, double _a8, double _a9, double _a10, double _a11, double _a12);
   27|       |	void set_parameters (char signature[12]);
   28|       |
   29|       |	void next (void);
   30|       |	
   31|       |private:
   32|       |	double a[12];
   33|       |};
   34|       |
   35|       |#endif // __POINTS_STRANGE_ATTRACTOR_QUADRATICMAPS_H__

/workspaces/cg/src/cgmesh/points_strange_attractor_quadraticmaps3D.h:
    1|       |#ifndef __POINTS_STRANGE_ATTRACTOR_QUADRATICMAPS3D_H__
    2|       |#define __POINTS_STRANGE_ATTRACTOR_QUADRATICMAPS3D_H__
    3|       |
    4|       |#include "points_strange_attractor.h"
    5|       |
    6|       |class StrangeAttractor_QuadraticMaps3D : public StrangeAttractor
    7|       |{
    8|       |public:
    9|      0|	StrangeAttractor_QuadraticMaps3D () {};
   10|       |	void set_parameters (double _a0, double _a1, double _a2, double _a3, double _a4, double _a5,
   11|       |			     double _a6, double _a7, double _a8, double _a9, double _a10, double _a11,
   12|       |			     double _a12, double _a13, double _a14, double _a15, double _a16, double _a17);
   13|       |	void set_parameters (char signature[18]);
   14|       |	void set_parameters_random (void);
   15|       |	void set_signature_random  (void);
   16|       |
   17|       |	bool get_signature (char **signature, int *length);
   18|       |
   19|       |	void next (void);
   20|       |	
   21|       |private:
   22|       |	char   s[18];
   23|       |	double a[18];
   24|       |};
   25|       |
   26|       |#endif // __POINTS_STRANGE_ATTRACTOR_QUADRATICMAPS3D_H__

/workspaces/cg/src/cgmesh/polygon2.h:
    1|       |#ifndef __POLYGON2_H__
    2|       |#define __POLYGON2_H__
    3|       |
    4|       |#define SIGNATURE_DEVIATION 0
    5|       |#define SIGNATURE_CURVATURE 1
    6|       |#define SIGNATURE_BOUTIN    2
    7|       |
    8|       |#define INTERPOLATION_LINEAR 0
    9|       |#define INTERPOLATION_COSINE 1
   10|       |
   11|       |//
   12|       |// Contour 2D
   13|       |//
   14|       |class Polygon2
   15|       |{
   16|       |public:
   17|       |	Polygon2 ();
   18|       |	Polygon2 (const Polygon2 &pol);
   19|       |	~Polygon2 ();
   20|       |
   21|       |	Polygon2 &operator=(const Polygon2 &pol);
   22|       |
   23|       |	// input
   24|       |	void input (float *pPoints, int n);
   25|       |	void input (float *x, float *y, int n);
   26|       |	void input (Polygon2 *contour, int interpolation_type, int nn); // parameterize an existing contour
   27|       |	void input (char *filename);
   28|       |private:
   29|       |	void input_from_svg_path (char *path);
   30|       |
   31|       |public:
   32|       |	// edit
   33|       |	float* add_contour (unsigned int index, unsigned int nPoints, float *pPoints);
   34|       |	int add_polygon2d (Polygon2 *pol);
   35|       |
   36|       |	// output
   37|       |	void dump ();
   38|       |	void output (char *filename);
   39|       |
   40|       |	int set_point (unsigned int iContour, unsigned int iPoint, float x, float y);
   41|       |	int get_point (unsigned int iContour, unsigned int iPoint, float *x, float *y);
   42|       |
   43|      0|	int    get_n_contours (void) { return m_nContours; };
   44|      0|	float* get_points (unsigned int iContour) { return m_pPoints[iContour]; };
   45|      0|	int    get_n_points (unsigned int iContour) { return m_nPoints[iContour]; };
   46|      0|	int    get_n_points (void) {
   47|      0|		int nPoints = 0;
   48|      0|		for (unsigned int i=0; i<m_nContours; i++)
   49|      0|			nPoints += get_n_points (i);
   50|      0|		return nPoints; };
   51|       |	
   52|       |	void  get_bbox (float *xmin, float *xmax, float *ymin, float *ymax);
   53|       |	float length (int interpolation_type);
   54|       |	float area   (void);
   55|       |	float area   (int i1, int i2, int i3);
   56|       |	
   57|       |	void smooth (void);
   58|       |	void flip_x (void);
   59|       |	void apply_PCA (void);
   60|       |	void translate (float tx, float ty);
   61|       |	void rotate (float angle);
   62|       |	void centerize (void);
   63|       |	void center (float *xc, float *yc);
   64|       |	
   65|       |	int is_point_inside (float x, float y);
   66|       |
   67|       |	// order of the points
   68|       |	void inverse_order (void);
   69|       |	int  is_trigonometric_order (void);
   70|       |	
   71|       |	int  generalized_barycentric_coordinates (float pt[2], float *coords);
   72|       |
   73|       |	// moments
   74|       |	void moment_0 (float m[1]);
   75|       |	void moment_1 (float m[2]);
   76|       |	void moment_2 (float m[3], bool centralized=false);
   77|       |	void moment_3 (float m[4]);
   78|       |	
   79|       |	// symmetry
   80|       |	void search_symmetry_zabrodsky (float *xc, float *yc, float *angle);
   81|       |	void search_symmetry_signature (int signature_type, int interpolation_type, int nbins);
   82|       |	void search_symmetry_pridmore (void);
   83|       |	void search_symmetry_pridmore_bis (void);
   84|       |	
   85|       |	// matching
   86|       |	float matching_arkin (Polygon2 *contour, int nn);
   87|       |	
   88|       |	// clean a polygon
   89|       |	int clean (Polygon2* polygon);
   90|       |
   91|       |	// tesselation
   92|       |	int tesselate (float **pVertices, unsigned int *nVertices,
   93|       |		       unsigned int **pFaces, unsigned int *nFaces);
   94|       |
   95|       |	void thicken (Polygon2* polygon, float ithickness, float othickness, int bOpen=1);
   96|       |	void dilate (Polygon2* polygon, float d);
   97|       |
   98|       |	void extrude (float fHeight, char *filename);
   99|       |	
  100|       |//private:
  101|       |	int alloc_contours (int nContours);
  102|       |	
  103|       |	//
  104|       |	unsigned int m_nContours;
  105|       |	unsigned int *m_nPoints;
  106|       |	float **m_pPoints;
  107|       |};
  108|       |
  109|       |
  110|       |#endif // __POLYGON2_H__

/workspaces/cg/src/cgmesh/polygon3.h:
    1|       |#ifndef __POLYGON3_H__
    2|       |#define __POLYGON3_H__
    3|       |
    4|       |#include "../cgmath/cgmath.h"
    5|       |
    6|       |class Polygon3
    7|       |{
    8|       |public:
    9|       |	Polygon3 ();
   10|       |	~Polygon3 ();
   11|       |
   12|       |	int add_contour (unsigned int index, unsigned int nPoints, float *pPoints);
   13|       |
   14|      0|	unsigned int GetNContours (void) { return m_nContours; };
   15|      0|	unsigned int GetNPoints (unsigned int i) { return m_nPoints[i]; };
   16|      0|	float* GetPoints (unsigned int i) { return m_pPoints[i]; };
   17|       |	inline void GetPoint (unsigned int ci, unsigned int vi, vec3 pt)
   18|      0|		{
   19|      0|			vec3_init (pt, m_pPoints[ci][3*vi], m_pPoints[ci][3*vi+1], m_pPoints[ci][3*vi+2]);
   20|      0|		};
   21|       |	void GetBBox (vec3 min, vec3 max);
   22|       |
   23|       |	void Dump (void);
   24|       |
   25|       |private:
   26|       |	unsigned int m_nContours;
   27|       |	unsigned int *m_nPoints;
   28|       |	float **m_pPoints;
   29|       |};
   30|       |
   31|       |#endif // __POLYGON3_H__

/workspaces/cg/src/cgmesh/raytracer.cpp:
    1|       |#include <stdlib.h>
    2|       |#include <stdio.h>
    3|       |
    4|       |#include "../cgmesh/cgmesh.h"
    5|       |#include "raytracer.h"
    6|       |
    7|       |Raytracer::Raytracer ()
    8|      4|{
    9|      4|	m_pScene = new Scene ();
   10|      4|	m_pCamera = new Camera ();
   11|      4|	m_pLights[0] = new Light ();
   12|      4|	m_nLights = 1;
   13|       |
   14|      4|	m_time_GetColorWithRay = 0.;
   15|      4|	m_time_GetIntersectionWithRay = 0.;
   16|      4|}
   17|       |
   18|       |Raytracer::~Raytracer ()
   19|      4|{
   20|      8|	for (unsigned int i=0; i<m_nLights; i++)
   21|      4|		delete m_pLights[i];
   22|      4|	if (m_pCamera)
   23|      4|		delete m_pCamera;
   24|      4|	if (m_pScene)
   25|      4|		delete m_pScene;
   26|      4|}
   27|       |
   28|       |unsigned int Raytracer::AddLight (Light* pLight)
   29|      0|{
   30|      0|	m_pLights[m_nLights] = pLight;
   31|      0|	unsigned int idLight = m_nLights++;
   32|      0|	return idLight;
   33|      0|}
   34|       |
   35|       |//
   36|       |// Phong shading
   37|       |// http://en.wikipedia.org/wiki/Phong_shading
   38|       |//
   39|       |int Raytracer::GetColorWithRay (vec3 vOrig, vec3 vDirection, float color[3])
   40|  65.5k|{
   41|  65.5k|	vec3 vIntersection, vN;
   42|  65.5k|	Ticker t;
   43|  65.5k|	color[0] = 0.;
   44|  65.5k|	color[1] = 0.;
   45|  65.5k|	color[2] = 0.;
   46|       |
   47|  65.5k|	Geometry *pObject = GetScene()->GetIntersectionWithRay (vOrig, vDirection, vIntersection, vN);
   48|  65.5k|	m_time_GetIntersectionWithRay += t.stop ();
   49|  65.5k|	if (!pObject)
   50|  47.6k|		return 0;
   51|       |
   52|       |	// todo : check what type of material it is
   53|  17.8k|	MaterialColorExt* pMaterial = (MaterialColorExt*)pObject->GetMaterial ();
   54|       |
   55|  17.8k|	if (pMaterial == nullptr)
   56|  10.0k|	{
   57|       |		// default material
   58|  10.0k|		pMaterial = new MaterialColorExt();
   59|  10.0k|		pMaterial->SetAmbient(0.7, 0.1, 0.3, 1.f);
   60|  10.0k|		pMaterial->SetDiffuse(0.7, 0.3, 0.2, 1.f);
   61|  10.0k|		pMaterial->SetSpecular(0.5, 0.1, 0.1, 1.f);
   62|       |
   63|       |		// TODO : fix memory leak...
   64|  10.0k|	}
   65|       |
   66|       |	//MaterialColorExt *pMaterial = new MaterialColorExt ();//pObject->m_pMaterial;
   67|       |	//pMaterial->Init_From_Library (MaterialColorExt::EMERALD);
   68|  17.8k|	float Ia, Id, Is;
   69|       |
   70|  17.8k|	vec3_normalize (vN);
   71|       |
   72|  35.6k|	for (unsigned int i=0; i<m_nLights; i++)
   73|  17.8k|	{
   74|  35.6k|		for (unsigned int j=0; j<RAYTRACER_SHADOWS_NUMBER_RAYS_PER_PIXEL; j++)
   75|  17.8k|		{
   76|  17.8k|			float vLight[3];
   77|  17.8k|			vLight[0] = m_pLights[i]->Position[0];
   78|  17.8k|			vLight[1] = m_pLights[i]->Position[1];
   79|  17.8k|			vLight[2] = m_pLights[i]->Position[2];
   80|  17.8k|			if (RAYTRACER_SHADOWS_NUMBER_RAYS_PER_PIXEL > 1)
   81|      0|			{
   82|      0|				vLight[0] += 0.5*RAYTRACER_SHADOWS_LIGHT_POSITION_OFFSET*((float)rand()/(RAND_MAX+1.0));
   83|      0|				vLight[1] += 0.5*RAYTRACER_SHADOWS_LIGHT_POSITION_OFFSET*((float)rand()/(RAND_MAX+1.0));
   84|      0|				vLight[2] += 0.5*RAYTRACER_SHADOWS_LIGHT_POSITION_OFFSET*((float)rand()/(RAND_MAX+1.0));
   85|      0|			}
   86|       |
   87|  17.8k|			vec3 vL; // intersection -> light
   88|  17.8k|			vL[0] = vLight[0] - vIntersection[0];
   89|  17.8k|			vL[1] = vLight[1] - vIntersection[1];
   90|  17.8k|			vL[2] = vLight[2] - vIntersection[2];
   91|  17.8k|			float fL2 = vec3_dot_product (vL, vL);
   92|  17.8k|			vec3_normalize (vL);
   93|       |				
   94|  17.8k|			vec3 vR;
   95|  17.8k|			float fDotNL = vec3_dot_product (vN, vL);
   96|  17.8k|			if (fDotNL < 0.)
   97|  2.11k|				fDotNL = 0.;
   98|       |				
   99|  17.8k|			vR[0] = 2.*fDotNL*vN[0]-vL[0];
  100|  17.8k|			vR[1] = 2.*fDotNL*vN[1]-vL[1];
  101|  17.8k|			vR[2] = 2.*fDotNL*vN[2]-vL[2];
  102|  17.8k|			vec3_normalize (vR);
  103|       |				
  104|  17.8k|			vec3 vV;
  105|  17.8k|			vV[0] = -vDirection[0];
  106|  17.8k|			vV[1] = -vDirection[1];
  107|  17.8k|			vV[2] = -vDirection[2];
  108|  17.8k|			vec3_normalize (vV);
  109|       |				
  110|       |			// todo : store the following parameters in the material
  111|  17.8k|			float m_fDiffuseReflectionConstant = 0.5;
  112|  17.8k|			float m_fAmbientReflectionConstant = 0.3;
  113|  17.8k|			float m_fSpecularReflectionConstant = 0.5;
  114|  17.8k|			float m_fShininess = 10.;
  115|       |			//
  116|       |
  117|  17.8k|			float fDotRV = vec3_dot_product (vR, vV);
  118|  17.8k|			float fDotRValpha = (fDotRV < 0.)? 0. : pow ((float)(fDotRV), (float)(m_fShininess));
  119|  17.8k|			Ia = m_fAmbientReflectionConstant;
  120|  17.8k|			Id = m_fDiffuseReflectionConstant * fDotNL;
  121|  17.8k|			Is = m_fSpecularReflectionConstant * fDotRValpha;
  122|       |				
  123|  17.8k|			float fIntensity = Ia + Id + Is;
  124|       |				
  125|  17.8k|			float vIntersectionOffset[3];
  126|  17.8k|			float fOffset = 0.0001;
  127|  17.8k|			vIntersectionOffset[0] = vIntersection[0] + fOffset*vL[0];
  128|  17.8k|			vIntersectionOffset[1] = vIntersection[1] + fOffset*vL[1];
  129|  17.8k|			vIntersectionOffset[2] = vIntersection[2] + fOffset*vL[2];
  130|       |
  131|  17.8k|			color[0] += Ia*pMaterial->m_fAmbient[0] + Id*pMaterial->m_fDiffuse[0] + Is*pMaterial->m_fSpecular[0];
  132|  17.8k|			color[1] += Ia*pMaterial->m_fAmbient[1] + Id*pMaterial->m_fDiffuse[1] + Is*pMaterial->m_fSpecular[1];
  133|  17.8k|			color[2] += Ia*pMaterial->m_fAmbient[2] + Id*pMaterial->m_fDiffuse[2] + Is*pMaterial->m_fSpecular[2];
  134|       |				
  135|  17.8k|			float vIntersection2[3], vNormal2[3];
  136|       |			//Geometry *pObject2 = GetScene()->GetIntersectionWithSegment (vIntersectionOffset, m_pLights[i]->m_vPosition,
  137|       |			//							     vIntersection2, vNormal2);
  138|  17.8k|			t.start ();
  139|  17.8k|			Geometry *pObject2 = NULL;//GetScene()->GetIntersectionWithRay (vIntersectionOffset, vL, vIntersection2, vNormal2);
  140|  17.8k|			m_time_GetIntersectionWithRay += t.stop ();
  141|  17.8k|			if (pObject2)
  142|      0|			{
  143|      0|				vec3 vTmp;
  144|      0|				vTmp[0] = vIntersection2[0] - vIntersection[0];
  145|      0|				vTmp[1] = vIntersection2[1] - vIntersection[1];
  146|      0|				vTmp[2] = vIntersection2[2] - vIntersection[2];
  147|      0|				float l2 = vec3_dot_product (vTmp, vTmp);
  148|      0|				if (pObject2 && l2 > fL2)
  149|      0|				{
  150|       |					//float fIntensity = dot_product (vNormal, vL);
  151|      0|					color[0] += /*Ia*pMaterial->m_fAmbient[0] + */Id*pMaterial->m_fDiffuse[0] + Is*pMaterial->m_fSpecular[0];
  152|      0|					color[1] += /*Ia*pMaterial->m_fAmbient[1] + */Id*pMaterial->m_fDiffuse[1] + Is*pMaterial->m_fSpecular[1];
  153|      0|					color[2] += /*Ia*pMaterial->m_fAmbient[2] + */Id*pMaterial->m_fDiffuse[2] + Is*pMaterial->m_fSpecular[2];
  154|      0|				}
  155|      0|			}
  156|  17.8k|		}
  157|       |
  158|  17.8k|		color[0] /= RAYTRACER_SHADOWS_NUMBER_RAYS_PER_PIXEL;
  159|  17.8k|		color[1] /= RAYTRACER_SHADOWS_NUMBER_RAYS_PER_PIXEL;
  160|  17.8k|		color[2] /= RAYTRACER_SHADOWS_NUMBER_RAYS_PER_PIXEL;
  161|       |
  162|  17.8k|		if (color[0] > 1.) color[0] = 1.;
  163|  17.8k|		if (color[1] > 1.) color[1] = 1.;
  164|  17.8k|		if (color[2] > 1.) color[2] = 1.;
  165|  17.8k|	}
  166|       |
  167|  17.8k|	return 1;
  168|  65.5k|}
  169|       |
  170|       |Img* Raytracer::Trace (unsigned int iWidth, unsigned int iHeight)
  171|      4|{
  172|      4|	Ticker t;
  173|       |
  174|      4|	Img *pImg = new Img (iWidth, iHeight, false);
  175|       |
  176|       |	//
  177|      4|	if (0) // orthographic
  178|      0|	{
  179|      0|		float width = 20.;
  180|      0|		float height = 20.;
  181|      0|		for (unsigned int j=0; j<iHeight; j++)
  182|      0|		{
  183|      0|			for (unsigned int i=0; i<iWidth; i++)
  184|      0|			{
  185|      0|				vec3 vD;
  186|      0|				vD[0] = 0.;
  187|      0|				vD[1] = 0.4;
  188|      0|				vD[2] = -0.1;
  189|      0|				vec3_normalize (vD);
  190|       |				
  191|      0|				float vEye[3];
  192|      0|				vEye[0] = -width/2. + i*width/iWidth;
  193|      0|				vEye[1] = 0.;
  194|      0|				vEye[2] = height/2. - j*height/iHeight;
  195|       |				
  196|       |				// transform vD in local frame
  197|      0|				vEye[1] = -10.;
  198|      0|				vEye[2] += height/2.;
  199|       |
  200|       |				// is there an interection between the ray and the geometry
  201|      0|				float vIntersection[3], vNormal[3], color[3];
  202|      0|				Ticker t;
  203|      0|				GetColorWithRay (vEye, vD, color);
  204|      0|				m_time_GetColorWithRay += t.stop ();
  205|      0|			}
  206|      0|		}
  207|      0|	}
  208|      4|	else // perspective
  209|      4|	{
  210|      4|		float width_aov = M_PI/8.;
  211|      4|		float height_aov = M_PI/8.;
  212|    516|		for (unsigned int j=0; j<iHeight; j++)
  213|    512|		{
  214|  66.0k|			for (unsigned int i=0; i<iWidth; i++)
  215|  65.5k|			{
  216|       |				// spherical coordinates
  217|  65.5k|				float fTheta = (M_PI + width_aov)/2. - i*width_aov/iWidth;
  218|  65.5k|				float fPhi = height_aov/2. - j*height_aov/iHeight;
  219|       |				
  220|       |				// cartesian coordinates
  221|  65.5k|				vec3 vD;
  222|  65.5k|				vD[0] = cos(fTheta)*cos(fPhi);
  223|  65.5k|				vD[1] = sin(fTheta)*cos(fPhi);
  224|  65.5k|				vD[2] = sin(fPhi);
  225|  65.5k|				vec3_normalize (vD);
  226|       |				
  227|  65.5k|				float vEye[3];
  228|  65.5k|				vEye[0] = GetCamera()->m_vPosition[0];
  229|  65.5k|				vEye[1] = GetCamera()->m_vPosition[1];
  230|  65.5k|				vEye[2] = GetCamera()->m_vPosition[2];
  231|       |				
  232|       |				
  233|  65.5k|				Ticker t;
  234|  65.5k|				float color[3];
  235|  65.5k|				if (!GetColorWithRay (vEye, vD, color))
  236|  47.6k|				{
  237|       |					// no intersection => set background
  238|  47.6k|					color[0] = 1.;
  239|  47.6k|					color[1] = 1.;
  240|  47.6k|					color[2] = 1.;
  241|  47.6k|				}
  242|  65.5k|				m_time_GetColorWithRay += t.stop();
  243|  65.5k|				pImg->set_pixel (i, j, (int)(color[0]*255.), (int)(color[1]*255.), (int)(color[2]*255.), 255);
  244|  65.5k|			}
  245|    512|		}
  246|      4|	}
  247|       |
  248|      4|	printf ("Total elapsed time : %fs\n", t.stop ()/1000.);
  249|       |
  250|      4|	return pImg;
  251|      4|}
  252|       |
  253|       |void Raytracer::Dump ()
  254|      0|{
  255|       |	//printf ("nLights : %d\n", m_nLights);
  256|      0|	printf ("GetColorWithRay        : %f\n", m_time_GetColorWithRay);
  257|      0|	printf ("GetIntersectionWithRay : %f\n", m_time_GetIntersectionWithRay);
  258|      0|}
  259|       |
  260|       |void Raytracer::export_statistics (char *filename)
  261|      0|{
  262|      0|	FILE *ptr = fopen (filename, "w");
  263|      0|	if (!ptr)
  264|      0|		return;
  265|       |
  266|      0|	fprintf (ptr, "<html>\n");
  267|       |
  268|      0|	fprintf (ptr, "<head><title></title></head>\n");
  269|       |
  270|      0|	fprintf (ptr, "<body>\n");
  271|       |
  272|      0|	fprintf (ptr, "<p>m_time_GetColorWithRay : %.3f sec\n", m_time_GetColorWithRay/1000);
  273|      0|	fprintf (ptr, "<p>m_time_GetIntersectionWithRay : %.3f sec\n", m_time_GetIntersectionWithRay/1000);
  274|       |
  275|       |
  276|      0|	fprintf (ptr, "<p>m_i_GetIntersectionBboxWithRay_count : %d\n", m_pScene->m_i_GetIntersectionBboxWithRay_count);
  277|      0|	fprintf (ptr, "<p>m_i_GetIntersectionWithRay_count : %d\n", m_pScene->m_i_GetIntersectionWithRay_count);
  278|       |
  279|       |
  280|      0|	fprintf (ptr, "</body>\n");
  281|      0|	fprintf (ptr, "</html>\n");
  282|       |
  283|      0|	fclose (ptr);
  284|      0|}
  285|       |
  286|       |

/workspaces/cg/src/cgmesh/raytracer.h:
    1|       |#ifndef __RAYTRACER_H__
    2|       |#define __RAYTRACER_H__
    3|       |
    4|       |#include "../cgimg/cgimg.h"
    5|       |#include "../cgmesh/cgmesh.h"
    6|       |#include "scene.h"
    7|       |#include "camera.h"
    8|       |
    9|       |// Shadows
   10|       |static unsigned int RAYTRACER_SHADOWS_NUMBER_RAYS_PER_PIXEL = 1; // 600;
   11|       |static float        RAYTRACER_SHADOWS_LIGHT_POSITION_OFFSET = 20.;
   12|       |
   13|       |//
   14|       |// raytracer
   15|       |//
   16|       |class Raytracer
   17|       |{
   18|       |public:
   19|       |	Raytracer ();
   20|       |	~Raytracer ();
   21|       |
   22|       |	// set up methods
   23|   196k|	inline Camera* GetCamera (void) { return m_pCamera; };
   24|  65.5k|	inline Scene* GetScene (void) { return m_pScene; };
   25|      4|	inline Light* GetLight (unsigned int i) { return m_pLights[i]; };
   26|       |	unsigned int AddLight (Light* pLight);
   27|       |
   28|       |	// ray tracing process
   29|       |	Img* Trace (unsigned int iWidth, unsigned int iHeight);
   30|       |
   31|       |	// dump
   32|       |	void Dump (void);
   33|       |	void export_statistics (char *filename);
   34|       |
   35|       |private:
   36|       |	int GetColorWithRay (float vOrig[3], float vDirection[3], float color[3]);
   37|       |
   38|       |private:
   39|       |	Camera *m_pCamera;      // camera
   40|       |	unsigned int m_nLights; // number of lights
   41|       |	Light *m_pLights[8];    // description of the lights in the scene
   42|       |	Scene *m_pScene;        // contains the description of the geometric objects
   43|       |
   44|       |	// benchmarks
   45|       |	double m_time_GetColorWithRay;
   46|       |	double m_time_GetIntersectionWithRay;
   47|       |};
   48|       |
   49|       |#endif // __RAYTRACER_H__

/workspaces/cg/src/cgmesh/regions_faces.h:
    1|       |#ifndef __REGIONS_FACES_H__
    2|       |#define __REGIONS_FACES_H__
    3|       |
    4|       |#include "mesh_half_edge.h"
    5|       |#include "geometric_primitives.h"
    6|       |
    7|       |class Cregions_faces
    8|       |{
    9|       |  friend class Cmodel3d_geometric_primitive;
   10|       |  
   11|       | public:
   12|       |  Cregions_faces (Mesh_half_edge *mesh_half_edge);
   13|       |  ~Cregions_faces ();
   14|       |
   15|       |  void init_segmentation (float epsilon);
   16|       |  void init (float *datas, int size);
   17|       |  void clean_segmentation (float percentage);
   18|       |
   19|       |  // getters
   20|      0|  int get_size (void) { return size; };
   21|       |
   22|       |  int *get_selected_region (void);
   23|       |  int *get_regions (void);
   24|       |  Mesh_half_edge *get_mesh_half_edge (void);
   25|       |
   26|       |  // update the colors in the model
   27|       |  void refresh_colors (void);
   28|       |  
   29|       |  // selection
   30|       |  void select_faces_by_id_region (int id);
   31|       |  void select_face (int id);
   32|       |  void deselect_face (int id);
   33|       |  void select_faces (int id);
   34|       |  void deselect_faces (int id);
   35|       |  void deselect (void);
   36|       |
   37|       |  // export methods
   38|       |  void export_selected_region_cloud_points (char *filename);
   39|       |
   40|       |  //
   41|       |  // algorithms
   42|       |  //
   43|       |
   44|       |  // morphological operators
   45|       |  void dilate_regions (void);
   46|       |  void erode_regions (void);
   47|       |  void opening_regions (void);
   48|       |  void closing_regions (void);
   49|       |  void delete_isolated_regions (void);
   50|       |
   51|       |  void dilate_selected_region (void);
   52|       |  void erode_selected_region (void);
   53|       |  void opening_selected_region (void);
   54|       |  void closing_selected_region (void);
   55|       |
   56|       |  // smoothing
   57|       |  void smoothing_laplacian (void);
   58|       |  void smoothing_taubin (void);
   59|       |
   60|       |  // fitting
   61|       |  Plane*  plane_fitting  (void);
   62|       |
   63|       |  //
   64|       |  // colors
   65|       |  //
   66|       |  void set_color_regions         (float r, float g, float b);
   67|       |  void set_color_selected_region (float r, float g, float b);
   68|       |  void set_color_common_face     (float r, float g, float b);
   69|       |
   70|       | private:
   71|       |  Mesh_half_edge *mesh_half_edge; // original model
   72|       |  int  size;             // size of the following arrays (number of faces)
   73|       |  float *data;          // for each element is associated a value
   74|       |  int  *regions;         // precise if an element is included in a specific region
   75|       |  int  *selected_region; // allow the user to select elements among the regions
   76|       |
   77|       |  // colors
   78|       |  float r_regions, g_regions, b_regions;
   79|       |  float r_selected_region, g_selected_region, b_selected_region;
   80|       |  float r_common_face, g_common_face, b_common_face;
   81|       |};
   82|       |
   83|       |#endif // __REGIOND_FACES_H__

/workspaces/cg/src/cgmesh/regions_vertices.h:
    1|       |#ifndef __REGIONS_VERTICES_H__
    2|       |#define __REGIONS_VERTICES_H__
    3|       |
    4|       |#include "mesh_half_edge.h"
    5|       |
    6|       |#define ACCESSIBILITY_RIDGES  1
    7|       |#define ACCESSIBILITY_RAVINES 2
    8|       |
    9|       |class Cregions_vertices
   10|       |{
   11|       |  friend class Cmodel3d_geometric_primitive;
   12|       |
   13|       | public:
   14|       |  Cregions_vertices (Mesh_half_edge *mesh_half_edge);
   15|       |  ~Cregions_vertices ();
   16|       |
   17|      0|  int get_size (void) { return size; };
   18|       |
   19|       |  void set_datas (float *datas, int size);
   20|       |  float* get_datas ();
   21|       |
   22|      0|  int *get_selected_region (void) { return selected_region; };
   23|       |
   24|       |  void get_principal_direction_max_from_selected_regions (Vector3d **directions, int *n);
   25|       |  void get_principal_direction_min_from_selected_regions (Vector3d **directions, int *n);
   26|       |  void get_curvature_max_from_selected_regions (float **curvatures, int *n);
   27|       |  void get_curvature_min_from_selected_regions (float **curvatures, int *n);
   28|       |
   29|       |  /* export methods */
   30|       |  void export_selected_region_cloud_points (char *filename);
   31|       |
   32|       |  // init the regions to the boundary of the 3d model
   33|       |  void init_from_boundary (void);
   34|       |
   35|       |  /* edit */
   36|       |  void delete_selected_region (void);
   37|       |
   38|       |  /**************************/
   39|       |  /*** ridges and ravines ***/
   40|       |  /**************************/
   41|       |
   42|       |  // threshold of the curvatures
   43|       |  void init_from_max_curvatures (void);
   44|       |  void init_from_min_curvatures (void);
   45|       |  void init_from_closest_to_zero_curvatures (void);
   46|       |  void init_from_highest_absolute_curvatures (void);
   47|       |
   48|       |  // method of cylinders
   49|       |  void init_from_cylinders (void);
   50|       |
   51|       |  // accessibility
   52|       |  void init_from_accessibility (int type);
   53|       |  void init_from_accessibility2 (void);
   54|       |
   55|       |  // belyaev
   56|       |  void init_from_belyaev (void);
   57|       |  void get_directions_lines_from_belyaev (Vector3 **directions, int *n);
   58|       |  void belyaev_ridges_select_n (float percentage);
   59|       |  void belyaev_ravines_select_n (float percentage);
   60|       |
   61|       |  void get_directions_lines (Vector3 **directions, int *n, float threshold, float epsilon);
   62|       |
   63|       |  void init_lines         (float threshold, float epsilon);
   64|       |  void init_lines_ridges  (float threshold, float epsilon);
   65|       |  void init_lines_ravines (float threshold, float epsilon);
   66|       |  void init_circles       (float radius, float threshold, float epsilon);
   67|       |  void init_planes        (float epsilon);
   68|       |  void init_spheres       (float threshold, float epsilon);
   69|       |  void init_cylinders     (float threshold, float epsilon);
   70|       |
   71|       |  //
   72|       |  // segmentation
   73|       |  //
   74|       |  
   75|       |  // segmentation whitaker
   76|       |  void init_from_whitaker (void);
   77|       |
   78|       |  //
   79|       |  // misc
   80|       |  //
   81|       |
   82|       |  // update the colors in the model
   83|       |  void refresh_colors (void);
   84|       |
   85|       |  // get extrema of datas
   86|       |  void get_extremas (float *min, float *max);
   87|       |
   88|       |  //
   89|       |  // selection
   90|       |  //
   91|       |  void select_n_up   (float percentage); // select the n vertices with higher values in datas
   92|       |  void select_n_down (float percentage); // select the n vertices with lower values in datas
   93|       |  void select_threshold_up   (float threshold);
   94|       |  void select_threshold_down (float threshold);
   95|       |  void select_datas          (float value);
   96|       |  float get_lowest_value_from_selected_region (void);
   97|       |  float get_highest_value_from_selected_region (void);
   98|       |
   99|       |  void select_all_regions (void);
  100|       |  void select_region (int id);
  101|       |  void select_vertex (int id);
  102|       |  void deselect_vertex (int id);
  103|       |  void select_vertices (int id);
  104|       |  void deselect_vertices (int id);
  105|       |  void deselect (void);
  106|       |
  107|       |  //
  108|       |  // algorithms
  109|       |  //
  110|       |
  111|       |  //
  112|       |  // smoothing data
  113|       |  //
  114|       |  void smoothing_data (void);
  115|       |
  116|       |  //
  117|       |  // morphological operators
  118|       |  //
  119|       |  void dilate_regions (void);
  120|       |  void erode_regions (void);
  121|       |  void opening_regions (void);
  122|       |  void closing_regions (void);
  123|       |  void delete_isolated_regions (int n = 1); // delete connex regions containing less than n vertices
  124|       |
  125|       |  void dilate_selected_region (void);
  126|       |  void erode_selected_region (void);
  127|       |  void opening_selected_region (void);
  128|       |  void closing_selected_region (void);
  129|       |
  130|       |  //
  131|       |  // skeletonization
  132|       |  //
  133|       |  void skeletonize_selected_region (void);
  134|       |  void pruning_selected_region (void);
  135|       |
  136|       |  //
  137|       |  // smoothing
  138|       |  //
  139|       |  void smoothing_laplacian_regions (void);
  140|       |  void smoothing_laplacian_inverse_regions (void);
  141|       |  void smoothing_taubin_regions (void);
  142|       |  void smoothing_taubin_regions (float lambda, float mu);
  143|       |  void smoothing_taubin_inverse_regions (void);
  144|       |
  145|       |  void smoothing_laplacian_selected_region (void);
  146|       |  void smoothing_laplacian_inverse_selected_region (void);
  147|       |  void smoothing_taubin_selected_region (void);
  148|       |  void smoothing_taubin_selected_region (float lambda, float mu);
  149|       |  void smoothing_taubin_inverse_selected_region (void);
  150|       |
  151|       |  //
  152|       |  // fitting
  153|       |  //
  154|       |/*
  155|       |  Line*   line_fitting   (void);
  156|       |  Circle* circle_fitting (void);
  157|       |  Plane*  plane_fitting  (void);
  158|       |*/
  159|       |
  160|       |  //
  161|       |  // colors
  162|       |  //
  163|       |  void set_color_regions (float r, float g, float b);
  164|       |  void set_color_selected_region (float r, float g, float b);
  165|       |  void set_color_common_vertex (float r, float g, float b);
  166|       |
  167|       | protected:
  168|       |  Mesh_half_edge *mesh_half_edge; // original model
  169|       |  int  size;                // size of the following arrays (number of vertices)
  170|       |  float *datas;            // for each element is associated a value
  171|       |  int  *regions;            // 0 or 1 : precise if an element is included in a specific region
  172|       |  int  *selected_region;    // 0 or 1 : allow the user to select elements among the regions
  173|       |
  174|       |  // colors
  175|       |  float r_regions, g_regions, b_regions;
  176|       |  float r_selected_region, g_selected_region, b_selected_region;
  177|       |  float r_common_vertex, g_common_vertex, b_common_vertex;
  178|       |};
  179|       |
  180|       |#endif // __REGIONS_VERTICES_H__

/workspaces/cg/src/cgmesh/rendered_geometry.h:
    1|       |#ifndef __RENDERED_GEOMETRY_H__
    2|       |#define __RENDERED_GEOMETRY_H__
    3|       |
    4|       |#include "../cgmath/cgmath.h"
    5|       |#include "material.h"
    6|       |
    7|       |class RenderedPlane : public Plane
    8|       |{
    9|       |public:
   10|       |	RenderedPlane ();
   11|       |	~RenderedPlane ();
   12|       |
   13|      0|	void SetMaterial (Material *pMaterial) { m_pMaterial = pMaterial; };
   14|      0|	virtual void* GetMaterial (void) { return m_pMaterial; };
   15|       |
   16|       |private:
   17|       |	Material *m_pMaterial;
   18|       |};
   19|       |
   20|       |class RenderedSphere : public Sphere
   21|       |{
   22|       |public:
   23|       |	RenderedSphere ();
   24|       |	~RenderedSphere ();
   25|       |
   26|      0|	void SetMaterial (Material *pMaterial) { m_pMaterial = pMaterial; };
   27|      0|	virtual void* GetMaterial (void) { return m_pMaterial; };
   28|       |
   29|       |private:
   30|       |	Material *m_pMaterial;
   31|       |};
   32|       |
   33|       |class RenderedTorus : public Torus
   34|       |{
   35|       |public:
   36|       |	RenderedTorus ();
   37|       |	~RenderedTorus ();
   38|       |
   39|      0|	void SetMaterial (Material *pMaterial) { m_pMaterial = pMaterial; };
   40|      0|	virtual void* GetMaterial (void) { return m_pMaterial; };
   41|       |
   42|       |private:
   43|       |	Material *m_pMaterial;
   44|       |};
   45|       |
   46|       |class RenderedTriangle : public Triangle
   47|       |{
   48|       |public:
   49|       |	RenderedTriangle ();
   50|       |	~RenderedTriangle ();
   51|       |
   52|      0|	void SetMaterial (Material *pMaterial) { m_pMaterial = pMaterial; };
   53|      0|	virtual void* GetMaterial (void) { return m_pMaterial; };
   54|       |
   55|       |private:
   56|       |	Material *m_pMaterial;
   57|       |};
   58|       |
   59|       |#endif // __RENDERED_GEOMETRY_H__

/workspaces/cg/src/cgmesh/scene.cpp:
    1|       |#include <stdlib.h>
    2|       |
    3|       |#include "scene.h"
    4|       |
    5|       |Scene::Scene ()
    6|      4|{
    7|      4|	m_nObjects = 0;
    8|       |
    9|       |	// stats
   10|      4|	m_i_GetIntersectionBboxWithRay_count = 0;
   11|      4|	m_i_GetIntersectionWithRay_count = 0;
   12|      4|}
   13|       |
   14|       |Scene::~Scene ()
   15|      4|{
   16|     59|	for (unsigned int i=0; i<m_nObjects; i++)
   17|     55|		delete m_pObjects[i];
   18|      4|	m_nObjects = 0;
   19|      4|}
   20|       |
   21|       |void Scene::AddObject (Geometry *pObject)
   22|     55|{
   23|     55|	m_pObjects[m_nObjects++] = pObject;
   24|     55|}
   25|       |
   26|       |Geometry* Scene::GetIntersectionWithRay (vec3 vOrig, vec3 vDirection, vec3 vIntersection, vec3 vNormal)
   27|  65.5k|{
   28|  65.5k|	float fT = 0.;
   29|  65.5k|	Geometry *pIntersectedObject = NULL;
   30|   966k|	for (unsigned int i=0; i<m_nObjects; i++)
   31|   901k|	{
   32|   901k|		float fTCurrent = 0.;
   33|   901k|		float vIntersectionCurrent[3], vNormalCurrent[3];
   34|       |
   35|   901k|		m_i_GetIntersectionBboxWithRay_count++;
   36|   901k|		bool bGotBBox = m_pObjects[i]->GetIntersectionBboxWithRay (vOrig, vDirection);
   37|   901k|		if (bGotBBox == false)
   38|   859k|			continue;
   39|       |
   40|  41.7k|		m_i_GetIntersectionWithRay_count++;
   41|  41.7k|		unsigned int bIntersectionCurrent = m_pObjects[i]->GetIntersectionWithRay (vOrig, vDirection,
   42|  41.7k|											   &fTCurrent,
   43|  41.7k|											   vIntersectionCurrent, vNormalCurrent);
   44|  41.7k|		if (bIntersectionCurrent == 1)
   45|  18.6k|		{
   46|  18.6k|			if ((!pIntersectedObject) ||
   47|  18.6k|			    (pIntersectedObject && fTCurrent < fT))
   48|  18.3k|			{
   49|  18.3k|				pIntersectedObject = m_pObjects[i];
   50|  18.3k|				fT = fTCurrent;
   51|  18.3k|				vIntersection[0] = vIntersectionCurrent[0];
   52|  18.3k|				vIntersection[1] = vIntersectionCurrent[1];
   53|  18.3k|				vIntersection[2] = vIntersectionCurrent[2];
   54|  18.3k|				vNormal[0] = vNormalCurrent[0];
   55|  18.3k|				vNormal[1] = vNormalCurrent[1];
   56|  18.3k|				vNormal[2] = vNormalCurrent[2];
   57|  18.3k|			}
   58|  18.6k|		}
   59|  41.7k|	}
   60|       |
   61|  65.5k|	return pIntersectedObject;
   62|  65.5k|}
   63|       |
   64|       |Geometry* Scene::GetIntersectionWithSegment (vec3 vStart, vec3 vEnd, vec3 vIntersection, vec3 vNormal)
   65|      0|{
   66|      0|	float fT = 0.;
   67|      0|	float vDirection[3];
   68|      0|	vDirection[0] = vEnd[0] - vStart[0];
   69|      0|	vDirection[1] = vEnd[1] - vStart[1];
   70|      0|	vDirection[2] = vEnd[2] - vStart[2];
   71|      0|	Geometry *pIntersectedObject = NULL;
   72|      0|	for (unsigned int i=0; i<m_nObjects; i++)
   73|      0|	{
   74|      0|		float fTCurrent = 0.;
   75|      0|		float vIntersectionCurrent[3], vNormalCurrent[3];
   76|      0|		unsigned int bIntersectionCurrent = m_pObjects[i]->GetIntersectionWithRay (vStart, vDirection,
   77|      0|											   &fTCurrent,
   78|      0|											   vIntersectionCurrent, vNormalCurrent);
   79|      0|		if (bIntersectionCurrent == 1 && fTCurrent < 1.)
   80|      0|		{
   81|      0|			if ((!pIntersectedObject) ||
   82|      0|			    (pIntersectedObject && fTCurrent < fT))
   83|      0|			{
   84|      0|				pIntersectedObject = m_pObjects[i];
   85|      0|				fT = fTCurrent;
   86|      0|				vIntersection[0] = vIntersectionCurrent[0];
   87|      0|				vIntersection[1] = vIntersectionCurrent[1];
   88|      0|				vIntersection[2] = vIntersectionCurrent[2];
   89|      0|				vNormal[0] = vNormalCurrent[0];
   90|      0|				vNormal[1] = vNormalCurrent[1];
   91|      0|				vNormal[2] = vNormalCurrent[2];
   92|      0|			}
   93|      0|		}
   94|      0|	}
   95|       |
   96|      0|	return pIntersectedObject;
   97|      0|}
   98|       |
   99|       |void Scene::Dump (void)
  100|      0|{
  101|      0|	printf ("Scene stats :\n");
  102|      0|	printf ("m_i_GetIntersectionBboxWithRay_count : %d\n", m_i_GetIntersectionBboxWithRay_count);
  103|      0|	printf ("m_i_GetIntersectionWithRay_count : %d\n", m_i_GetIntersectionWithRay_count);
  104|      0|}
  105|       |

/workspaces/cg/src/cgmesh/slicer.h:
    1|       |#ifndef __SLICER_H__
    2|       |#define __SLICER_H__
    3|       |
    4|       |#include "cgmesh.h"
    5|       |
    6|       |#define ALONGOX 0
    7|       |#define ALONGOY 1
    8|       |#define ALONGOZ 2
    9|       |
   10|       |class Cmodel3d_half_edge_sliced
   11|       |{
   12|       | public:
   13|       |  Cmodel3d_half_edge_sliced (Mesh_half_edge *model, int dir, float _step_slice);
   14|       |  ~Cmodel3d_half_edge_sliced ();
   15|       |
   16|      0|  Mesh_half_edge* get_model (void) { return model; };
   17|       |
   18|       |  void get_areas (float **areas, int *size);
   19|       |  void get_slice (int index, Polygon2 ***slice, int *nc);
   20|      0|  int  get_n_slices (void) { return n_slices; };
   21|       |
   22|      0|  float get_step_slice (void) { return step_slice; };
   23|      0|  float get_zmin (void) { return zmin; };
   24|      0|  float get_xmin (void) { return xmin; };
   25|       |
   26|       |  void look_at_symmetry (void);
   27|       |
   28|       |  void dump (char *prefix);
   29|       |  
   30|       | private:
   31|       |  int direction;
   32|       |
   33|       |  void scan_model_along_Ox (void);
   34|       |  void scan_model_along_Oz (void);
   35|       |  void scan_model (int dir);
   36|       |
   37|       |  Mesh_half_edge *model;
   38|       |
   39|       |  float zmin, xmin;
   40|       |
   41|       |  // slices
   42|       |  int n_slices;
   43|       |  Polygon2 ***slices;
   44|       |  int *n_contours;
   45|       |  float step_slice; // distance between two consecutive slices
   46|       |};
   47|       |
   48|       |#endif // __SLICER_H__

/workspaces/cg/src/cgmesh/smoothing_laplacian.h:
    1|       |#ifndef __SMOOTHING_LAPLACIAN_H__
    2|       |#define __SMOOTHING_LAPLACIAN_H__
    3|       |
    4|       |#include "mesh_half_edge.h"
    5|       |
    6|       |//
    7|       |//
    8|       |//
    9|       |class MeshAlgoSmoothingLaplacian
   10|       |{
   11|       |public:
   12|      0|	MeshAlgoSmoothingLaplacian () {};
   13|      0|	~MeshAlgoSmoothingLaplacian () {};
   14|       |
   15|       |	bool Apply (Mesh_half_edge *model);
   16|       |};
   17|       |
   18|       |#endif // __SMOOTHING_LAPLACIAN_H__

/workspaces/cg/src/cgmesh/smoothing_taubin.h:
    1|       |#ifndef __SMOOTHING_TAUBIN_H__
    2|       |#define __SMOOTHING_TAUBIN_H__
    3|       |
    4|       |#include "mesh_half_edge.h"
    5|       |
    6|       |//
    7|       |//
    8|       |//
    9|       |class MeshAlgoSmoothingTaubin
   10|       |{
   11|       |public:
   12|      0|	MeshAlgoSmoothingTaubin () {};
   13|      0|	~MeshAlgoSmoothingTaubin () {};
   14|       |
   15|       |	bool Apply (Mesh_half_edge *model, float lambda = 0.7, float mu = -0.7527);
   16|       |
   17|       |private:
   18|       |	bool ApplyCoefficient (Mesh_half_edge *model, float coeff);
   19|       |};
   20|       |
   21|       |#endif // __SMOOTHING_TAUBIN_H__

/workspaces/cg/src/cgmesh/subdivision_karbacher.h:
    1|       |#ifndef __SUBDIVISION_KARBACHER_H__
    2|       |#define __SUBDIVISION_KARBACHER_H__
    3|       |
    4|       |#include "cgmesh.h"
    5|       |
    6|       |class MeshAlgoSubdivisionKarbacher
    7|       |{
    8|       |public:
    9|      0|	MeshAlgoSubdivisionKarbacher () {};
   10|      0|	~MeshAlgoSubdivisionKarbacher () {};
   11|       |
   12|       |	bool Apply (Mesh_half_edge *model);
   13|       |
   14|       |private:
   15|       |	void InitializePosition (Vector3d &par_pos, Vector3d &par_npos,
   16|       |				 Vector3d par_v1, Vector3d par_v2, Vector3d par_v3,
   17|       |				 Vector3d par_n1, Vector3d par_n2, Vector3d par_n3);
   18|       |	void DeleteAngles (void);
   19|       |
   20|       |	Mesh_half_edge *m_pModel;
   21|       |};
   22|       |
   23|       |#endif // __SUBDIVISION_KARBACHER_H__

/workspaces/cg/src/cgmesh/subdivision_loop.h:
    1|       |#ifndef __SUBDIVISION_LOOP_H__
    2|       |#define __SUBDIVISION_LOOP_H__
    3|       |
    4|       |#include "mesh_half_edge.h"
    5|       |
    6|       |//
    7|       |//
    8|       |//
    9|       |class MeshAlgoSubdivisionLoop
   10|       |{
   11|       |public:
   12|      0|	MeshAlgoSubdivisionLoop () {};
   13|      0|	~MeshAlgoSubdivisionLoop () {};
   14|       |
   15|       |	bool Apply (Mesh_half_edge *model);
   16|       |
   17|       |private:
   18|       |};
   19|       |
   20|       |#endif // __SUBDIVISION_LOOP_H__

/workspaces/cg/src/cgmesh/surface_architecture.h:
    1|       |#ifndef __SURFACE_ARCHITECTURE_H__
    2|       |#define __SURFACE_ARCHITECTURE_H__
    3|       |
    4|       |#include "mesh.h"
    5|       |#include "polygon2.h"
    6|       |
    7|       |extern Mesh* CreateArch (void);
    8|       |extern Mesh* CreateArch2 (void);
    9|       |extern Mesh* CreateBlock (float width = 1.61803399, float height = 1., float depth = 1., float bevel = 0.1);
   10|       |
   11|       |extern int create_arc_brise (float a, float b, unsigned int npts, float **p, float **tgt, float offset);
   12|       |extern int create_arc_accolade (float a, float b, float e, unsigned int npts, float **p, float **tgt);
   13|       |extern int create_arc_anse_de_panier (float a, float e, unsigned int npts, float **p, float **tgt);
   14|       |extern int create_arc_rampant (float a, float t, unsigned int npts, float **p, float **tgt);
   15|       |
   16|       |extern int extrude_moulure_along_curve (unsigned int npcurve, float *pcurve, float *tcurve,
   17|       |					unsigned int npmoulure, float *pmoulure,
   18|       |					float **points, unsigned int **faces);
   19|       |
   20|       |class Rosace
   21|       |{
   22|       |public:
   23|       |	Rosace ();
   24|       |	~Rosace ();
   25|       |	
   26|      0|	inline void SetNFoils (unsigned int nFoils) { m_nFoils = nFoils; };
   27|       |	Polygon2* Generate (void);
   28|       |
   29|       |private:
   30|       |	unsigned int m_nFoils;
   31|       |	float m_fRadius;
   32|       |};
   33|       |
   34|       |class ArcBrise
   35|       |{
   36|       |public:
   37|       |	ArcBrise ();
   38|       |	~ArcBrise ();
   39|       |	void SetPrincipalArc (float altitude, float width, float height);
   40|       |	void SetSecondArc (float altitude2, float width2, float height2);
   41|       |	Polygon2* Generate (void);
   42|       |	
   43|       |private:
   44|       |	float m_fAltitude, m_fWidth, m_fHeight;
   45|       |	float m_fAltitude2, m_fWidth2, m_fHeight2;
   46|       |};
   47|       |
   48|       |#endif // __SURFACE_ARCHITECTURE_H__

/workspaces/cg/src/cgmesh/surface_basic.cpp:
    1|       |//#define _BSD_SOURCE
    2|       |#define _USE_MATH_DEFINES
    3|       |#include <math.h>
    4|       |#include <stdio.h>
    5|       |
    6|       |#include "surface_basic.h"
    7|       |
    8|       |//
    9|       |//
   10|       |//
   11|       |Mesh* CreateTriangle (float x1, float y1, float z1,
   12|       |		      float x2, float y2, float z2,
   13|       |		      float x3, float y3, float z3)
   14|      0|{
   15|      0|	Mesh *mesh = new Mesh (3, 1);
   16|       |
   17|       |	// create vertices
   18|      0|	float vertices[3*3] = {x1, y1, z1, x2, y2, z2, x3, y3, z3};
   19|      0|	mesh->SetVertices (3, vertices);
   20|       |
   21|       |	// create faces
   22|      0|	unsigned int faces[3] = {0, 1, 2};
   23|      0|	mesh->SetFaces (1, 3, faces);
   24|       |
   25|      0|	return mesh;
   26|      0|}
   27|       |
   28|       |//
   29|       |//
   30|       |//
   31|       |Mesh* CreateQuad (void)
   32|      0|{
   33|      0|	Mesh *mesh = new Mesh ();
   34|       |
   35|       |	// create vertices
   36|      0|	float vertices[4*3] = { -1., -1., 0.,
   37|      0|			         1., -1., 0.,
   38|      0|			         1.,  1., 0.,
   39|      0|			        -1.,  1., 0.  };
   40|      0|	mesh->SetVertices (4, vertices);
   41|       |
   42|       |	// create faces
   43|      0|	unsigned int faces[4] = {0, 1, 2, 3};
   44|      0|	mesh->SetFaces (1, 4, faces);
   45|       |	
   46|       |	//float texture_coordinates[4*2] = {0, 0, 1, 0, 1, 1, 0, 1};
   47|       |	//mesh->SetTextureCoordinates (1, 4, texture_coordinates);
   48|       |
   49|      0|	return mesh;
   50|      0|}
   51|       |
   52|       |Mesh* CreateGrid(unsigned int nx, unsigned int ny)
   53|      0|{
   54|      0|	int nvertices = nx*ny;
   55|      0|	int nfaces = 2*(nx-1)*(ny-1);
   56|      0|	Mesh *mesh = new Mesh (nvertices, nfaces);
   57|       |
   58|       |	// generate vertices
   59|      0|	for (int j=0; j<ny; j++)
   60|      0|		for (int i=0; i<nx; i++)
   61|      0|			mesh->SetVertex(nx*j+i, (float)i, (float)j, 0.f);
   62|       |
   63|       |	// generates faces
   64|      0|	int fi=0;
   65|      0|	for (int j=0; j<ny-1; j++)
   66|      0|		for (int i=0; i<nx-1; i++)
   67|      0|		{
   68|      0|			mesh->SetFace(fi++, nx*j+i, nx*j+i+1, nx*(j+1)+i+1);
   69|      0|			mesh->SetFace(fi++, nx*j+i, nx*(j+1)+i+1, nx*(j+1)+i);
   70|      0|		}
   71|       |
   72|      0|		return mesh;
   73|      0|}
   74|       |
   75|       |//
   76|       |//
   77|       |//
   78|       |Mesh* CreateCube (bool bTri)
   79|      0|{
   80|      0|	Mesh *mesh = new Mesh ();
   81|       |
   82|      0|	float vertices[8*3] = { -1., -1., -1.,
   83|      0|		1., -1., -1.,
   84|      0|		1.,  1., -1.,
   85|      0|		-1.,  1., -1.,
   86|      0|		-1., -1.,  1.,
   87|      0|		1., -1.,  1.,
   88|      0|		1.,  1.,  1.,
   89|      0|		-1.,  1.,  1. };
   90|      0|	mesh->SetVertices (8, vertices);
   91|       |
   92|       |	// create faces
   93|      0|	if (bTri)
   94|      0|	{
   95|      0|		unsigned int faces[12*3] = {0, 3, 2, 0, 2, 1,
   96|      0|			4, 5, 6, 4, 6, 7,
   97|      0|			0, 4, 7, 0, 7, 3,
   98|      0|			3, 7, 6, 3, 6, 2,
   99|      0|			2, 6, 5, 2, 5, 1,
  100|      0|			1, 5, 4, 1, 4, 0};
  101|      0|		mesh->SetFaces (12, 3, faces);
  102|      0|	}
  103|      0|	else
  104|      0|	{
  105|      0|		unsigned int faces[6*4] = {0, 3, 2, 1,
  106|      0|			4, 5, 6, 7,
  107|      0|			0, 4, 7, 3,
  108|      0|			3, 7, 6, 2,
  109|      0|			2, 6, 5, 1,
  110|      0|			1, 5, 4, 0};
  111|      0|		mesh->SetFaces (6, 4, faces);
  112|       |
  113|       |		//float texture_coordinates[6*2] = {};
  114|       |		//mesh->SetTextureCoordinates (6, 4, texture_coordinates);
  115|      0|	}
  116|       |
  117|      0|	return mesh;
  118|      0|}
  119|       |
  120|       |//
  121|       |//
  122|       |//
  123|       |Mesh* CreateTetrahedron (void)
  124|      0|{
  125|      0|	Mesh *mesh = new Mesh ();
  126|       |
  127|       |	// create vertices
  128|      0|	float sqrt3 = 1.0f / sqrt(3.0f);
  129|      0|	float vertices[12] = {sqrt3, sqrt3, sqrt3,
  130|      0|			      -sqrt3, -sqrt3, sqrt3,
  131|      0|			      -sqrt3, sqrt3, -sqrt3,
  132|      0|			      sqrt3, -sqrt3, -sqrt3};
  133|      0|	mesh->SetVertices (4, vertices);
  134|       |
  135|       |	// create faces
  136|      0|	unsigned int faces[12] = {0, 2, 1, 0, 1, 3, 2, 3, 1, 3, 2, 0};
  137|      0|	mesh->SetFaces (4, 3, faces);
  138|       |
  139|      0|	return mesh;
  140|      0|}
  141|       |
  142|       |//
  143|       |//
  144|       |//
  145|       |Mesh* CreateOctahedron (void)
  146|      0|{
  147|      0|	Mesh *mesh = new Mesh ();
  148|       |
  149|       |	// create vertices
  150|      0|	float vertices[18] = {0.0, 0.0, -1.0,
  151|      0|			      1.0, 0.0, 0.0,
  152|      0|			      0.0, -1.0, 0.0,
  153|      0|			      -1.0, 0.0, 0.0,
  154|      0|			      0.0, 1.0, 0.0,
  155|      0|			      0.0, 0.0, 1.0}; 
  156|      0|	mesh->SetVertices (6, vertices);
  157|       |
  158|       |	// create faces
  159|      0|	unsigned int faces[24] = {0, 1, 2, 0, 2, 3, 0, 3, 4, 0, 4, 1, 5, 2, 1, 5, 3, 2, 5, 4, 3, 5, 1, 4};
  160|      0|	mesh->SetFaces (8, 3, faces);
  161|       |
  162|      0|	return mesh;
  163|      0|}
  164|       |
  165|       |Mesh* CreateDodecahedron (void)
  166|      0|{
  167|      0|	Mesh *mesh = new Mesh ();
  168|       |
  169|       |	// create vertices
  170|      0|	float vertices[20*3] = {-0.57735,  -0.57735,  0.57735,
  171|      0|				0.934172,  0.356822,  0,
  172|      0|				0.934172,  -0.356822,  0,
  173|      0|				-0.934172,  0.356822,  0,
  174|      0|				-0.934172,  -0.356822,  0,
  175|      0|				0,  0.934172,  0.356822,
  176|      0|				0,  0.934172,  -0.356822,
  177|      0|				0.356822,  0,  -0.934172,
  178|      0|				-0.356822,  0,  -0.934172,
  179|      0|				0,  -0.934172,  -0.356822,
  180|      0|				0,  -0.934172,  0.356822,
  181|      0|				0.356822,  0,  0.934172,
  182|      0|				-0.356822,  0,  0.934172,
  183|      0|				0.57735,  0.57735,  -0.57735,
  184|      0|				0.57735,  0.57735,  0.57735,
  185|      0|				-0.57735,  0.57735,  -0.57735,
  186|      0|				-0.57735,  0.57735,  0.57735,
  187|      0|				0.57735,  -0.57735,  -0.57735,
  188|      0|				0.57735,  -0.57735,  0.57735,
  189|      0|				-0.57735,  -0.57735,  -0.57735 };
  190|      0|	mesh->SetVertices (20, vertices);
  191|       |
  192|       |	// create faces
  193|      0|	unsigned int faces[12*5] = {  1, 14, 11, 18, 2,
  194|      0|				      1, 2, 17, 7, 13,
  195|      0|				      3, 15, 8, 19, 4,
  196|      0|				      3, 4, 0, 12, 16,
  197|      0|				      3, 16, 5, 6, 15,
  198|      0|				      1, 13, 6, 5, 14,
  199|      0|				      2, 18, 10, 9, 17,
  200|      0|				      4, 19, 9, 10, 0,
  201|      0|				      7, 17, 9, 19, 8,
  202|      0|				      6, 13, 7, 8, 15,
  203|      0|				      5, 16, 12, 11, 14,
  204|      0|				      10, 18, 11, 12, 0 };
  205|      0|	mesh->SetFaces (12, 5, faces);
  206|       |
  207|      0|	return mesh;
  208|      0|}
  209|       |
  210|       |extern Mesh* CreateIcosahedron (void)
  211|      0|{
  212|      0|	Mesh *mesh = new Mesh ();
  213|       |
  214|       |	// create vertices
  215|      0|	float t = (1.0f+sqrt(5.0f))/2.0f;
  216|      0|	float tau = t/sqrt(1.0f+t*t);
  217|      0|	float one = 1/sqrt(1.0f+t*t);
  218|       |
  219|      0|	float vertices[12*3] = {tau, one, 0.0,
  220|      0|			      -tau, one, 0.0,
  221|      0|			      -tau, -one, 0.0,
  222|      0|			      tau, -one, 0.0,
  223|      0|			      one, 0.0 ,  tau,
  224|      0|			      one, 0.0 , -tau,
  225|      0|			      -one, 0.0 , -tau,
  226|      0|			      -one, 0.0 , tau,
  227|      0|			      0.0 , tau, one,
  228|      0|			      0.0 , -tau, one,
  229|      0|			      0.0 , -tau, -one,
  230|      0|			      0.0 , tau, -one};
  231|      0|	mesh->SetVertices (12, vertices);
  232|       |
  233|       |	// create faces
  234|      0|	unsigned int faces[20*3] = {4, 8, 7,
  235|      0|				    4, 7, 9,
  236|      0|				    5, 6, 11,
  237|      0|				    5, 10, 6,
  238|      0|				    0, 4, 3,
  239|      0|				    0, 3, 5,
  240|      0|				    2, 7, 1,
  241|      0|				    2, 1, 6,
  242|      0|				    8, 0, 11,
  243|      0|				    8, 11, 1,
  244|      0|				    9, 10, 3,
  245|      0|				    9, 2, 10,
  246|      0|				    8, 4, 0,
  247|      0|				    11, 0, 5,
  248|      0|				    4, 9, 3,
  249|      0|				    5, 3, 10,
  250|      0|				    7, 8, 1,
  251|      0|				    6, 1, 11,
  252|      0|				    7, 2, 9,
  253|      0|				    6, 10, 2};
  254|      0|	mesh->SetFaces (20, 3, faces);
  255|       |
  256|      0|	return mesh;
  257|      0|}
  258|       |
  259|       |//
  260|       |//
  261|       |//
  262|       |Mesh* CreateDisk (unsigned int nVertices)
  263|      0|{
  264|      0|	Mesh *mesh = new Mesh (nVertices, 1);
  265|       |
  266|      0|	float *pVertices = mesh->m_pVertices;
  267|      0|	for (unsigned int i=0; i<nVertices; i++)
  268|      0|	{
  269|      0|		float fAngle = i*2*M_PI/(nVertices);
  270|      0|		pVertices[3*i+0] = cos(fAngle);
  271|      0|		pVertices[3*i+1] = sin(fAngle);
  272|      0|		pVertices[3*i+2] = 0.;
  273|      0|	}
  274|       |
  275|      0|	Face *pFace = new Face ();
  276|      0|	pFace->SetNVertices (nVertices);
  277|      0|	for (unsigned int i=0; i<nVertices; i++)
  278|      0|		pFace->m_pVertices[i] = i;
  279|      0|	mesh->m_pFaces[0] = pFace;
  280|       |
  281|      0|	return mesh;
  282|      0|}
  283|       |
  284|       |//
  285|       |//
  286|       |//
  287|       |Mesh* CreateCone (float fHeight, float fRadius, unsigned int nVertices, bool bCap)
  288|      0|{
  289|      0|	unsigned int nv = nVertices+1;
  290|      0|	unsigned int nf = (bCap)? nVertices+1 : nVertices;
  291|      0|	Mesh *mesh = new Mesh (nv, nf);
  292|       |
  293|      0|	float *pVertices = mesh->m_pVertices;
  294|      0|	pVertices[0] = 0.;
  295|      0|	pVertices[1] = 0.;
  296|      0|	pVertices[2] = fHeight;
  297|      0|	for (unsigned int i=1; i<=nVertices; i++)
  298|      0|	{
  299|      0|		float fAngle = (i-1)*2*M_PI/(nVertices);
  300|      0|		pVertices[3*i+0] = fRadius * cos(fAngle);
  301|      0|		pVertices[3*i+1] = fRadius * sin(fAngle);
  302|      0|		pVertices[3*i+2] = 0.;
  303|      0|	}
  304|       |
  305|      0|	for (unsigned int i=0; i<nVertices; i++)
  306|      0|	{
  307|      0|		Face *pFace = new Face ();
  308|      0|		pFace->SetTriangle (0, i+1, (i==(nVertices-1))? 1 : i+2);
  309|      0|		mesh->m_pFaces[i] = pFace;
  310|      0|	}
  311|      0|	if (bCap)
  312|      0|	{
  313|      0|		Face *pFace = new Face ();
  314|      0|		pFace->SetNVertices (nVertices);
  315|      0|		for (unsigned int i=0; i<nVertices; i++)
  316|      0|			pFace->m_pVertices[i] = nVertices-i;
  317|      0|		mesh->m_pFaces[nVertices] = pFace;
  318|       |	
  319|      0|	}
  320|       |
  321|      0|	return mesh;
  322|      0|}
  323|       |
  324|       |//
  325|       |//
  326|       |//
  327|       |Mesh* CreateCylinder (float fHeight, float fRadius, unsigned int nVertices, bool bCap, bool bTriangular)
  328|      0|{
  329|      0|	unsigned int nv = 2*nVertices;
  330|      0|	unsigned int nf = 0;
  331|      0|	if (!bTriangular)
  332|      0|		nf = (bCap)? nVertices+2 : nVertices;
  333|      0|	else
  334|      0|		nf = (bCap)? 2*nVertices+2*(nVertices-2) : 2*nVertices;
  335|      0|	Mesh *mesh = new Mesh (nv, nf);
  336|       |
  337|      0|	float *pVertices = mesh->m_pVertices;
  338|      0|	for (unsigned int i=0; i<nVertices; i++)
  339|      0|	{
  340|      0|		float fAngle = i*2*M_PI/(nVertices);
  341|      0|		pVertices[3*i+0] = fRadius * cos(fAngle);
  342|      0|		pVertices[3*i+1] = fRadius * sin(fAngle);
  343|      0|		pVertices[3*i+2] = 0.;
  344|       |
  345|      0|		pVertices[3*(nVertices+i)+0] = pVertices[3*i+0];
  346|      0|		pVertices[3*(nVertices+i)+1] = pVertices[3*i+1];
  347|      0|		pVertices[3*(nVertices+i)+2] = fHeight;
  348|      0|	}
  349|       |
  350|      0|	if (bTriangular)
  351|      0|	{
  352|      0|		unsigned int fi = 0;
  353|      0|		for (unsigned int i=0; i<nVertices; i++)
  354|      0|		{
  355|      0|			Face *pFace1 = new Face ();
  356|      0|			pFace1->SetTriangle (i, (i+1)%nVertices, nVertices+(i+1)%nVertices);
  357|      0|			mesh->m_pFaces[fi++] = pFace1;
  358|       |
  359|      0|			Face *pFace2 = new Face ();
  360|      0|			pFace2->SetTriangle (i, nVertices+(i+1)%nVertices, nVertices+i);
  361|      0|			mesh->m_pFaces[fi++] = pFace2;
  362|      0|		}
  363|      0|		if (bCap)
  364|      0|		{
  365|      0|			for (unsigned int i=1; i<nVertices-1; i++)
  366|      0|			{
  367|      0|				Face *pFaceTop = new Face ();
  368|      0|				pFaceTop->SetTriangle (nVertices, nVertices+i, nVertices+(i+1)%nVertices);
  369|      0|				mesh->m_pFaces[fi++] = pFaceTop;
  370|      0|			}
  371|      0|			for (unsigned int i=1; i<nVertices-1; i++)
  372|      0|			{
  373|      0|				Face *pFaceBottom = new Face ();
  374|      0|				pFaceBottom->SetTriangle (0, nVertices-i, nVertices-(i+1)%nVertices);
  375|      0|				mesh->m_pFaces[fi++] = pFaceBottom;
  376|      0|			}
  377|      0|		}
  378|      0|	}
  379|      0|	else
  380|      0|	{
  381|      0|		for (unsigned int i=0; i<nVertices; i++)
  382|      0|		{
  383|      0|			Face *pFace = new Face ();
  384|      0|			pFace->SetQuad (i, i+1, nVertices+i+1, nVertices+i);
  385|      0|			if (i==nVertices-1)
  386|      0|			{
  387|      0|				pFace->m_pVertices[1] = 0;
  388|      0|				pFace->m_pVertices[2] = nVertices;
  389|      0|			}
  390|      0|			mesh->m_pFaces[i] = pFace;
  391|      0|		}
  392|      0|		if (bCap)
  393|      0|		{
  394|      0|			Face *pFaceTop = new Face ();
  395|      0|			pFaceTop->SetNVertices (nVertices);
  396|      0|			Face *pFaceBottom = new Face ();
  397|      0|			pFaceBottom->SetNVertices (nVertices);
  398|      0|			for (unsigned int i=0; i<nVertices; i++)
  399|      0|			{
  400|      0|				pFaceTop->m_pVertices[i] = nVertices+i;
  401|      0|				pFaceBottom->m_pVertices[i] = nVertices-i-1;
  402|      0|			}
  403|      0|			mesh->m_pFaces[nVertices] = pFaceTop;
  404|      0|			mesh->m_pFaces[nVertices+1] = pFaceBottom;
  405|      0|		}
  406|      0|	}
  407|       |
  408|      0|	return mesh;
  409|      0|}
  410|       |
  411|       |//
  412|       |//
  413|       |//
  414|       |Mesh* CreateCapsule (unsigned int n, float height, float radius)
  415|      0|{
  416|      0|    float height_half = height/2.;
  417|      0|    unsigned int nhalf = n/2.;
  418|       |
  419|      0|	unsigned int nVertices = 2*n*nhalf+2;
  420|      0|	unsigned int nFaces = 2*(n-1)*2*nhalf + 2*n;
  421|      0|	Mesh *mesh = new Mesh (nVertices, nFaces);
  422|       |
  423|      0|	float x, y, z;
  424|      0|	unsigned int ivertex = 0;
  425|      0|	unsigned int iface = 0;
  426|       |
  427|       |    //
  428|       |    // vertices
  429|       |    //
  430|       |
  431|       |    // top
  432|      0|    for (unsigned int i=0; i<n; i++)
  433|      0|    {
  434|      0|        float angle = 2.*M_PI*i / n;
  435|      0|        x = radius*cos(angle);
  436|      0|        y = radius*sin(angle);
  437|      0|        z = height_half;
  438|      0|		mesh->SetVertex (ivertex++, x, y, z);
  439|      0|    }
  440|       |
  441|      0|    for (unsigned int j=1; j<nhalf; j++)
  442|      0|    {
  443|      0|        float hcapsule = cos ((M_PI/2.)*(1.-((float)j)/(nhalf)));
  444|      0|        float rcapsule = radius*sqrt (1. - hcapsule*hcapsule);
  445|      0|        hcapsule *= radius;
  446|      0|        for (unsigned int i=0; i<n; i++)
  447|      0|        {
  448|      0|            float angle = 2.*M_PI*i / n;
  449|      0|            x = rcapsule * cos(angle);
  450|      0|            y = rcapsule * sin(angle);
  451|      0|            z = height_half + hcapsule;
  452|      0| 			mesh->SetVertex (ivertex++, x, y, z);
  453|      0|        }
  454|      0|    }
  455|      0|    x = 0.;
  456|      0|    y = 0.;
  457|      0|    z = height_half + radius;
  458|      0|    mesh->SetVertex (ivertex++, x, y, z);
  459|       |    
  460|       |    // bottom
  461|      0|    for (unsigned int i=0; i<n; i++)
  462|      0|    {
  463|      0|        float angle = 2.*M_PI*i / n;
  464|      0|        x = radius*cos(angle);
  465|      0|        y = radius*sin(angle);
  466|      0|        z = -height_half;
  467|      0|		mesh->SetVertex (ivertex++, x, y, z);
  468|      0|    }
  469|       |
  470|      0|    for (unsigned int j=1; j<nhalf; j++)
  471|      0|    {
  472|      0|        float hcapsule = cos ((M_PI/2.)*(1.-((float)j)/(nhalf)));
  473|      0|        float rcapsule = radius*sqrt (1. - hcapsule*hcapsule);
  474|      0|        hcapsule *= radius;
  475|      0|        for (unsigned int i=0; i<n; i++)
  476|      0|        {
  477|      0|            float angle = 2.*M_PI*i / n;
  478|      0|            x = rcapsule * cos(angle);
  479|      0|            y = rcapsule * sin(angle);
  480|      0|            z = -height_half - hcapsule;
  481|      0|			mesh->SetVertex (ivertex++, x, y, z);
  482|      0|        }
  483|      0|    }
  484|      0|    x = 0.;
  485|      0|    y = 0.;
  486|      0|    z = -height_half - radius;
  487|      0|    mesh->SetVertex (ivertex++, x, y, z);
  488|       |
  489|       |    //
  490|       |    // faces
  491|       |    //
  492|       |
  493|       |    // top
  494|      0|    unsigned int voffsettop = 0;
  495|      0|    unsigned int a, b, c;
  496|      0|    for (unsigned int j=0; j<nhalf-1; j++)
  497|      0|        for (unsigned int i=0; i<n; i++)
  498|      0|        {
  499|      0|            a = voffsettop + j*n+i;
  500|      0|            b = voffsettop + j*n+(i+1)%n;
  501|      0|            c = voffsettop + (j+1)*n+(i+1)%n;
  502|      0|	    mesh->m_pFaces[iface] = new Face ();
  503|      0|	    mesh->m_pFaces[iface++]->SetTriangle (a, b, c);
  504|       |
  505|      0|            a = voffsettop + j*n+i;
  506|      0|            b = voffsettop + (j+1)*n+(i+1)%n;
  507|      0|            c = voffsettop + (j+1)*n+i;
  508|      0|            mesh->m_pFaces[iface] = new Face ();
  509|      0|	    mesh->m_pFaces[iface++]->SetTriangle (a, b, c);
  510|      0|        }
  511|       |
  512|      0|    for (unsigned int i=0; i<n; i++)
  513|      0|    {
  514|      0|        a = voffsettop + n*nhalf;
  515|      0|        b = voffsettop + n*(nhalf-1) + i;
  516|      0|        c = voffsettop + n*(nhalf-1) + (i+1)%n;
  517|      0|        mesh->m_pFaces[iface] = new Face ();
  518|      0|	mesh->m_pFaces[iface++]->SetTriangle (a, b, c);
  519|      0|    }
  520|       |
  521|       |    // bottom
  522|      0|    voffsettop = n*nhalf+1;
  523|      0|    for (unsigned int j=0; j<nhalf-1; j++)
  524|      0|        for (unsigned int i=0; i<n; i++)
  525|      0|        {
  526|      0|            a = voffsettop + j*n+i;
  527|      0|            b = voffsettop + (j+1)*n+(i+1)%n;
  528|      0|            c = voffsettop + j*n+(i+1)%n;
  529|      0|            mesh->m_pFaces[iface] = new Face ();
  530|      0|	    mesh->m_pFaces[iface++]->SetTriangle (a, b, c);
  531|       |
  532|      0|            a = voffsettop + j*n+i;
  533|      0|            b = voffsettop + (j+1)*n+i;
  534|      0|            c = voffsettop + (j+1)*n+(i+1)%n;
  535|      0|            mesh->m_pFaces[iface] = new Face ();
  536|      0|	    mesh->m_pFaces[iface++]->SetTriangle (a, b, c);
  537|      0|        }
  538|       |
  539|      0|    for (unsigned int i=0; i<n; i++)
  540|      0|    {
  541|      0|        a = voffsettop + n*nhalf;
  542|      0|        b = voffsettop + n*(nhalf-1) + (i+1)%n;
  543|      0|        c = voffsettop + n*(nhalf-1) + i;
  544|      0|        mesh->m_pFaces[iface] = new Face ();
  545|      0|	mesh->m_pFaces[iface++]->SetTriangle (a, b, c);
  546|      0|    }
  547|       |
  548|       |    // body
  549|      0|    for (unsigned int j=0; j<n; j++)
  550|      0|    {
  551|      0|        a = (j+1)%n;
  552|      0|        b = j;
  553|      0|        c = voffsettop+j;
  554|      0|        mesh->m_pFaces[iface] = new Face ();
  555|      0|	mesh->m_pFaces[iface++]->SetTriangle (a, b, c);
  556|       |
  557|      0|        a = (j+1)%n;
  558|      0|        b = voffsettop+j;
  559|      0|        c = voffsettop+(j+1)%n;
  560|      0|        mesh->m_pFaces[iface] = new Face ();
  561|      0|	mesh->m_pFaces[iface++]->SetTriangle (a, b, c);
  562|      0|    }
  563|       |
  564|      0|    return mesh;
  565|      0|}
  566|       |
  567|       |#include "surface_teapot_data.h"
  568|       |Mesh* CreateTeapot (void)
  569|      1|{
  570|      1|	unsigned int nVertices = sizeof(TeapotData_Vertex)/sizeof(3*sizeof(float));
  571|      1|	unsigned int nFaces = sizeof(TeapotData_Face)/(3*sizeof(int));
  572|       |
  573|      1|	Mesh *mesh = new Mesh (nVertices, nFaces);
  574|       |
  575|       |	// create vertices
  576|  1.76k|	for (unsigned int i=0; i<nVertices; i++)
  577|  1.76k|	{
  578|  1.76k|		mesh->m_pVertices[3*i+0] = TeapotData_Vertex[i][0];
  579|  1.76k|		mesh->m_pVertices[3*i+1] = TeapotData_Vertex[i][1];
  580|  1.76k|		mesh->m_pVertices[3*i+2] = TeapotData_Vertex[i][2];
  581|  1.76k|	}
  582|       |
  583|       |	// create faces
  584|  2.25k|	for (unsigned int i=0; i<nFaces; i++)
  585|  2.25k|	{
  586|  2.25k|		Face *pFace = new Face ();
  587|  2.25k|		pFace->SetTriangle (TeapotData_Face[3*i], TeapotData_Face[3*i+1], TeapotData_Face[3*i+2]);
  588|  2.25k|		mesh->m_pFaces[i] = pFace;
  589|  2.25k|	}
  590|       |
  591|      1|	return mesh;
  592|      1|}
  593|       |
  594|       |//
  595|       |//
  596|       |//
  597|       |
  598|       |/*
  599|       |Theta \in [0,Pi] et Phi \in [0,2Pi]
  600|       |x = (a*(1+sin(Theta)) + r(Theta)*cos(Phi)) * cos(Theta)
  601|       |y = (b+r(Theta)*cos(Phi)) * sin(Theta)
  602|       |z = r(Theta)*sin(Phi)
  603|       |
  604|       |Theta \in [Pi,2Pi] et Phi \in [0,2Pi]
  605|       |x = a*(1+sin(Theta))*cos(Theta) - r(Theta) * cos(Phi)
  606|       |y = b*sin(Theta)
  607|       |z = r(Theta)*sin(Phi)
  608|       |
  609|       |  r(Theta) = c(1 - cos(Theta)/2)
  610|       |  a = 3
  611|       |  b = 8
  612|       |  c = 2
  613|       |*/
  614|       |
  615|       |static float r (float alpha)
  616|    297|{
  617|    297|	return 2.0f*(1.0f-cos(alpha)*0.5f);
  618|    297|}
  619|       |
  620|       |Mesh* CreateKleinBottle (int ThetaResolution, int PhiResolution)
  621|      1|{
  622|      1|	unsigned int vn = 10000;
  623|      1|	unsigned int fn = 2*((ThetaResolution-1)*(PhiResolution)+PhiResolution-1+1);
  624|      1|	Mesh *mesh = new Mesh (vn, fn);
  625|       |
  626|      1|	float Theta, Phi;
  627|      1|	float x, y, z;
  628|      1|	float a = 3;
  629|      1|	float b = 8;
  630|      1|	float c = 2;
  631|      1|	float Pi = 3.14159f;
  632|       |
  633|      1|	float stepTheta = 2*Pi/ThetaResolution; // step between two slices
  634|      1|	float stepPhi = 2*Pi/PhiResolution; // step in a slice
  635|       |
  636|       |	//
  637|       |	// vertices
  638|       |	//
  639|      1|	unsigned int vi=0;
  640|      6|	for (Theta=0; Theta<Pi; Theta+=stepTheta)
  641|      5|	{
  642|     60|		for (Phi=0; Phi<2.*Pi; Phi+=stepPhi)
  643|     55|		{
  644|     55|			x = (a*(1.0f+sin(Theta)) + r(Theta)*cos(Phi)) * cos(Theta);
  645|     55|			y = (b+r(Theta)*cos(Phi)) * sin(Theta);
  646|     55|			z = r(Theta)*sin(Phi);
  647|     55|			mesh->SetVertex (vi++, x, y, z);
  648|     55|		}
  649|      5|	}
  650|       |
  651|      7|	for (Theta=Pi; Theta<2.*Pi; Theta+=stepTheta)
  652|      6|	{
  653|     72|		for (Phi=0; Phi<2.*Pi; Phi+=stepPhi)
  654|     66|		{
  655|     66|			x = a*(1+sin(Theta))*cos(Theta) - r(Theta) * cos(Phi);
  656|     66|			y = b*sin(Theta);
  657|     66|			z = r(Theta)*sin(Phi);
  658|     66|			mesh->SetVertex (vi++, x, y, z);
  659|     66|		}
  660|      6|	}
  661|       |
  662|       |	//
  663|       |	// faces
  664|       |	//
  665|      1|	int nVerticesInSlice = PhiResolution;
  666|      1|	int nSlicesInTheta = ThetaResolution;
  667|      1|	int i, j, i1, i2, i3, i4;
  668|      1|	unsigned int fi=0;
  669|     10|	for (j=0; j<nSlicesInTheta-1; j++)
  670|      9|	{
  671|     99|		for (i=0; i<nVerticesInSlice; i++)
  672|     90|		{
  673|     90|			i1 = j*nVerticesInSlice+i;
  674|     90|			i2 = i1+1;
  675|     90|			i3 = (j+1)*nVerticesInSlice+i;
  676|     90|			i4 = i3+1;
  677|       |
  678|     90|			if ( !(nVerticesInSlice-1-i) ) // reach the border (i == (nVerticesInSlice-1))
  679|      9|			{
  680|      9|				i2 -= nVerticesInSlice;
  681|      9|				i4 -= nVerticesInSlice;
  682|      9|			}
  683|       |
  684|     90|			mesh->m_pFaces[fi] = new Face ();
  685|     90|			mesh->m_pFaces[fi++]->SetTriangle (i1, i2, i3);
  686|     90|			mesh->m_pFaces[fi] = new Face ();
  687|     90|			mesh->m_pFaces[fi++]->SetTriangle (i2, i4, i3);
  688|     90|		}
  689|      9|	}
  690|       |
  691|       |	// last connection
  692|     10|	for (i=0; i<nVerticesInSlice-1; i++)
  693|      9|	{
  694|      9|		i1 = j*nVerticesInSlice+i;
  695|      9|		i2 = j*nVerticesInSlice+i+1;
  696|      9|		i3 = nVerticesInSlice/2-i;
  697|      9|		i4 = nVerticesInSlice/2-i-1;
  698|      9|		if (i3<0)
  699|      3|			i3 = nVerticesInSlice-(i-nVerticesInSlice/2);
  700|      9|		if (i4<0)
  701|      4|			i4 = nVerticesInSlice-(i+1-nVerticesInSlice/2);
  702|       |
  703|      9|		mesh->m_pFaces[fi] = new Face ();
  704|      9|		mesh->m_pFaces[fi++]->SetTriangle (i1, i2, i3);
  705|      9|		mesh->m_pFaces[fi] = new Face ();
  706|      9|		mesh->m_pFaces[fi++]->SetTriangle (i2, i4, i3);
  707|      9|	}
  708|      1|	i1 = i1+1;
  709|      1|	i2 = i2+1-nVerticesInSlice;
  710|      1|	i3 = (i3 == 0)? nVerticesInSlice-1 : i3-1;
  711|      1|	i4 = (i4 == 0)? nVerticesInSlice-1 : i4-1;
  712|      1|	mesh->m_pFaces[fi] = new Face ();
  713|      1|	mesh->m_pFaces[fi++]->SetTriangle (i1, i2, i3);
  714|      1|	mesh->m_pFaces[fi] = new Face ();
  715|      1|	mesh->m_pFaces[fi++]->SetTriangle (i2, i4, i3);
  716|       |
  717|      1|	printf ("%d %d\n", vi, fi);
  718|      1|	mesh->m_nVertices = vi;
  719|      1|	mesh->m_nFaces = fi;
  720|       |
  721|      1|	return mesh;
  722|      1|}
  723|       |

/workspaces/cg/src/cgmesh/surface_implicit.h:
    1|       |#ifndef __SURFACE_IMPLICIT_H__
    2|       |#define __SURFACE_IMPLICIT_H__
    3|       |
    4|       |#include <stdlib.h>
    5|       |
    6|       |struct vec3f { float fX, fY, fZ; };
    7|       |
    8|       |typedef float (*mc_eval_func_t)   (float, float, float);
    9|       |typedef void  (*mc_color_func_t)  (float, float, float);
   10|       |typedef bool  (*mc_vertex_func_t) (float, float, float, int, void*);
   11|       |typedef void  (*mc_normal_func_t) (float, float, float);
   12|       |typedef void  (*mc_face_completed_func_t) (void*);
   13|       |typedef void  (*mc_layer_completed_func_t) (void*);
   14|       |
   15|       |class ImplicitSurface
   16|       |{
   17|       |public:
   18|       |	ImplicitSurface ();
   19|      0|	~ImplicitSurface () {};
   20|       |
   21|       |	inline void set_bbox (float minx, float miny, float minz, float maxx, float maxy, float maxz)
   22|      0|		{
   23|      0|			min[0] = minx; min[1] = miny; min[2] = minz;
   24|      0|			max[0] = maxx; max[1] = maxy; max[2] = maxz;
   25|      0|		};
   26|       |	inline void get_bbox (vec3f &vmin, vec3f &vmax)
   27|      0|		{
   28|      0|			vmin.fX = min[0]; vmin.fY = min[1]; vmin.fZ = min[2];
   29|      0|			vmax.fX = max[0]; vmax.fY = max[1]; vmax.fZ = max[2];
   30|      0|		};
   31|      0|	inline void set_value (float _fValue) { fValue = _fValue; };
   32|      0|	inline float get_value (float _fValue) { return fValue; };
   33|      0|	inline void set_boundary (int _bBoundary) { bBoundary = _bBoundary; };
   34|       |	inline void set_orientation (int bInf)
   35|      0|		{
   36|      0|			orientation[0] = 0;
   37|      0|			if (bInf)
   38|      0|			{
   39|      0|				orientation[1] = 1;
   40|      0|				orientation[2] = 2;
   41|      0|			}
   42|      0|			else
   43|      0|			{
   44|      0|				orientation[1] = 2;
   45|      0|				orientation[2] = 1;
   46|      0|			}
   47|      0|		}
   48|       |	inline void set_resolution_per_unit (int _resolution)
   49|      0|		{
   50|      0|			for (int i=0; i<3; i++)
   51|      0|			{
   52|      0|				resolution[i] = (int)((max[i]-min[i])*_resolution);
   53|      0|				step[i] = (max[i]-min[i])/(resolution[i]);
   54|      0|			}
   55|      0|		};
   56|      0|	inline void set_eval_func (mc_eval_func_t _eval_func) { eval_func = _eval_func; };
   57|      0|	inline void set_color_func (mc_color_func_t _color_func) { color_func = _color_func; };
   58|      0|	inline void set_normal_func (mc_normal_func_t _normal_func) { normal_func = _normal_func; };
   59|      0|	inline void set_vertex_func (mc_vertex_func_t _vertex_func) { vertex_func = _vertex_func; };
   60|      0|	inline void set_face_completed_func (mc_face_completed_func_t _face_completed_func) { face_completed_func = _face_completed_func; };
   61|       |
   62|       |	void compute (int bUsecache);
   63|       |	void get_triangulation (int *nvertices, float **vertices, int *nfaces, unsigned int **faces);
   64|       |
   65|       |	void get_normal (vec3f &pt, vec3f &normal);
   66|       |
   67|       |protected:
   68|       |	virtual void get_triangulation_pre (void);
   69|       |	virtual void get_triangulation_post (int *nvertices, float **vertices, int *nfaces, unsigned int **faces);
   70|       |
   71|       |	mc_face_completed_func_t face_completed_func;
   72|       |	mc_layer_completed_func_t layer_completed_func;
   73|       |	void *data;
   74|       |
   75|       |private:
   76|       |	void compute_cube (unsigned int iX, unsigned int iY, unsigned iZ);
   77|       |	int orientation[3];
   78|       |	int bBoundary;
   79|       |
   80|       |	float min[3], max[3];
   81|       |	float resolution[3];
   82|       |	float step[3];
   83|       |	float fValue;
   84|       |	
   85|       |	mc_eval_func_t eval_func;
   86|       |	mc_color_func_t color_func;
   87|       |	mc_vertex_func_t vertex_func;
   88|       |	mc_normal_func_t normal_func;
   89|       |
   90|       |	// temporary variables used in mc_compute
   91|       |	float *fValueCached;
   92|       |	int *fIndicesCached;
   93|       |	int iCurrentVertex;
   94|       |};
   95|       |
   96|       |#endif // __SURFACE_IMPLICIT_H__

/workspaces/cg/src/cgmesh/surface_parametric.h:
    1|       |#ifndef __SURFACE_PARAMETRIC_H__
    2|       |#define __SURFACE_PARAMETRIC_H__
    3|       |
    4|       |#include "mesh.h"
    5|       |#include "tensor.h"
    6|       |
    7|       |typedef struct diff_s {
    8|       |	vec3 position;
    9|       |	float dx, dy, dxx, dxy, dyy;
   10|       |	vec3 normal;
   11|       |	vec3 first_fundamental_form;
   12|       |	vec3 second_fundamental_form;
   13|       |} diff_s;
   14|       |
   15|       |class ParametricSurface : public Mesh
   16|       |{
   17|       |public:
   18|      0|	ParametricSurface () {};
   19|      0|	~ParametricSurface () {};
   20|       |
   21|       |public:
   22|       |	virtual int EvaluatePosition (float u, float v, diff_s *diff) = 0;
   23|       |	int Generate (void);
   24|       |	int EvaluateFundamentalForms (diff_s *diff, vec3 dfdu, vec3 dfdv, vec3 dfdudu, vec3 dfdudv, vec3 dfdvdv);
   25|       |	Tensor* EvaluateTensor (diff_s diff);
   26|       |	
   27|       |	unsigned int iNU;
   28|       |	unsigned int iNV;
   29|       |	int bCloseU; // do we close the u border ?
   30|       |	int bCloseV; // do we close the v border ?
   31|       |	int bIndependentCloseU; // do we close independently the extremities u=0 and u=1 ?
   32|       |	int bIndependentCloseV; // do we close independently the extremities v=0 and v=1 ?
   33|       |	int bInverseCloseU;
   34|       |	int bInverseCloseV;
   35|       |	float fParams[4];
   36|       |};
   37|       |
   38|       |//
   39|       |class ParametricSphere : public ParametricSurface
   40|       |{
   41|       |public:
   42|       |	ParametricSphere (unsigned int nu=20, unsigned int nv=20);
   43|      0|	~ParametricSphere () {};
   44|       |	int EvaluatePosition (float u, float v, diff_s *diff);
   45|       |};
   46|       |
   47|       |// 
   48|       |class EllipticHelicoid : public ParametricSurface
   49|       |{
   50|       |public:
   51|       |	EllipticHelicoid (unsigned int nu=20, unsigned int nv=20, float a=1., float b=1., float c=0.2);
   52|      0|	~EllipticHelicoid () {};
   53|       |	int EvaluatePosition (float u, float v, diff_s *diff);
   54|       |};
   55|       |
   56|       |// 
   57|       |class SeaShell : public ParametricSurface
   58|       |{
   59|       |public:
   60|       |	SeaShell (unsigned int nu=20, unsigned int nv=20);
   61|      0|	~SeaShell () {};
   62|       |	int EvaluatePosition (float u, float v, diff_s *diff);
   63|       |};
   64|       |
   65|       |// 
   66|       |class SeaShellVonSeggern : public ParametricSurface
   67|       |{
   68|       |public:
   69|       |	SeaShellVonSeggern (unsigned int nu=20, unsigned int nv=20, float a=.2, float b=1., float c=.1, float n=2.);
   70|      0|	~SeaShellVonSeggern () {};
   71|       |	int EvaluatePosition (float u, float v, diff_s *diff);
   72|       |};
   73|       |
   74|       |class CorkscrewSurface : public ParametricSurface
   75|       |{
   76|       |public:
   77|       |	CorkscrewSurface (unsigned int nu=20, unsigned int nv=20, float a=1., float b=.5);
   78|      0|	~CorkscrewSurface () {};
   79|       |	int EvaluatePosition (float u, float v, diff_s *diff);
   80|       |};
   81|       |
   82|       |// 
   83|       |class MobiusStrip : public ParametricSurface
   84|       |{
   85|       |public:
   86|       |	MobiusStrip (unsigned int nu=20, unsigned int nv=20, float w=.1, float r=.5);
   87|      0|	~MobiusStrip () {};
   88|       |	int EvaluatePosition (float u, float v, diff_s *diff);
   89|       |};
   90|       |
   91|       |// 
   92|       |class RadialWave : public ParametricSurface
   93|       |{
   94|       |public:
   95|       |	RadialWave (unsigned int nu=20, unsigned int nv=20, float radius=10., float height=20., float frequency=.6);
   96|      0|	~RadialWave () {};
   97|       |	int EvaluatePosition (float u, float v, diff_s *diff);
   98|       |};
   99|       |
  100|       |//
  101|       |class ParametricTorus : public ParametricSurface
  102|       |{
  103|       |public:
  104|       |	ParametricTorus (unsigned int nu=20, unsigned int nv=20, float radius1=5., float radius2=2.);
  105|      0|	~ParametricTorus () {};
  106|       |	int EvaluatePosition (float u, float v, diff_s *diff);
  107|       |};
  108|       |
  109|       |/*
  110|       |Mesh* mesh_generate_parametric_surface_trumpet (unsigned int nu, unsigned int nv,
  111|       |						  float s, float t);
  112|       |Mesh* mesh_generate_parametric_surface_cylinder (unsigned int nu, unsigned int nv,
  113|       |						   float r, float h);
  114|       |*/
  115|       |class Breather : public ParametricSurface
  116|       |{
  117|       |public:
  118|       |	Breather (unsigned int nu=20, unsigned int nv=20);
  119|      0|	~Breather () {};
  120|       |	int EvaluatePosition (float u, float v, diff_s *diff);
  121|       |};
  122|       |
  123|       |/*
  124|       |// tubes
  125|       |Mesh* mesh_generate_parametric_surface_helix (unsigned int nu, unsigned int nv);
  126|       |*/
  127|       |
  128|       |//
  129|       |class BorromeanRing : public ParametricSurface
  130|       |{
  131|       |	friend class BorromeanRings;
  132|       |public:
  133|       |	BorromeanRing (unsigned int nu=20, unsigned int nv=20, float param1=2., float param2=1., float r=.2);
  134|      0|	~BorromeanRing () {};
  135|       |	int EvaluatePosition (float u, float v, diff_s *diff);
  136|       |};
  137|       |
  138|       |class BorromeanRings : public Mesh
  139|       |{
  140|       |public:
  141|       |	BorromeanRings (unsigned int nu=20, unsigned int nv=20);
  142|      0|	~BorromeanRings () {};
  143|       |	int EvaluatePosition (float u, float v, diff_s *diff);
  144|       |};
  145|       |/*
  146|       |Mesh* mesh_generate_parametric_surface_borromean_elliptical_rings (unsigned int nu, unsigned int nv);
  147|       |*/
  148|       |
  149|       |class TorusKnot : public ParametricSurface
  150|       |{
  151|       |public:
  152|       |	TorusKnot (unsigned int nu=20, unsigned int nv=20, unsigned int a=3, unsigned int b=4);
  153|      0|	~TorusKnot () {};
  154|       |	int EvaluatePosition (float u, float v, diff_s *diff);
  155|       |};
  156|       |
  157|       |class CinquefoilKnot : public ParametricSurface
  158|       |{
  159|       |public:
  160|       |	CinquefoilKnot (unsigned int nu=20, unsigned int nv=20, unsigned int a=3);
  161|      0|	~CinquefoilKnot () {};
  162|       |	int EvaluatePosition (float u, float v, diff_s *diff);
  163|       |};
  164|       |
  165|       |//
  166|       |class TrefoilKnot1 : public ParametricSurface
  167|       |{
  168|       |public:
  169|       |	TrefoilKnot1 (unsigned int nu=20, unsigned int nv=20);
  170|      0|	~TrefoilKnot1 () {};
  171|       |	int EvaluatePosition (float u, float v, diff_s *diff);
  172|       |};
  173|       |
  174|       |//
  175|       |class TrefoilKnot2 : public ParametricSurface
  176|       |{
  177|       |public:
  178|       |	TrefoilKnot2 (unsigned int nu=20, unsigned int nv=20);
  179|      0|	~TrefoilKnot2 () {};
  180|       |	int EvaluatePosition (float u, float v, diff_s *diff);
  181|       |};
  182|       |
  183|       |
  184|       |
  185|       |//
  186|       |class HyperbolicParaboloid : public ParametricSurface
  187|       |{
  188|       |public:
  189|       |	HyperbolicParaboloid (unsigned int nu=20, unsigned int nv=20, float xmin=-5., float xmax=5., float ymin=-5., float ymax=5.);
  190|      0|	~HyperbolicParaboloid () {};
  191|       |	int EvaluatePosition (float u, float v, diff_s *diff);
  192|       |};
  193|       |
  194|       |class MonkeySaddle : public ParametricSurface
  195|       |{
  196|       |public:
  197|       |	MonkeySaddle (unsigned int nu=20, unsigned int nv=20, float xmin=-5., float xmax=5., float ymin=-5., float ymax=5.);
  198|      0|	~MonkeySaddle () {};
  199|       |	int EvaluatePosition (float u, float v, diff_s *diff);
  200|       |};
  201|       |
  202|       |class Blobs : public ParametricSurface
  203|       |{
  204|       |public:
  205|       |	Blobs (unsigned int nu=20, unsigned int nv=20, float xmin=-5., float xmax=5., float ymin=-5., float ymax=5.);
  206|      0|	~Blobs () {};
  207|       |	int EvaluatePosition (float u, float v, diff_s *diff);
  208|       |};
  209|       |
  210|       |class Drop : public ParametricSurface
  211|       |{
  212|       |public:
  213|       |	Drop (unsigned int nu=20, unsigned int nv=20, float xmin=-5., float xmax=5., float ymin=-5., float ymax=5.);
  214|      0|	~Drop () {};
  215|       |	int EvaluatePosition (float u, float v, diff_s *diff);
  216|       |};
  217|       |
  218|       |class Wave1 : public ParametricSurface
  219|       |{
  220|       |public:
  221|       |	Wave1 (unsigned int nu=20, unsigned int nv=20, float xmin=-5., float xmax=5., float ymin=-5., float ymax=5.);
  222|      0|	~Wave1 () {};
  223|       |	int EvaluatePosition (float u, float v, diff_s *diff);
  224|       |};
  225|       |
  226|       |class Wave2 : public ParametricSurface
  227|       |{
  228|       |public:
  229|       |	Wave2 (unsigned int nu=20, unsigned int nv=20, float xmin=-5., float xmax=5., float ymin=-5., float ymax=5.);
  230|      0|	~Wave2 () {};
  231|       |	int EvaluatePosition (float u, float v, diff_s *diff);
  232|       |};
  233|       |
  234|       |class Weight : public ParametricSurface
  235|       |{
  236|       |public:
  237|       |	Weight (unsigned int nu=20, unsigned int nv=20, float xmin=-5., float xmax=5., float ymin=-5., float ymax=5.);
  238|      0|	~Weight () {};
  239|       |	int EvaluatePosition (float u, float v, diff_s *diff);
  240|       |};
  241|       |
  242|       |class Guimard : public ParametricSurface
  243|       |{
  244|       |public:
  245|       |	Guimard (unsigned int nu=20, unsigned int nv=20, float a=2., float b=3., float c=1.);
  246|      0|	~Guimard () {};
  247|       |	int EvaluatePosition (float u, float v, diff_s *diff);
  248|       |};
  249|       |
  250|       |#endif // __SURFACE_PARAMETRIC_H__

/workspaces/cg/src/cgmesh/tensor.h:
    1|       |#ifndef __TENSOR_H__
    2|       |#define __TENSOR_H__
    3|       |
    4|       |#include "../cgmath/cgmath.h"
    5|       |
    6|       |//
    7|       |// Tensor
    8|       |//
    9|       |class Tensor
   10|       |{
   11|       |public:
   12|       |	typedef enum {CURVATURE_MIN = 0, CURVATURE_MAX, CURVATURE_GAUSSIAN, CURVATURE_MEAN} eCurvature; 
   13|      0|	Tensor () { Reset (); };
   14|      0|	~Tensor () {};
   15|       |	
   16|       |	//
   17|       |	// getters - setters
   18|       |	//
   19|       |	void Reset (void)
   20|      0|		{
   21|      0|			SetNormal (0., 0., 0.);
   22|      0|			SetDirectionMax (0., 0., 0.);
   23|      0|			SetDirectionMin (0., 0., 0.);
   24|      0|			kappa_max = 0.0;
   25|      0|			kappa_min = 0.0;
   26|      0|		}
   27|      0|	void SetKappaMax (float kappa) { kappa_max = kappa; };
   28|      0|	void SetKappaMin (float kappa) { kappa_min = kappa; };
   29|       |
   30|      0|	void SetNormal (float x, float y, float z) { vec3_init (normal, x, y, z);  };
   31|      0|	void SetNormal (vec3 n) { vec3_copy (normal, n); };
   32|      0|	void SetDirectionMax (float x, float y, float z) { vec3_init (direction_max, x, y, z);  };
   33|      0|	void SetDirectionMax (vec3 dmax) { vec3_copy (direction_max, dmax); };
   34|      0|	void SetDirectionMin (float x, float y, float z) { vec3_init (direction_min, x, y, z);  };
   35|      0|	void SetDirectionMin (vec3 dmin) { vec3_copy (direction_min, dmin); };
   36|       |
   37|      0|	void  GetNormal (vec3 n) { vec3_copy (n, normal); };
   38|      0|	float GetKappaMax (void) { return kappa_max; };
   39|      0|	float GetKappaMin (void) { return kappa_min; };
   40|      0|	void  GetDirectionMax (vec3 dmax) { vec3_copy (dmax, direction_max); };
   41|      0|	void  GetDirectionMin (vec3 dmin) { vec3_copy (dmin, direction_min); };
   42|       |
   43|       |	void Dump (void)
   44|      0|		{
   45|      0|			printf ("tensor :\n");
   46|      0|			printf (" normale :\n   %f %f %f\n", normal[0], normal[1], normal[2]);
   47|      0|			printf ("   kappa_max = %f\n", kappa_max);
   48|      0|			printf ("   kappa_min = %f\n", kappa_min);
   49|      0|			printf (" direction max :\n   %f %f %f\n", direction_max[0], direction_max[1], direction_max[2]);
   50|      0|			printf (" direction min :\n   %f %f %f\n", direction_min[0], direction_min[1], direction_min[2]);
   51|      0|		}
   52|       |	
   53|       |	
   54|       |private:
   55|       |	vec3 normal;
   56|       |	float kappa_max, kappa_min;
   57|       |	vec3 direction_max;
   58|       |	vec3 direction_min;
   59|       |};
   60|       |
   61|       |#endif // __TENSOR_H__

/workspaces/cg/src/cgmesh/ticker.cpp:
    1|       |#include <stdlib.h>
    2|       |
    3|       |#include "ticker.h"
    4|       |
    5|       |
    6|       |#ifdef linux
    7|       |
    8|       |Ticker::Ticker ()
    9|   131k|{
   10|   131k|	gettimeofday (&s, NULL);
   11|   131k|}
   12|       |
   13|       |Ticker::~Ticker ()
   14|   131k|{
   15|   131k|}
   16|       |
   17|       |void
   18|       |Ticker::start (void)
   19|  17.8k|{
   20|  17.8k|	gettimeofday (&s, NULL);
   21|  17.8k|}
   22|       |
   23|       |double
   24|       |Ticker::stop (void)
   25|   148k|{
   26|   148k|	gettimeofday (&e, NULL);
   27|   148k|	return ((e.tv_sec - s.tv_sec)*1000000.0 + e.tv_usec - s.tv_usec)*0.000001;
   28|   148k|}
   29|       |
   30|       |void Ticker::evaluate_gettimeofday (void)
   31|      0|{
   32|      0|	if (1)
   33|      0|	{
   34|      0|		int count = 1 * 1000 * 1000 * 1;
   35|      0|		gettimeofday (&s, NULL);
   36|      0|		struct timeval tv_tmp;
   37|      0|		for (int i = 0; i < count; i++)
   38|      0|			gettimeofday(&tv_tmp, NULL);
   39|      0|		gettimeofday (&e, NULL);
   40|      0|		float diff = ((e.tv_sec - s.tv_sec)*1000000.0 + e.tv_usec - s.tv_usec)*0.000001;
   41|      0|		printf("%d calls in %f s = %f s/call\n", count, diff, (double)diff / (double)count);
   42|      0|	}
   43|      0|	else
   44|      0|	{
   45|      0|		struct timespec tv_start, tv_end;
   46|      0|		struct timeval tv_tmp;
   47|      0|		int count = 1 * 1000 * 1000 * 50;
   48|      0|		clockid_t clockid;
   49|      0|		int rv = clock_getcpuclockid(0, &clockid);
   50|      0|		if (rv)
   51|      0|		{
   52|      0|			perror("clock_getcpuclockid");
   53|      0|			return;
   54|      0|		}
   55|       |		
   56|      0|		clock_gettime(clockid, &tv_start);
   57|      0|		for (int i = 0; i < count; i++)
   58|      0|			gettimeofday(&tv_tmp, NULL);
   59|      0|		clock_gettime(clockid, &tv_end);
   60|       |		
   61|      0|		long long diff = (long long)(tv_end.tv_sec - tv_start.tv_sec)*(1*1000*1000*1000);
   62|      0|		diff += (tv_end.tv_nsec - tv_start.tv_nsec);
   63|       |		
   64|      0|		printf("%d cycles in %lld ns = %f ns/cycle\n", count, diff, (double)diff / (double)count);
   65|      0|	}
   66|      0|}
   67|       |
   68|       |#endif // linux
   69|       |
   70|       |
   71|       |#ifdef WIN32
   72|       |Ticker::Ticker ()
   73|       |{
   74|       |	QueryPerformanceFrequency ((LARGE_INTEGER*)&freq);
   75|       |	QueryPerformanceCounter ((LARGE_INTEGER*)&s);
   76|       |}
   77|       |
   78|       |void
   79|       |Ticker::start (void)
   80|       |{
   81|       |	QueryPerformanceCounter ((LARGE_INTEGER*)&s);
   82|       |}
   83|       |
   84|       |double
   85|       |Ticker::stop (void)
   86|       |{
   87|       |	QueryPerformanceCounter ((LARGE_INTEGER*)&e);
   88|       |	//return (double)(e.QuadPart - s.QuadPart)/freq;
   89|       |	return (double)(1000*(e - s))/freq;
   90|       |}
   91|       |
   92|       |#endif // WIN32

/workspaces/cg/src/cgmesh/voxels.h:
    1|       |#ifndef __VOXELS_H__
    2|       |#define __VOXELS_H__
    3|       |
    4|       |#include "../cgimg/cgimg.h"
    5|       |
    6|       |//
    7|       |//
    8|       |//
    9|       |class Voxel
   10|       |{
   11|       |	friend class Voxels;
   12|       |	friend class MengerSponge;
   13|       |public:
   14|       |	Voxel ();
   15|       |	~Voxel ();
   16|       |private:
   17|       |	bool m_bActivated;
   18|       |	unsigned int m_iLabel;
   19|       |	float m_fData;
   20|       |	//void *m_pData;
   21|       |};
   22|       |
   23|       |//
   24|       |//
   25|       |//
   26|       |class Voxels
   27|       |{
   28|       |public:
   29|       |	Voxels (unsigned int _nx=0, unsigned int _ny=0, unsigned int _nz=0);
   30|       |	~Voxels ();
   31|       |
   32|       |	int init (unsigned int nx, unsigned int ny, unsigned int nz);
   33|       |	
   34|       |	int input_vxl (char *filename);
   35|       |	int input_img (Img *img);
   36|       |	int input_imgs (Img **img, unsigned int nImgs);
   37|       |	int input (char *filename);
   38|       |
   39|       |	float get_data (unsigned int i, unsigned int j, unsigned int k);
   40|       |	float get_data_for_intersection (unsigned int i, unsigned int j, unsigned int k);
   41|       |	void get_extremal_values (float *min, float *max);
   42|       |
   43|       |	void smooth_data (int n);
   44|       |	void threshold_data (float threshold);
   45|       |
   46|       |	inline void activate (unsigned int xi, unsigned int yi, unsigned int zi)
   47|      0|	{
   48|      0|		m_pVoxels[xi][yi][zi].m_bActivated = true;
   49|      0|	};
   50|       |	inline void set_label (unsigned int xi, unsigned int yi, unsigned int zi, unsigned int ilabel)
   51|      0|	{
   52|      0|		m_pVoxels[xi][yi][zi].m_iLabel = ilabel;
   53|      0|	};
   54|       |	void inverse_activation (void);
   55|       |
   56|       |	// morphologic operators
   57|       |	void dilation (void);
   58|       |
   59|       |
   60|       |	// label management
   61|       |	void reset_labels (void);
   62|       |
   63|       |	// export methods
   64|       |	int export_slice_XY (char *filename, unsigned int islice);
   65|       |	int export_slice_YZ (char *filename, unsigned int islice);
   66|       |	int export_slice_XZ (char *filename, unsigned int islice);
   67|       |	int triangulate (char *filename);
   68|       |	
   69|       |	int export_cubes (char *filename);
   70|       |	int export_palette_to_mtl (char *mtlfile);
   71|       |
   72|       |protected:
   73|       |	Voxel*** m_pVoxels;
   74|       |	unsigned int m_nx, m_ny, m_nz;
   75|       |	Palette *m_pPalette;
   76|       |};
   77|       |
   78|       |#endif // __VOXELS_H__

/workspaces/cg/src/cgmesh/writer_svg.h:
    1|       |#pragma once
    2|       |
    3|       |#include <list>
    4|       |using namespace std;
    5|       |
    6|       |typedef struct point2D
    7|       |{
    8|      0|	void set (float _x, float _y) { x = _x; y = _y; };
    9|       |	float x,y;
   10|       |} point2D;
   11|       |
   12|       |
   13|       |
   14|       |typedef struct PathStyle
   15|       |{
   16|       |	bool  bClosed;
   17|       |	unsigned char  ucFillR, ucFillG, ucFillB;
   18|       |	unsigned char  ucStrokeR, ucStrokeG, ucStrokeB;
   19|       |	float fStrokeWidth;
   20|       |} PathStyle;
   21|       |
   22|       |//
   23|       |//
   24|       |//
   25|       |class WriterSVG
   26|       |{
   27|       |public:
   28|       |	WriterSVG(void);
   29|       |	~WriterSVG(void);
   30|       |
   31|       |	bool InitFile (char* pFilename);
   32|       |
   33|       |	void WriteHeader (float fWidth, float fHeight);
   34|       |	void WriteFooter (void);
   35|       |
   36|       |	void WriteStyleBegin (char* pStroke = NULL, float fStrokeWidth = 1.0, char * pColorFill = NULL);
   37|       |	void WriteStyleEnd ();
   38|       |
   39|       |	void WriteGroupBegin (char *strId = NULL);
   40|       |	void WriteGroupEnd (void);
   41|       |
   42|       |	void WritePath (list<point2D> listPoints, PathStyle *pathStyle = NULL);
   43|       |	void WritePath (list<list<point2D> > listsPoints, PathStyle *pathStyle = NULL);
   44|       |
   45|       |	static inline void PathStyle_init (PathStyle *pathStyle)
   46|      0|		{
   47|      0|			pathStyle->bClosed = true;
   48|      0|			pathStyle->ucFillR = 255;
   49|      0|			pathStyle->ucFillG = 255;
   50|      0|			pathStyle->ucFillB = 255;
   51|      0|			pathStyle->ucStrokeR = 0;
   52|      0|			pathStyle->ucStrokeG = 0;
   53|      0|			pathStyle->ucStrokeB = 0;
   54|      0|			pathStyle->fStrokeWidth = 1.;
   55|      0|		}
   56|       |
   57|       |private:
   58|       |	FILE* m_pFile;
   59|       |};
   60|       |
   61|       |
   62|       |/*
   63|       |
   64|       |*-> x
   65|       ||
   66|       |V
   67|       |
   68|       |y
   69|       |*/

/workspaces/cg/test/tu_all.cpp:
    1|       |#include <gtest/gtest.h>
    2|       |
    3|      1|int main(int argc, char **argv) {
    4|      1|  ::testing::InitGoogleTest(&argc, argv);
    5|       |
    6|       |  //std::cout << "TEST_DIR '" << TEST_DIR << "'" << std::endl;
    7|      1|  for (int i = 1; i < argc; ++i) {
    8|      0|      std::cout << "Input[" << i << "]: "<< argv[i] << std::endl;
    9|      0|  }
   10|       |
   11|      1|  return RUN_ALL_TESTS();
   12|      1|}

/workspaces/cg/test/tu_cgimg_io.cpp:
    1|       |#include <gtest/gtest.h>
    2|       |
    3|       |#include "../src/cgimg/cgimg.h"
    4|       |
    5|       |TEST(TEST_cgimg_io, tga_ctc16)
    6|      1|{
    7|       |    // context
    8|      1|    Img img;
    9|       |
   10|       |    // action 1
   11|      1|    auto res = img.load("./test/data/tga/ctc16.tga");
   12|       |
   13|       |    // expectations
   14|      1|    EXPECT_EQ(res, 0);
   15|      1|    EXPECT_EQ(img.width(), 128);
   16|      1|    EXPECT_EQ(img.height(), 128);
   17|      1|}
   18|       |
   19|       |TEST(TEST_cgimg_io, tga_ctc24)
   20|      1|{
   21|       |    // context
   22|      1|    Img img;
   23|       |
   24|       |    // action 1
   25|      1|    auto res = img.load("./test/data/tga/ctc24.tga");
   26|       |
   27|       |    // expectations
   28|      1|    EXPECT_EQ(res, 0);
   29|      1|    EXPECT_EQ(img.width(), 128);
   30|      1|    EXPECT_EQ(img.height(), 128);
   31|      1|}
   32|       |
   33|       |TEST(TEST_cgimg_io, tga_ctc32)
   34|      1|{
   35|       |    // context
   36|      1|    Img img;
   37|       |
   38|       |    // action 1
   39|      1|    auto res = img.load("./test/data/tga/ctc32.tga");
   40|       |
   41|       |    // expectations
   42|      1|    EXPECT_EQ(res, 0);
   43|      1|    EXPECT_EQ(img.width(), 128);
   44|      1|    EXPECT_EQ(img.height(), 128);
   45|      1|}

/workspaces/cg/test/tu_cgmath_aabox.cpp:
    1|       |#include <gtest/gtest.h>
    2|       |
    3|       |#include "../src/cgmath/aabox.h"
    4|       |#include "../src/cgmath/geometry.h"
    5|       |
    6|       |TEST(TEST_cgmath_aabox, contains_point)
    7|      1|{
    8|       |    // context
    9|      1|    Vector3 min(0.f, 0.f, 0.f);
   10|      1|    Vector3 max(1.f, 1.f, 1.f);
   11|      1|    AABox aab(min, max);
   12|       |
   13|       |    // action 1
   14|      1|    bool bIsInside = aab.contains(.1f, .2f, .3f);
   15|       |
   16|       |    // expectations
   17|      1|    EXPECT_TRUE(bIsInside);
   18|       |
   19|       |    // action 1
   20|      1|    bIsInside = aab.contains(.1f, -.2f, .3f);
   21|       |
   22|       |    // expectations
   23|      1|    EXPECT_FALSE(bIsInside);
   24|      1|}
   25|       |
   26|       |TEST(TEST_cgmath_aabox, contains_triangle)
   27|      1|{
   28|       |    // context
   29|      1|    Vector3 min(0.f, 0.f, 0.f);
   30|      1|    Vector3 max(1.f, 1.f, 1.f);
   31|      1|    AABox aab(min, max);
   32|       |
   33|      1|    Triangle tri;
   34|      1|    tri.SetVertex(0, .1f, .1f, .1f);
   35|      1|    tri.SetVertex(1, .1f, .2f, .8f);
   36|      1|    tri.SetVertex(2, .2f, .3f, .4f);
   37|       |
   38|       |    // action
   39|      1|    bool bIsInside = aab.contains(tri);
   40|       |
   41|       |    // expectations
   42|      1|    EXPECT_TRUE(bIsInside);
   43|      1|}

/workspaces/cg/test/tu_cgmath_algebra_vector3.cpp:
    1|       |#include <gtest/gtest.h>
    2|       |
    3|       |#include "../src/cgmath/algebra_vector3.h"
    4|       |
    5|      1|TEST(TEST_cgmath, init) {
    6|      1|    int i = 0;
    7|      1|    vec3 a;
    8|      1|    vec3_init(a, 1.f, 1.f, 0.f);
    9|      1|    EXPECT_TRUE(a[0] == 1.f);
   10|      1|    EXPECT_TRUE(a[1] == 1.f);
   11|      1|    EXPECT_TRUE(a[2] == 0.f);
   12|      1|}

/workspaces/cg/test/tu_cgmath_triangle.cpp:
    1|       |#include <gtest/gtest.h>
    2|       |
    3|       |#include "../src/cgmath/geometry.h"
    4|       |
    5|       |TEST(TEST_cgmath_triangle, GetIntersectionWithRay)
    6|      1|{
    7|       |    // context
    8|      1|    Triangle tri;
    9|      1|    tri.SetVertex(0, 0.f, 0.f, 0.f);
   10|      1|    tri.SetVertex(1, 1.f, 1.f, 0.f);
   11|      1|    tri.SetVertex(2, 1.f, 1.f, 2.f);
   12|      1|    vec3 o = {.5f, 0.f, .5f};
   13|      1|    vec3 d = {0.f, 1.f, 0.f};
   14|       |
   15|       |    // action
   16|      1|    float t = 0.f;
   17|      1|    vec3 i = {0.f, 0.f, 0.f};
   18|      1|    vec3 n = {0.f, 0.f, 0.f};
   19|      1|    tri.GetIntersectionWithRay(o, d, &t, i, n);
   20|       |
   21|       |    // expectations
   22|      1|    EXPECT_EQ(t, .5f);
   23|      1|    EXPECT_EQ(i[0], .5f);
   24|      1|    EXPECT_EQ(i[1], .5f);
   25|      1|    EXPECT_EQ(i[2], .5f);
   26|      1|    EXPECT_FLOAT_EQ(n[0], .707107f);
   27|      1|    EXPECT_FLOAT_EQ(n[1], -.707107f);
   28|      1|    EXPECT_EQ(n[2], 0.f);
   29|      1|}

/workspaces/cg/test/tu_cgmesh_audio.cpp:
    1|       |#include <gtest/gtest.h>
    2|       |
    3|       |#include "../src/cgmesh/cgmesh.h"
    4|       |
    5|       |
    6|       |TEST(TEST_cgmesh_audio, rate)
    7|      1|{
    8|       |    // context
    9|      1|    char* input = (char*)"./test/data/M1F1-Alaw-AFsp.wav";
   10|      1|    Audio* audio = new Audio();
   11|      1|    audio->load(input);
   12|      1|    audio->dump();
   13|       |
   14|       |    // action
   15|      1|    auto rate = audio->get_rate();
   16|      1|    auto length = audio->get_length();
   17|       |
   18|       |    // expectations
   19|      1|    EXPECT_EQ(rate, 8000.f);
   20|      1|    EXPECT_EQ(length, 145969);
   21|      1|}
   22|       |
   23|       |TEST(TEST_cgmesh_audio, spectrum)
   24|      1|{
   25|       |    // context
   26|      1|    char* input = (char*)"./test/data/M1F1-Alaw-AFsp.wav";
   27|      1|    Audio* audio = new Audio();
   28|      1|    audio->load(input);
   29|       |
   30|       |    // action
   31|      1|    int nWindows = 1200;
   32|      1|    int nLength = 256;
   33|      1|    float* spectrum = (float*)malloc(nWindows * nLength * sizeof(float));
   34|      1|    float* data = (float*)malloc(nWindows * nLength * sizeof(float));
   35|  1.20k|    for (int i = 0; i < nWindows; i++)
   36|  1.20k|    {
   37|  1.20k|        audio->get_spectrum((audio->get_length()) * i / nWindows, nLength, spectrum);
   38|  1.20k|        data[i * (nLength / 2) + 0] = fabs(spectrum[0]);
   39|   153k|        for (int j = 1; j < nLength / 2; j++)
   40|   152k|        {
   41|   152k|            float real, imag, mod;
   42|   152k|            real = spectrum[j];
   43|   152k|            int spectrum_size = nLength;
   44|   152k|            imag = spectrum[spectrum_size - j];
   45|   152k|            mod = sqrt(real * real + imag * imag);
   46|   152k|            data[i * (nLength / 2) + j] = mod;
   47|   152k|        }
   48|  1.20k|    }
   49|       |
   50|       |    // expectations
   51|      1|    EXPECT_EQ(data[0], 308.832031f);
   52|       |
   53|      1|    return;
   54|       |
   55|       |    // export
   56|       |
   57|       |    // obj
   58|      1|    FILE* ptr = fopen("fft.obj", "w");
   59|      0|    for (int i = 0; i < nWindows; i++)
   60|      0|        for (int j = 0; j < nLength / 2; j++)
   61|      0|            fprintf(ptr, "v %f %f %f\n", (float)i, (float)j, data[i * (nLength / 2) + j]);
   62|      0|    for (int i = 0; i < (nWindows - 1); i++)
   63|      0|        for (int j = 0; j < (nLength / 2 - 2); j++)
   64|      0|            fprintf(ptr, "f %d %d %d %d \n", 1 + i * (nLength / 2) + j, 1 + (i + 1) * (nLength / 2) + j, 1 + (i + 1) * (nLength / 2) + j + 1, 1 + i * (nLength / 2) + j + 1);
   65|       |
   66|      0|    fclose(ptr);
   67|       |
   68|       |
   69|      0|    float max_level = 0.;
   70|      0|    for (int i = 0; i < nWindows; i++)
   71|      0|        for (int j = 0; j < nLength / 2 - 1; j++)
   72|      0|            if (max_level < data[i * (nLength / 2) + j])
   73|      0|                max_level = data[i * (nLength / 2) + j];
   74|      0|    printf("max_level = %f\n", max_level);
   75|       |
   76|       |    // output fft.ppm
   77|      0|    ptr = fopen("fft.ppm", "w");
   78|      0|    fprintf(ptr, "P3\n%d %d\n255\n", nLength / 2, nWindows);
   79|      0|    for (int i = 0; i < nWindows; i++)
   80|      0|        for (int j = 0; j < nLength / 2; j++)
   81|      0|        {
   82|      0|            float max_level_v = max_level / (0.6 * j);
   83|      0|            int r, g, b;
   84|      0|            color_jet_int(data[i * (nLength / 2) + j] / max_level_v, &r, &g, &b);
   85|      0|            if (r > 255) r = 255;
   86|      0|            if (g > 255) g = 255;
   87|      0|            if (b > 255) b = 255;
   88|      0|            fprintf(ptr, "%d %d %d\n", r, g, b);
   89|      0|        }
   90|      0|    fclose(ptr);
   91|      0|}
   92|       |
   93|       |TEST(TEST_cgmesh_audio, audio_2_image)
   94|      1|{
   95|       |    // context
   96|      1|    char* input = (char*)"./test/data/M1F1-Alaw-AFsp.wav";
   97|      1|    Audio* audio = new Audio();
   98|      1|    audio->load(input);
   99|       |
  100|       |    // action
  101|      1|    Img* img = audio_2_image(audio);
  102|       |
  103|       |    // expectations
  104|      1|    int ret = img->save("audio.bmp");
  105|      1|    EXPECT_EQ(ret, 0);
  106|      1|}

/workspaces/cg/test/tu_cgmesh_io.cpp:
    1|       |#include <gtest/gtest.h>
    2|       |
    3|       |#include "../src/cgmesh/cgmesh.h"
    4|       |
    5|       |
    6|       |TEST(TEST_cgmesh_io, stl)
    7|      1|{
    8|       |    // context
    9|      1|    Mesh_half_edge* mesh = new Mesh_half_edge();
   10|       |
   11|       |    // action
   12|      1|    mesh->load("./test/data/BunnyLowPoly.stl");
   13|       |
   14|       |    // expectations
   15|      1|    EXPECT_EQ(mesh->GetNVertices(), 1986);
   16|      1|    EXPECT_EQ(mesh->GetNFaces(), 662);
   17|       |
   18|       |    // export
   19|      1|    return;
   20|       |
   21|      1|    mesh->export_statistics("stats.html");
   22|      0|}
   23|       |
   24|       |TEST(TEST_cgmesh_io, 3ds)
   25|      1|{
   26|       |    // context
   27|      1|    Object3D* object = new Object3D();
   28|       |
   29|       |    // action
   30|      1|    object->import_file("./test/data/sink.3ds");
   31|       |
   32|       |    // expectations
   33|      1|    auto & list = object->GetMeshes();
   34|      1|    ASSERT_EQ(list.size(), 4);
   35|      1|}

/workspaces/cg/test/tu_cgmesh_raytracer.cpp:
    1|       |#include <gtest/gtest.h>
    2|       |
    3|       |#include <stdio.h>
    4|       |#include <math.h>
    5|       |#include <stdlib.h>
    6|       |#include <string.h>
    7|       |#include <time.h>
    8|       |
    9|       |#ifndef WIN32
   10|       |#include <sys/time.h>
   11|       |#endif
   12|       |
   13|       |
   14|       |#include "../src/cgmath/cgmath.h"
   15|       |#include "../src/cgmesh/cgmesh.h"
   16|       |#include "../src/cgmesh/raytracer.h"
   17|       |
   18|       |void CreateScene (Scene *pScene, int id)
   19|      4|{
   20|      4|	switch (id)
   21|      4|	{
   22|      1|	case 0:
   23|      1|	{
   24|      1|		Plane *pPlane = new Plane ();
   25|       |		/*
   26|       |		pPlane->m_pMaterial->SetAmbient (0.1, 0.21, 0.7);
   27|       |		pPlane->m_pMaterial->SetDiffuse (0.1, 0.3, 0.2);
   28|       |		pPlane->m_pMaterial->SetSpecular (0.3, 0.8, 0.1);
   29|       |		*/
   30|       |		//pScene->AddObject (pPlane);
   31|       |
   32|      1|		Sphere *pSphere1 = new Sphere ();
   33|      1|		pSphere1->SetCenter (1., 0., 1.);
   34|      1|		pSphere1->SetRadius (1.);
   35|       |		/*
   36|       |		pSphere1->m_pMaterial->SetAmbient (0.7, 0.1, 0.3);
   37|       |		pSphere1->m_pMaterial->SetDiffuse (0.7, 0.3, 0.2);
   38|       |		pSphere1->m_pMaterial->SetSpecular (0.5, 0.1, 0.1);
   39|       |		*/
   40|      1|		pScene->AddObject (pSphere1);
   41|       |		
   42|      1|		Sphere *pSphere2 = new Sphere ();
   43|      1|		pSphere2->SetCenter (-1., 0., 0.);
   44|      1|		pSphere2->SetRadius (2.);
   45|      1|		pScene->AddObject (pSphere2);
   46|      1|	}
   47|      1|	break;
   48|      1|	case 1:
   49|      1|	{
   50|      1|		Plane *pPlane = new Plane ();
   51|       |		/*
   52|       |		pPlane->m_pMaterial->SetAmbient (0.1, 0.21, 0.7);
   53|       |		pPlane->m_pMaterial->SetDiffuse (0.1, 0.3, 0.2);
   54|       |		pPlane->m_pMaterial->SetSpecular (0.3, 0.8, 0.1);
   55|       |		*/
   56|       |		//pScene->AddObject (pPlane);
   57|       |
   58|      1|		Sphere *pSphere = new Sphere ();
   59|      1|		pSphere->SetCenter (0., 0., 3.);
   60|      1|		pSphere->SetRadius (1.5);
   61|      1|		pScene->AddObject (pSphere);
   62|       |
   63|      1|		Torus *pTorus = new Torus ();
   64|      1|		pTorus->R = 5.;
   65|      1|		pTorus->r = 1.;
   66|       |		//pTorus->SetCenter (-3., -3., 0.);
   67|       |		//pTorus->SetRadius (1.);
   68|      1|		pScene->AddObject (pTorus);
   69|      1|	}
   70|      1|	break;
   71|      1|	case 2:
   72|      1|	{
   73|      1|		float fScale = 4.;
   74|      1|		float r=0.3*fScale;
   75|      1|		float z=-r;
   76|      1|		unsigned int n=50;//300;
   77|     51|		for (unsigned int j=0; j<n; j++)
   78|     50|		{
   79|     50|			Sphere *pSphere = new Sphere ();
   80|     50|			float fAngle = j*180./(3.14159*1.5*n)-3.14159/3.;
   81|     50|			float rtmp = fScale*r*(sin(acos(z/r)));
   82|     50|			pSphere->SetCenter (-rtmp*cos(fAngle), rtmp*sin(fAngle), z*fScale);
   83|     50|			pSphere->SetRadius (0.13*fScale);
   84|     50|			pScene->AddObject (pSphere);
   85|     50|			z += 2.*r/n;
   86|     50|		}
   87|      1|	}
   88|      1|	break;
   89|      1|	case 3:
   90|      1|	{
   91|       |		//Plane *pPlane = new Plane ();
   92|       |		//pScene->AddObject (pPlane);
   93|       |
   94|      1|		Mesh *pMesh = new Mesh ();
   95|      1|		pMesh->load ("./test/data/BunnyLowPoly.stl");
   96|      1|		pMesh->FlipFaces();
   97|      1|		mat3 m;
   98|      1|		mat3_init_rotation_from_euler_angles (m, 0., 0., M_PI/2.);
   99|      1|		pMesh->transform (m);
  100|      1|		pMesh->centerize ();
  101|      1|		pMesh->scale (1./5.);
  102|      1|		pMesh->computebbox();
  103|      1|		if (pMesh)
  104|      1|		{
  105|      1|			if (0) // isolated triangles
  106|      0|			{
  107|       |				// init a material for the mesh
  108|      0|				MaterialColorExt *pMaterials[2];
  109|      0|				pMaterials[0] = new MaterialColorExt();
  110|      0|				pMaterials[1] = new MaterialColorExt();
  111|      0|				pMaterials[0]->Init_From_Library (MaterialColorExt::EMERALD);
  112|      0|				pMaterials[1]->Init_From_Library (MaterialColorExt::RUBY);
  113|       |
  114|      0|				float *pVertices = pMesh->m_pVertices;
  115|      0|				for (unsigned int i=0; i<pMesh->m_nFaces; i++)
  116|      0|				{
  117|      0|					Face *face = pMesh->m_pFaces[i];
  118|      0|					unsigned int a = face->m_pVertices[0];
  119|      0|					unsigned int b = face->m_pVertices[1];
  120|      0|					unsigned int c = face->m_pVertices[2];
  121|       |				
  122|      0|					RenderedTriangle *pTri = new RenderedTriangle ();
  123|      0|					pTri->Init (pVertices[3*a], pVertices[3*a+1], pVertices[3*a+2],
  124|      0|								pVertices[3*b], pVertices[3*b+1], pVertices[3*b+2],
  125|      0|								pVertices[3*c], pVertices[3*c+1], pVertices[3*c+2]);
  126|      0|					pTri->SetMaterial (pMaterials[i%2]);
  127|      0|					pScene->AddObject (pTri);
  128|      0|				}
  129|      0|			}
  130|      1|			else // all the mesh
  131|      1|			{
  132|      1|				pScene->AddObject (pMesh);
  133|      1|			}
  134|      1|		}
  135|      1|	}
  136|      1|	break;
  137|      0|	default:
  138|      0|		break;
  139|      4|	}
  140|      4|}
  141|       |
  142|       |static std::shared_ptr< Raytracer > InitRaytracer(unsigned int idScene)
  143|      4|{
  144|      4|	auto pRaytracer = std::make_shared< Raytracer >();
  145|       |
  146|       |	// camera
  147|      4|	Camera* pCamera = pRaytracer->GetCamera();
  148|      4|	pCamera->SetPosition(0., -30., 0.);
  149|      4|	pCamera->SetDirection(0., 1., 0.);
  150|      4|	pCamera->SetUp(0., 0., 1.);
  151|       |
  152|       |	// lights
  153|      4|	Light* pLight1 = pRaytracer->GetLight(0);
  154|      4|	pLight1->SetPosition(-30., -30., 2.);
  155|       |	//pRaytracer->AddLight (pLight1);
  156|       |
  157|      4|	Light* pLight2 = new Light();
  158|      4|	pLight2->SetPosition(30., 0., 0.);
  159|       |	//pRaytracer->AddLight (pLight2);
  160|       |
  161|       |	// scene
  162|      4|	Scene* pScene = pRaytracer->GetScene();
  163|      4|	CreateScene(pScene, idScene);
  164|       |
  165|      4|	return pRaytracer;
  166|      4|}
  167|       |
  168|       |TEST(TEST_cgmath_raytracer, scene0)
  169|      1|{
  170|       |	// Context
  171|      1|	auto pRaytracer = InitRaytracer(0);
  172|       |
  173|       |	// Action
  174|      1|	Img* pImg = pRaytracer->Trace(128, 128);
  175|      1|	pImg->save("raytracer0.bmp");
  176|       |
  177|       |	// Expectations
  178|      1|	EXPECT_EQ(pImg->width(), 128);
  179|      1|	EXPECT_EQ(pImg->height(), 128);
  180|       |
  181|       |	// cleaning
  182|      1|	delete pImg;
  183|       |
  184|      1|	return;
  185|       |
  186|       |	// export stats
  187|      0|	pRaytracer->Dump();
  188|      0|	pRaytracer->export_statistics("raytracer_stats_scene0.html");
  189|      0|}
  190|       |
  191|       |TEST(TEST_cgmath_raytracer, scene1)
  192|      1|{
  193|       |	// Context
  194|      1|	auto pRaytracer = InitRaytracer(1);
  195|       |
  196|       |	// Action
  197|      1|	Img* pImg = pRaytracer->Trace(128, 128);
  198|      1|	pImg->save("raytracer1.bmp");
  199|       |
  200|       |	// Expectations
  201|      1|	EXPECT_EQ(pImg->width(), 128);
  202|      1|	EXPECT_EQ(pImg->height(), 128);
  203|       |
  204|       |	// cleaning
  205|      1|	delete pImg;
  206|       |
  207|      1|	return;
  208|       |
  209|       |	// export stats
  210|      0|	pRaytracer->Dump();
  211|      0|	pRaytracer->export_statistics("raytracer_stats_scene0.html");
  212|      0|}
  213|       |
  214|       |TEST(TEST_cgmath_raytracer, scene2)
  215|      1|{
  216|       |	// Context
  217|      1|	auto pRaytracer = InitRaytracer(2);
  218|       |
  219|       |	// Action
  220|      1|	Img* pImg = pRaytracer->Trace(128, 128);
  221|      1|	pImg->save("raytracer2.bmp");
  222|       |
  223|       |	// Expectations
  224|      1|	EXPECT_EQ(pImg->width(), 128);
  225|      1|	EXPECT_EQ(pImg->height(), 128);
  226|       |
  227|       |	// cleaning
  228|      1|	delete pImg;
  229|       |
  230|      1|	return;
  231|       |
  232|       |	// export stats
  233|      0|	pRaytracer->Dump();
  234|      0|	pRaytracer->export_statistics("raytracer_stats_scene0.html");
  235|      0|}
  236|       |
  237|       |TEST(TEST_cgmath_raytracer, scene3)
  238|      1|{
  239|       |	// Context
  240|      1|	auto pRaytracer = InitRaytracer(3);
  241|       |
  242|       |	// Action
  243|      1|	Img* pImg = pRaytracer->Trace(128, 128);
  244|      1|	pImg->save("raytracer3.bmp");
  245|       |
  246|       |	// Expectations
  247|      1|	EXPECT_EQ(pImg->width(), 128);
  248|      1|	EXPECT_EQ(pImg->height(), 128);
  249|       |
  250|       |	// cleaning
  251|      1|	delete pImg;
  252|       |
  253|      1|	return;
  254|       |
  255|       |	// export stats
  256|      0|	pRaytracer->Dump();
  257|      0|	pRaytracer->export_statistics("raytracer_stats_scene0.html");
  258|      0|}

/workspaces/cg/test/tu_cgmesh_surface_basic.cpp:
    1|       |#include <gtest/gtest.h>
    2|       |
    3|       |#include "../src/cgmesh/cgmesh.h"
    4|       |
    5|       |
    6|       |TEST(TEST_cgmesh_surface_basic, teapot)
    7|      1|{
    8|       |    // action
    9|      1|    Mesh* mesh = CreateTeapot();
   10|       |
   11|       |    // expectations
   12|      1|    EXPECT_EQ(mesh->GetNVertices(), 1767);
   13|      1|    EXPECT_EQ(mesh->GetNFaces(), 2256);
   14|      1|}
   15|       |
   16|       |TEST(TEST_cgmesh_surface_basic, klein_bottle)
   17|      1|{
   18|       |    // action
   19|      1|    printf("########\n");
   20|      1|    Mesh* mesh = CreateKleinBottle(10, 10);
   21|       |
   22|       |    // expectations
   23|      1|    EXPECT_EQ(mesh->GetNVertices(), 121);
   24|      1|    EXPECT_EQ(mesh->GetNFaces(), 200);
   25|      1|}

