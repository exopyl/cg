name: SQ
on:
  push:
    branches:
      - main
  pull_request:
    types: [opened, synchronize, reopened]
jobs:
  build:
    name: Build
    runs-on: ubuntu-latest
    env:
      BUILD_WRAPPER_OUT_DIR: build_wrapper_output_directory # Directory where build-wrapper output will be placed
    steps:
      - name: Install dependencies
        run: sudo apt-get install build-essential clang llvm libgtest-dev gcovr
      - name: Versions
        run: |
          echo && cmake --version
          echo && clang++ --version
          echo && llvm-cov --version
          
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Shallow clones should be disabled for a better relevancy of analysis

      - name: Run coverage
        working-directory: ${{github.workspace}}
        run: |
          sh coverage.sh
         
      - name: Convert existing coverage.info to SonarQube XML
        run: |
          cat > convert_lcov.py << 'EOF'
          #!/usr/bin/env python3
          import xml.etree.ElementTree as ET
          import re

          def lcov_to_sonarqube(lcov_file, output_file):
              root = ET.Element('coverage', version='1')
              current_file = None
              
              with open(lcov_file, 'r') as f:
                  for line in f:
                      line = line.strip()
                      
                      if line.startswith('SF:'):
                          # Nouveau fichier source
                          filepath = line[3:]
                          # Convertir en chemin relatif
                          filepath = re.sub(r'^/home/runner/work/cg/cg/', '', filepath)
                          current_file = ET.SubElement(root, 'file', path=filepath)
                      
                      elif line.startswith('DA:') and current_file is not None:
                          # Données de couverture de ligne
                          match = re.match(r'DA:(\d+),(\d+)', line)
                          if match:
                              line_num = match.group(1)
                              exec_count = int(match.group(2))
                              covered = 'true' if exec_count > 0 else 'false'
                              ET.SubElement(current_file, 'lineToCover',
                                          lineNumber=line_num,
                                          covered=covered)
              
              # Écrire le fichier XML
              tree = ET.ElementTree(root)
              ET.indent(tree, space='  ')
              tree.write(output_file, encoding='UTF-8', xml_declaration=True)
              print(f"Converted {lcov_file} to {output_file}")

          if __name__ == '__main__':
              lcov_to_sonarqube('coverage.info', 'coverage.xml')
          EOF
          
          python3 convert_lcov.py
          
          echo "=== First 100 lines of coverage.xml ==="
          head -100 coverage.xml
          
          echo "=== Statistics ==="
          echo "Total files: $(grep -c '<file path' coverage.xml || echo 0)"
          echo "Total lines: $(grep -c 'lineToCover' coverage.xml || echo 0)"



#      - name: cmake
#        run: |
#          cmake -S . -B build -DCMAKE_EXPORT_COMPILE_COMMANDS=ON
#          cmake --build build
#          cp build/compile_commands.json .

      - name: Run build-wrapper
        run: |
          curl -L -o build-wrapper.zip https://sonarcloud.io/static/cpp/build-wrapper-linux-x86.zip
          unzip build-wrapper.zip
          cmake -S . -B build \
            -DCMAKE_C_COMPILER=gcc \
            -DCMAKE_CXX_COMPILER=g++ \
            -DCMAKE_EXPORT_COMPILE_COMMANDS=ON
          ./build-wrapper-linux-x86/build-wrapper-linux-x86-64 --out-dir ${{ env.BUILD_WRAPPER_OUT_DIR }} cmake --build build/
          ls -l
          cat build/compile_commands.json | head -50
          ls -l ${{ env.BUILD_WRAPPER_OUT_DIR }}
          cat ${{ env.BUILD_WRAPPER_OUT_DIR }}/compile_commands.json | head -50

      - name: Download sonar-scanner
        run: |
          curl -L -o sonar-scanner.zip https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-6.2.1.4610-linux-x64.zip
          unzip -q sonar-scanner.zip
          echo "$PWD/sonar-scanner-6.2.1.4610-linux-x64/bin" >> $GITHUB_PATH

      - name: Run SonarScanner
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          sonar-scanner \
            -Dsonar.projectKey=exopyl_cg \
            -Dsonar.organization=exopyl \
            -Dsonar.sources=src \
            -Dsonar.cfamily.build-wrapper-output=${{ env.BUILD_WRAPPER_OUT_DIR }} \
            -Dsonar.coverageReportPaths=coverage.xml \
            -Dsonar.host.url=https://sonarcloud.io

#      - name: Sonarcloud Scan
#        uses: sonarsource/sonarcloud-github-action@v2
#        env:
#          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
#        with:
#          args: >
#            -Dsonar.projectKey=exopyl_cg
#            -Dsonar.organization=exopyl
#            -Dsonar.sources=.
#            -Dsonar.exclusions=build/**,**/CMakeFiles/**
#            -Dsonar.cfamily.build-wrapper-output=${{ env.BUILD_WRAPPER_OUT_DIR }}
#            -X

#-Dsonar.cfamily.build-wrapper-output=${{ env.BUILD_WRAPPER_OUT_DIR }}
#-Dsonar.cfamily.compile-commands=build/compile_commands.json
#-Dsonar.cfamily.gcov.reportsPath=coverage.info
          
#      - name: Run sonar-scanner
#        env:
#          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
#          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
#        run: |
#          sonar-scanner \
#            -Dsonar.cfamily.compile-commands=${{ env.BUILD_WRAPPER_OUT_DIR }}/compile_commands.json \
#            -Dsonar.cfamily.gcov.reportsPath=coverage.info
